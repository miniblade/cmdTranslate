STRACE（1）一般命令手册STRACE（1）



名称
       strace  - 跟踪系统调用和信号

概要
       strace [-CdffhikqrtttTvVxxy] [-In] [-bexecve] [-eexpr] ... [-acolumn]
       [-ofile] [-sstrsize] [-Ppath] ... -ppid ... / [-D] [-Evar [= val]] ...
       [-uusername] command [args]

       strace -c [df] [-In] [-bexecve] [-eexpr] ... [-Ooverhead] [-Ssortby]
       -ppid ... / [-D] [-Evar [= val]] ... [-uusername] command [args]

描述
       在最简单的情况下，strace运行指定的命令直到它退出。
       它拦截并记录由a调用的系统调用
       过程和过程接收的信号。的名字
       每个系统调用，其参数和返回值都打印在上面
       标准错误或使用-o选项指定的文件。

       strace是一种有用的诊断，指导和调试工具。 SYS-
       tem管理员，诊断员和麻烦射击者都会找到它
       对于解决源所针对的程序的问题是非常宝贵的
       不容易获得，因为它们不需要按顺序重新编译
       跟踪他们。学生，黑客和过于好奇的人会发现这一点
       关于系统及其系统调用，可以学到很多东西
       跟踪普通程序。程序员会发现自那以后
       系统调用和信号是在用户/内核上发生的事件
       接口，仔细检查这个边界对bug非常有用
       隔离，健全检查和试图捕捉竞争条件。

       跟踪中的每一行都包含系统调用名称，后跟其名称
       括号中的参数及其返回值。来自strac-的一个例子
       命令“cat / dev / null”是：

       open（“/ dev / null”，O_RDONLY）= 3

       错误（通常返回值为-1）具有错误符号和错误
       附加字符串。

       open（“/ foo / bar”，O_RDONLY）= -1 ENOENT（没有这样的文件或目录）

       信号被打印为信号符号和解码的siginfo结构。一个
       从打扰和打断命令“睡眠666”中摘录的是：

       sigsuspend（[] <未完成...>
       --- SIGINT {si_signo = SIGINT，si_code = SI_USER，si_pid = ...} ---
       +++被SIGINT +++杀死

       如果正在执行系统调用，同时正在执行另一个系统调用
       从不同的线程/进程调用然后strace将尝试保留
       这些事件的顺序，并将正在进行的呼叫标记为unfin-
       ished。当呼叫返回时，它将被标记为已恢复。

       [pid 28772] select（4，[3]，NULL，NULL，NULL <未完成...>
       [pid 28779] clock_gettime（CLOCK_REALTIME，{1130322148,939977000}）= 0
       [pid 28772] <...选择恢复>）= 1（在[3]中）

       通过信号传递中断（可重启的）系统呼叫是
       处理不同，因为内核终止系统调用
       在信号处理程序完成后安排立即重新执行。

       读（0,0x7ffff72cf5cf，1）=？ ERESTARTSYS（待重启）
       --- SIGALRM ...... ---
       rt_sigreturn（0xe）= 0
       read（0，“”，1）= 0

       争论以象征性的形式印有激情。这个例子
       显示执行“>> xyzzy”输出重定向的shell：

       打开（“xyzzy”，O_WRONLY | O_APPEND | O_CREAT，0666）= 3

       这里open的第三个参数是通过分解标志来解码的
       参数进入其三个按位OR成分并打印模式
       传统的八进制价值。传统或本地使用不同的地方
       从ANSI或POSIX开始，后一种形式是首选。在某些情况下，
       事实证明，strace输出比源更具可读性。

       结构指针被取消引用，成员显示为
       适当。在所有情况下，参数都以大多数类似的格式进行格式化
       时尚可能。例如，命令的本质是“ls -l
       / dev / null“被捕获为：

       lstat（“/ dev / null”，{st_mode = S_IFCHR | 0666，st_rdev = makedev（1,3），...}）= 0

       注意'struct stat'参数是如何被解引用的以及每个mem-如何
       ber象征性地显示。特别是，观察st_mode如何
       成员被仔细解码为符号和数字的按位或
       值。另请注意，在此示例中，lstat的第一个参数
       是系统调用的输入，第二个参数是输出。
       由于如果系统调用失败，则不会修改输出参数，
       可能并不总是取消引用。例如，重试“ls
       -l“具有不存在的文件的示例生成以下行：

       lstat（“/ foo / bar”，0xb004）= -1 ENOENT（没有这样的文件或目录）

       在这种情况下，门廊灯亮，但没有人在家。

       字符指针被取消引用并打印为C字符串。非-
       字符串中的打印字符通常由普通C表示
       逃脱码。只有字符串的第一个strsize（默认为32）字节
       印刷;较长的字符串后面附加一个省略号
       收盘报价。这是来自“ls -l”的一行，其中有getpwuid库
       例程正在读取密码文件：

       read（3，“root :: 0：0：System Administrator：/”...，1024）= 422

       虽然结构使用花括号，简单指针和注释来注释
       数组使用方括号打印，逗号分隔ele-
       发言：。以下是系统上命令“id”的示例
       补充组ID：

       getgroups（32，[100,0]）= 2

       另一方面，也使用方括号显示位集
       set元素仅由空格分隔。这是shell prepar-
       执行外部命令：

       sigprocmask（SIG_BLOCK，[CHLD TTOU]，[]）= 0

       这里的第二个参数是两个信号的位集，SIGCHLD和SIGT-
       TOU。在某些情况下，位集非常完整，可以打印出未设置的位
       元素更有价值。在这种情况下，位集以a为前缀
       像这样：

       sigprocmask（SIG_UNBLOCK，〜[]，NULL）= 0

       这里第二个参数表示所有信号的完整集合。

OPTIONS
       -c为每个系统调用计算时间，调用和错误
                   并报告程序退出的摘要。在Linux上，
                   这会尝试显示系统时间（花费的CPU时间）
                   在内核中运行）独立于挂钟
                   时间。如果-c仅与-f或-F（下方）一起使用
                   保留所有跟踪进程的总计。

       -C喜欢-c但也可以打印常规输出
                   cesses正在运行。

       -D将跟踪器进程作为独立的孙子运行，而不是作为
                   tracee的父母。这减少了可见光
                   通过保持直接的跟踪效果
                   呼叫过程的孩子。

       -d显示一些strace本身的调试输出
                   标准错误。

       -f跟踪子进程，因为它们是由cur-创建的
                   由于fork（2）而临近跟踪进程，
                   vfork（2）和clone（2）系统调用。请注意-p
                   PID -f将附加进程PID的所有线程（如果它）
                   是多线程的，不仅是thread_id =的线程
                   PID。

       -ff如果-o filename选项生效，则每个
                   cesses trace写入filename.pid，其中pid是
                   每个进程的数字进程ID。这是
                   与-c不兼容，因为没有每个进程计数
                   被存管。

       -F此选项现已过时且具有相同的选项
                   功能为-f。

       -h打印帮助摘要。

       -i在时间打印指令指针
                   系统调用。

       -k打印跟踪的pro-的执行堆栈跟踪
                   每次系统调用后（实验）。这个
                   选项仅在构建strace时可用
                   libunwind。

       -q禁止有关附加，分离等的消息。
                   重定向输出时会自动发生这种情况
                   到一个文件，命令直接运行而不是
                   连接。

       -qq如果给定两次，则禁止有关进程退出的消息
                   状态。

       -r在进入每个系统时打印相对时间戳
                   呼叫。这记录了之间的时差
                   连续系统调用的开始。

       -t使用一天中的时间为跟踪的每一行添加前缀。

       -tt如果给出两次，打印的时间将包括
                   微秒。

       -ttt如果给定三次，打印的时间将包括
                   将打印微秒和前导部分
                   作为自纪元以来的秒数。

       -T显示系统调用所花费的时间。这个记录
                   开头和开头之间的时差
                   每个系统调用结束。

       -w总结开头之间的时差
                   并且每个系统调用结束。默认是总和 - 
                   系统时间。

       -v打印环境的未缩写版本，stat，
                   termios等电话。这些结构非常好
                   在调用中很常见，因此显示默认行为
                   一个合理的结构成员子集。用这个
                   获得所有血腥细节的选项。

       -V打印strace的版本号。

       -x以十六进制字符串形式打印所有非ASCII字符串
                   格式。

       -xx以十六进制字符串格式打印所有字符串。

       -y与文件描述符相关的打印路径 - 
                   发言：。

       -yy打印与协议相关的协议特定信息
                   套接字文件描述符。

       -a column对齐特定列中的返回值（默认值
                   第40栏）。

       -b syscall如果指定了syscall，则从跟踪中分离
                   处理。目前，只有execve系统调用是支持
                   移植。如果要跟踪，此选项很有用
                   多线程进程因此需要-f，但是
                   不想跟踪它（可能非常复杂）
                   儿童。

       -e expr一个限定表达式，用于修改哪些事件
                   跟踪或如何跟踪它们。格式
                   表达是：

                             [预选赛=] [！]值1 [，值2] ...

                   限定符是trace，abbrev，verbose之一，
                   原始，信号，读取或写入和价值是合格的
                   依赖于fier的符号或数字。默认资格
                   微不足道。使用感叹号否定
                   价值观。例如，-e open意味着 - 
                   erally -e trace = open，这反过来意味着只跟踪
                   开放系统调用。相比之下，-e trace =！open
                   意味着跟踪除open之外的每个系统调用。在
                   另外，特殊值all和none都没有
                   明显的意义。

                   请注意，有些shell使用感叹号
                   历史扩张甚至在引用的论点中。如果
                   所以，你必须用一个逃避感叹号
                   反斜杠。

       -e trace = set
                   仅跟踪指定的系统调用集。该
                   -c选项对于确定哪个系统很有用
                   调用可能对跟踪有用。例如，
                   trace = open，close，read，write表示只跟踪
                   这四个系统调用。制作时要小心
                   关于用户/内核边界的推论，如果只有一个
                   正在监视系统调用的子集。该
                   默认是trace = all。

       -e trace =文件
                   跟踪将文件名作为的所有系统调用
                   论点。您可以将其视为缩写
                   for -e trace = open，stat，chmod，unlink，...这是
                   有助于查看该过程的参考文件 - 
                   ING。此外，使用缩写将
                   确保您不会意外忘记包含
                   列表中的lstat之类的调用。 Betchya愿意 - 
                   得到那个。

       -e trace = process
                   跟踪涉及流程管理的所有系统调用 - 
                   换货。这对于观看分叉，等待，
                   并执行一个过程的步骤。

       -e trace =网络
                   跟踪所有与网络相关的系统调用。

       -e trace =信号
                   跟踪所有与信号相关的系统调用

       -e trace = ipc
                   跟踪所有与IPC相关的系统调用。

       -e trace = desc
                   跟踪所有文件描述符相关的系统调用

       -e trace =记忆
                   跟踪所有内存映射相关的系统调用。

       -e abbrev = set
                   缩写打印每个成员的输出
                   大型结构。默认值为abbrev = all。该
                   -v选项具有abbrev = none的效果。

       -e verbose = set
                   指定的系统集的解除引用结构
                   tem电话。默认值为verbose = all。

       -e raw = set打印指定集的原始未解码参数
                   系统调用。此选项具有效果
                   导致所有参数以十六进制打印。
                   如果你不信任decod-这是非常有用的
                   或者你需要知道的实际数值
                   一个论点。

       -e signal = set
                   仅跟踪指定的信号子集。该
                   默认是signal = all。例如，signal =！ SIGIO
                   （或signal =！io）会导致SIGIO信号无效
                   跟踪。

       -e read = set执行所有的完整十六进制和ASCII转储
                   从标准中列出的文件描述符读取的数据
                   fied set。例如，要查看所有输入活动
                   文件描述符3和5使用-e read = 3,5。注意
                   这与正常的追踪无关
                   读取（2）由...控制的系统调用
                   选项-e trace = read。

       -e write = set
                   执行所有的完整十六进制和ASCII转储
                   写入规范中列出的文件描述符的数据
                   ified set。例如，查看所有输出活动
                   在文件描述符3和5上使用-e write = 3,5。注意
                   这与正常的追踪无关
                   write（2）系统调用由...控制
                   选项-e trace = write。

        - 我可以打断
                   当strace可以被信号中断（例如
                   按^ C）。 1：没有信号被阻挡; 2：致命
                   解码系统调用时阻塞信号
                   （默认）; 3：致命信号总是被阻挡
                   （默认为'-o FILE PROG'）; 4：致命信号和
                   SIGTSTP（^ Z）始终被阻止（有用）
                   strace -o FILE PROG不会停在^ Z）。

       -o filename将跟踪输出写入文件文件名
                   而不是stderr。如果使用-ff，请使用filename.pid。
                   如果参数以“|”开头或者用'！'那么
                   其余的论点被视为一个命令和所有
                   输出通过管道输送到它。这对于pip来说很方便
                   调试输出到没有的程序
                   影响已执行程序的重定向。

       -O overhead为追踪系统调用设置开销 - 
                   头微秒。这对覆盖很有用
                   猜测多少时间的默认启发式算法
                   仅用于测量定时系统调用的时间
                   使用-c选项。启发式的准确性
                   可以通过计算给定的程序运行而无需计量
                   追踪（使用时间（1））并比较累积
                   系统调用时间到使用的总产生量
                   -C。

       -p pid使用进程ID pid和附加到进程
                   开始追踪。跟踪可以在任何时候终止
                   时间由键盘中断信号（CTRL-C）。
                   strace将通过脱离自己来回应
                   追踪过程让它（它们）继续下去
                   运行。多个-p选项可用于附加
                   除了命令之外的许多进程（即
                   如果给出至少一个-p选项，则为可选项）。 -p
                   支持“`pidof PROG`”语法。

       -P path仅跟踪系统调用访问路径。多个-P
                   选项可用于指定多个路径。

       -s strsize指定要打印的最大字符串大小（
                   默认是32）。请注意，文件名不是重要的 - 
                   字符串，总是打印完整。

       -S sortby对由-c打印的直方图的输出进行排序
                   按指定标准的选项。法律价值观是
                   时间，电话，名字和什么都没有（默认是时间）。

       -u username运行命令，包含用户ID，组ID和补充
                   用户名的心理组。此选项仅适用
                   以root身份运行时有用并启用正确的
                   执行setuid和/或setgid二进制文件。除非
                   这个选项用于setuid和setgid程序
                   没有有效权限执行。

       -E var = val在其环境列表中使用var = val运行命令
                   变量。

       -E var从继承的环境列表中删除var
                   将变量传递给命令之前的变量。

诊断
       当命令退出时，strace以相同的退出状态退出。如果
       命令由信号终止，strace终止自身
       相同的信号，因此strace可以用作包装过程
       对调用父进程透明。请注意，父母 - 
       子关系（信号停止通知，getppid（）值，
       跟踪进程与其父进程之间没有保留
       除非使用-D。

       使用-p时，除非存在，否则strace的退出状态为零
       在进行跟踪时出现意外错误。

设置安装
       如果strace安装setuid到root然后调用用户
       将能够附加和跟踪任何用户拥有的进程。
       此外，还将执行setuid和setgid程序
       用正确的有效权限追踪。既然只有用户
       应该允许具有完全root权限的受信任者执行这些操作
       事情，只有将strace作为setuid安装到root才有意义
       当可以执行它的用户仅限于这些用户时
       谁有这种信任。例如，安装一个有意义
       特殊版本的strace，模式为'rwsr-xr--'，用户root和
       组跟踪，其中跟踪组的成员是受信任的用户。
       如果您确实使用此功能，请记得安装非
       setuid版本的strace供普通lusers使用。

也可以看看
       ltrace（1），time（1），ptrace（2），proc（5）

笔记
       遗憾的是系统产生了如此多的追踪混乱
       使用共享库。

       考虑系统调用输入和输出是有益的
       作为跨用户/内核边界的数据流。因为用户 - 
       空间和内核空间是分开的，并且是地址保护的，它是
       有时候可以对过程进行演绎推论
       使用输入和输出作为命题的行为。

       在某些情况下，系统调用将与记录的不同
       行为或具有不同的名称。例如，在System V-
       派生系统的真实时间（2）系统调用不需要
       参数和stat函数被称为xstat并且需要一个
       额外的主要论点。这些差异是正常的，但是
       系统调用接口的特性和特性
       由C库包装函数计算。

       一些系统调用在不同的架构中有不同的名称 - 
       真实和个性。在这些情况下，系统调用过滤
       和打印使用匹配对应__NR_ * ker-的名称
       tracee的建筑和个性的nel宏。那里
       这个一般规则有两个例外：arm_fadvise64_64（2）
       ARM系统调用和xtensa_fadvise64_64（2）Xtensa系统调用是
       tered并打印为fadvise64_64（2）。

       在某些平台上，使用-p附加的进程
       选项可能会观察到来自当前系统的虚假EINTR返回
       tem调用不可重启。 （理想情况下，所有系统调用
       应该在strace attach上重新启动，使附件不可见
       跟踪进程，但一些系统调用不是。
       可以说，这种行为的每个实例都是内核错误。）
       如果这个过程可能会对过程产生不可预测的影响
       进程无需重启系统调用。

BUGS
       使用setuid位的程序没有有效的用户ID
       被追踪时的特权。

       跟踪过程运行缓慢。

       可以保留从命令下降的跟踪过程
       在中断信号（CTRL-C）之后运行。

       -i选项受到弱支持。

历史
       原始的strace是由Paul Kranenburg为SunOS和
       受其微量效用的启发。 SunOS版本的strace
       被移植到Linux并由Branko Lankester加强，他也是
       写了Linux内核支持。尽管保罗发布了
       在1992年的Strace 2.5中，Branko的作品是基于Paul的1.5
       从1991年开始。1993年，Rick Sladkey合并了2.5
       SunOS和Linux的第二个版本，添加了许多
       来自SVR4的桁架（1）的特征，并产生了一个strace
       在两个平台上工作。 1994年里克将strace移植到SVR4
       和Solaris并编写了自动配置支持。在
       1995年，他将strace移植到Irix并厌倦了写自己
       在第三人称。

问题
       应该向strace邮件报告strace的问题
       列出<strace-devel@lists.sourceforge.net>。



                                  2010-03-30 STRACE（1）
