t searches for previous occurrences.
       character-search-backward (M-C-])
              A character is read and point is moved to the previous occurrence of that character.
              A negative count searches for subsequent occurrences.
       skip-csi-sequence
              Read enough characters to consume a multi-key sequence such  as  those  defined  for
              keys  like  Home  and  End.   Such sequences begin with a Control Sequence Indicator
              (CSI), usually ESC-[.  If this sequence  is  bound  to  "\[",  keys  producing  such
              sequences will have no effect unless explicitly bound to a readline command, instead
              of inserting stray characters into the editing buffer.  This is unbound by  default,
              but usually bound to ESC-[.
       insert-comment (M-#)
              Without  a  numeric  argument,  the  value of the readline comment-begin variable is
              inserted at the beginning of the current line.  If a numeric argument  is  supplied,
              this  command  acts  as a toggle:  if the characters at the beginning of the line do
              not match the value of comment-begin, the value is inserted, otherwise  the  charac‐
              ters  in  comment-begin are deleted from the beginning of the line.  In either case,
              the line is accepted as if a newline had been typed.   The  default  value  of  com‐
              ment-begin  causes  this  command  to  make  the current line a shell comment.  If a
              numeric argument causes the comment character to be removed, the line will  be  exe‐
              cuted by the shell.
       glob-complete-word (M-g)
              The word before point is treated as a pattern for pathname expansion, with an aster‐
              isk implicitly appended.  This pattern is used to generate a list of  matching  file
              names for possible completions.
       glob-expand-word (C-x *)
              The  word  before point is treated as a pattern for pathname expansion, and the list
              of matching file names is inserted, replacing the word.  If a  numeric  argument  is
              supplied, an asterisk is appended before pathname expansion.
       glob-list-expansions (C-x g)
              The  list  of  expansions that would have been generated by glob-expand-word is dis‐
              played, and the line is redrawn.  If a numeric argument is supplied, an asterisk  is
              appended before pathname expansion.
       dump-functions
              Print all of the functions and their key bindings to the readline output stream.  If
              a numeric argument is supplied, the output is formatted in such a way that it can be
              made part of an inputrc file.
       dump-variables
              Print all of the settable readline variables and their values to the readline output
              stream.  If a numeric argument is supplied, the output is formatted in  such  a  way
              that it can be made part of an inputrc file.
       dump-macros
              Print all of the readline key sequences bound to macros and the strings they output.
              If a numeric argument is supplied, the output is formatted in such a way that it can
              be made part of an inputrc file.
       display-shell-version (C-x C-v)
              Display version information about the current instance of bash.

   Programmable Completion
       When word completion is attempted for an argument to a command for which a completion spec‐
       ification (a compspec) has been defined using the complete builtin (see SHELL BUILTIN  COM‐
       MANDS below), the programmable completion facilities are invoked.

       First, the command name is identified.  If the command word is the empty string (completion
       attempted at the beginning of an empty line), any compspec defined with the  -E  option  to
       complete is used.  If a compspec has been defined for that command, the compspec is used to
       generate the list of possible completions for the word.  If the  command  word  is  a  full
       pathname,  a compspec for the full pathname is searched for first.  If no compspec is found
       for the full pathname, an attempt is made to find a compspec for the portion following  the
       final  slash.  If those searches do not result in a compspec, any compspec defined with the
       -D option to complete is used as the default.

       Once a compspec has been found, it is used to generate the list of matching  words.   If  a
       compspec  is  not found, the default bash completion as described above under Completing is
       performed.

       First, the actions specified by the compspec are used.  Only matches which are prefixed  by
       the  word  being  completed are returned.  When the -f or -d option is used for filename or
       directory name completion, the shell variable FIGNORE is used to filter the matches.

       Any completions specified by a pathname expansion pattern to the -G  option  are  generated
       next.   The  words  generated  by the pattern need not match the word being completed.  The
       GLOBIGNORE shell variable is not used to filter the matches, but the  FIGNORE  variable  is
       used.

       Next,  the  string specified as the argument to the -W option is considered.  The string is
       first split using the characters in the IFS special variable as delimiters.  Shell  quoting
       is  honored.   Each word is then expanded using brace expansion, tilde expansion, parameter
       and variable expansion, command substitution, and arithmetic expansion, as described  above
       under  EXPANSION.   The results are split using the rules described above under Word Split‐
       ting.  The results of the expansion are prefix-matched against the  word  being  completed,
       and the matching words become the possible completions.

       After  these  matches have been generated, any shell function or command specified with the
       -F and -C options is invoked.  When the command or  function  is  invoked,  the  COMP_LINE,
       COMP_POINT,  COMP_KEY, and COMP_TYPE variables are assigned values as described above under
       Shell Variables.  If a shell function is being invoked, the COMP_WORDS and COMP_CWORD vari‐
       ables  are  also  set.   When the function or command is invoked, the first argument is the
       name of the command whose arguments are being completed, the second argument  is  the  word
       being  completed,  and the third argument is the word preceding the word being completed on
       the current command line.  No filtering of the generated completions against the word being
       completed  is  performed;  the  function  or command has complete freedom in generating the
       matches.

       Any function specified with -F is invoked first.  The function may use  any  of  the  shell
       facilities,  including  the  compgen  builtin described below, to generate the matches.  It
       must put the possible completions in the COMPREPLY array variable.

       Next, any command specified with the -C option is invoked in an environment  equivalent  to
       command substitution.  It should print a list of completions, one per line, to the standard
       output.  Backslash may be used to escape a newline, if necessary.

       After all of the possible completions are generated,  any  filter  specified  with  the  -X
       option is applied to the list.  The filter is a pattern as used for pathname expansion; a &
       in the pattern is replaced with the text of the word being completed.  A literal &  may  be
       escaped  with a backslash; the backslash is removed before attempting a match.  Any comple‐
       tion that matches the pattern will be removed from the list.  A leading ! negates the  pat‐
       tern; in this case any completion not matching the pattern will be removed.

       Finally,  any prefix and suffix specified with the -P and -S options are added to each mem‐
       ber of the completion list, and the result is returned to the readline completion  code  as
       the list of possible completions.

       If  the  previously-applied actions do not generate any matches, and the -o dirnames option
       was supplied to complete when the  compspec  was  defined,  directory  name  completion  is
       attempted.

       If the -o plusdirs option was supplied to complete when the compspec was defined, directory
       name completion is attempted and any matches are added to the results of the other actions.

       By default, if a compspec is found, whatever it generates is  returned  to  the  completion
       code  as  the  full  set  of  possible  completions.   The default bash completions are not
       attempted, and the readline default of filename completion is disabled.  If the -o  bashde‐
       fault  option was supplied to complete when the compspec was defined, the bash default com‐
       pletions are attempted if the compspec generates no matches.  If the -o default option  was
       supplied  to  complete when the compspec was defined, readline's default completion will be
       performed if the compspec (and, if attempted, the default  bash  completions)  generate  no
       matches.

       When  a compspec indicates that directory name completion is desired, the programmable com‐
       pletion functions force readline to append a slash to completed names  which  are  symbolic
       links  to  directories,  subject  to  the  value of the mark-directories readline variable,
       regardless of the setting of the mark-symlinked-directories readline variable.

       There is some support for dynamically modifying completions.  This is most useful when used
       in  combination  with  a  default completion specified with complete -D.  It's possible for
       shell functions executed as completion handlers  to  indicate  that  completion  should  be
       retried  by  returning an exit status of 124.  If a shell function returns 124, and changes
       the compspec associated with the command on which completion is being  attempted  (supplied
       as the first argument when the function is executed), programmable completion restarts from
       the beginning, with an attempt to find a new compspec for that command.  This allows a  set
       of completions to be built dynamically as completion is attempted, rather than being loaded
       all at once.

       For instance, assuming that there is a library of compspecs, each kept  in  a  file  corre‐
       sponding  to  the name of the command, the following default completion function would load
       completions dynamically:

       _completion_loader()
       {
            . "/etc/bash_completion.d/$1.sh" >/dev/null 2>&1 && return 124
       }
       complete -D -F _completion_loader


HISTORY
       When the -o history option to the set builtin is enabled, the shell provides access to  the
       command history, the list of commands previously typed.  The value of the HISTSIZE variable
       is used as the number of commands to save in a history list.  The text of the last HISTSIZE
       commands  (default  500) is saved.  The shell stores each command in the history list prior
       to parameter and variable expansion (see EXPANSION above) but after  history  expansion  is
       performed, subject to the values of the shell variables HISTIGNORE and HISTCONTROL.

       On  startup,  the  history  is  initialized  from  the  file named by the variable HISTFILE
       (default ~/.bash_history).  The file named by the value of HISTFILE is truncated, if neces‐
       sary,  to  contain no more than the number of lines specified by the value of HISTFILESIZE.
       When the history file is read, lines beginning with the history comment character  followed
       immediately by a digit are interpreted as timestamps for the preceding history line.  These
       timestamps are optionally displayed depending on the value of the HISTTIMEFORMAT  variable.
       When  an interactive shell exits, the last $HISTSIZE lines are copied from the history list
       to $HISTFILE.  If the histappend shell option is enabled  (see  the  description  of  shopt
       under  SHELL BUILTIN COMMANDS below), the lines are appended to the history file, otherwise
       the history file is overwritten.   If  HISTFILE  is  unset,  or  if  the  history  file  is
       unwritable,  the  history is not saved.  If the HISTTIMEFORMAT variable is set, time stamps
       are written to the history file, marked with the history comment character, so they may  be
       preserved  across  shell  sessions.  This uses the history comment character to distinguish
       timestamps from other history lines.  After saving the history, the history file  is  trun‐
       cated  to  contain no more than HISTFILESIZE lines.  If HISTFILESIZE is not set, no trunca‐
       tion is performed.

       The builtin command fc (see SHELL BUILTIN COMMANDS below) may be used to list or  edit  and
       re-execute  a  portion  of the history list.  The history builtin may be used to display or
       modify the history list and manipulate the history file.  When using command-line  editing,
       search commands are available in each editing mode that provide access to the history list.

       The  shell  allows control over which commands are saved on the history list.  The HISTCON‐
       TROL and HISTIGNORE variables may be set to cause the shell to save only a  subset  of  the
       commands  entered.   The  cmdhist  shell option, if enabled, causes the shell to attempt to
       save each line of a multi-line command in the same history entry, adding  semicolons  where
       necessary  to preserve syntactic correctness.  The lithist shell option causes the shell to
       save the command with embedded newlines instead of semicolons.  See the description of  the
       shopt  builtin  below under SHELL BUILTIN COMMANDS for information on setting and unsetting
       shell options.

HISTORY EXPANSION
       The shell supports a history expansion feature that is similar to the history expansion  in
       csh.   This  section describes what syntax features are available.  This feature is enabled
       by default for interactive shells, and can be disabled using  the  +H  option  to  the  set
       builtin  command (see SHELL BUILTIN COMMANDS below).  Non-interactive shells do not perform
       history expansion by default.

       History expansions introduce words from the history list into the input stream,  making  it
       easy  to repeat commands, insert the arguments to a previous command into the current input
       line, or fix errors in previous commands quickly.

       History expansion is performed immediately after a complete line is read, before the  shell
       breaks  it  into words.  It takes place in two parts.  The first is to determine which line
       from the history list to use during substitution.  The second is to select portions of that
       line  for inclusion into the current one.  The line selected from the history is the event,
       and the portions of that line that are acted upon are words.  Various modifiers are  avail‐
       able  to  manipulate the selected words.  The line is broken into words in the same fashion
       as when reading input, so that several metacharacter-separated words surrounded  by  quotes
       are  considered  one word.  History expansions are introduced by the appearance of the his‐
       tory expansion character, which is ! by default.  Only backslash (\) and single quotes  can
       quote the history expansion character.

       Several  characters  inhibit  history  expansion if found immediately following the history
       expansion character, even if it is unquoted: space, tab, newline, carriage return,  and  =.
       If the extglob shell option is enabled, ( will also inhibit expansion.

       Several shell options settable with the shopt builtin may be used to tailor the behavior of
       history expansion.  If the histverify shell option is enabled (see the description  of  the
       shopt builtin below), and readline is being used, history substitutions are not immediately
       passed to the shell parser.  Instead, the expanded line is reloaded into the readline edit‐
       ing  buffer  for further modification.  If readline is being used, and the histreedit shell
       option is enabled, a failed history substitution will be reloaded into the readline editing
       buffer  for  correction.   The  -p option to the history builtin command may be used to see
       what a history expansion will do before using it.  The -s option to the history builtin may
       be  used to add commands to the end of the history list without actually executing them, so
       that they are available for subsequent recall.

       The shell allows control of the various characters used by the history expansion  mechanism
       (see the description of histchars above under Shell Variables).  The shell uses the history
       comment character to mark history timestamps when writing the history file.

   Event Designators
       An event designator is a reference to a command line entry in the history list.  Unless the
       reference is absolute, events are relative to the current position in the history list.

       !      Start  a  history  substitution,  except when followed by a blank, newline, carriage
              return, = or ( (when the extglob shell option is enabled using the shopt builtin).
       !n     Refer to command line n.
       !-n    Refer to the current command minus n.
       !!     Refer to the previous command.  This is a synonym for `!-1'.
       !string
              Refer to the most recent command preceding the current position in the history  list
              starting with string.
       !?string[?]
              Refer to the most recent command preceding the current postition in the history list
              containing string.  The trailing ? may be omitted if string is followed  immediately
              by a newline.
       ^string1^string2^
              Quick  substitution.   Repeat  the previous command, replacing string1 with string2.
              Equivalent to ``!!:s/string1/string2/'' (see Modifiers below).
       !#     The entire command line typed so far.

   Word Designators
       Word designators are used to select desired words from the event.  A : separates the  event
       specification  from  the  word designator.  It may be omitted if the word designator begins
       with a ^, $, *, -, or %.  Words are numbered from the beginning of the line, with the first
       word being denoted by 0 (zero).  Words are inserted into the current line separated by sin‐
       gle spaces.

       0 (zero)
              The zeroth word.  For the shell, this is the command word.
       n      The nth word.
       ^      The first argument.  That is, word 1.
       $      The last argument.
       %      The word matched by the most recent `?string?' search.
       x-y    A range of words; `-y' abbreviates `0-y'.
       *      All of the words but the zeroth.  This is a synonym for `1-$'.  It is not  an  error
              to  use  *  if  there is just one word in the event; the empty string is returned in
              that case.
       x*     Abbreviates x-$.
       x-     Abbreviates x-$ like x*, but omits the last word.

       If a word designator is supplied without an event specification, the  previous  command  is
       used as the event.

   Modifiers
       After  the optional word designator, there may appear a sequence of one or more of the fol‐
       lowing modifiers, each preceded by a `:'.

       h      Remove a trailing file name component, leaving only the head.
       t      Remove all leading file name components, leaving the tail.
       r      Remove a trailing suffix of the form .xxx, leaving the basename.
       e      Remove all but the trailing suffix.
       p      Print the new command but do not execute it.
       q      Quote the substituted words, escaping further substitutions.
       x      Quote the substituted words as with q, but break into words at blanks and newlines.
       s/old/new/
              Substitute new for the first occurrence of old in the event line.  Any delimiter can
              be  used in place of /.  The final delimiter is optional if it is the last character
              of the event line.  The delimiter may be quoted in old and new with a  single  back‐
              slash.   If  & appears in new, it is replaced by old.  A single backslash will quote
              the &.  If old is null, it is set to the last old substituted, or,  if  no  previous
              history substitutions took place, the last string in a !?string[?]  search.
       &      Repeat the previous substitution.
       g      Cause changes to be applied over the entire event line.  This is used in conjunction
              with `:s' (e.g., `:gs/old/new/') or `:&'.  If used with `:s', any delimiter  can  be
              used  in place of /, and the final delimiter is optional if it is the last character
              of the event line.  An a may be used as a synonym for g.
       G      Apply the following `s' modifier once to each word in the event line.

SHELL BUILTIN COMMANDS
       Unless otherwise noted, each builtin  command  documented  in  this  section  as  accepting
       options  preceded  by  - accepts -- to signify the end of the options.  The :, true, false,
       and test builtins do not accept options and do not treat -- specially.  The  exit,  logout,
       break,  continue,  let,  and  shift  builtins accept and process arguments beginning with -
       without requiring --.  Other builtins that  accept  arguments  but  are  not  specified  as
       accepting options interpret arguments beginning with - as invalid options and require -- to
       prevent this interpretation.
       : [arguments]
              No effect; the command does nothing beyond expanding arguments  and  performing  any
              specified redirections.  A zero exit code is returned.

        .  filename [arguments]
       source filename [arguments]
              Read  and execute commands from filename in the current shell environment and return
              the exit status of the last command executed from filename.  If  filename  does  not
              contain  a slash, file names in PATH are used to find the directory containing file‐
              name.  The file searched for in PATH need not be executable.  When bash  is  not  in
              posix  mode,  the current directory is searched if no file is found in PATH.  If the
              sourcepath option to the shopt builtin command  is  turned  off,  the  PATH  is  not
              searched.  If any arguments are supplied, they become the positional parameters when
              filename is executed.  Otherwise  the  positional  parameters  are  unchanged.   The
              return  status  is  the status of the last command exited within the script (0 if no
              commands are executed), and false if filename is not found or cannot be read.

       alias [-p] [name[=value] ...]
              Alias with no arguments or with the -p option prints the list of aliases in the form
              alias  name=value  on  standard  output.   When  arguments are supplied, an alias is
              defined for each name whose value is given.  A trailing space in  value  causes  the
              next word to be checked for alias substitution when the alias is expanded.  For each
              name in the argument list for which no value is supplied, the name and value of  the
              alias  is printed.  Alias returns true unless a name is given for which no alias has
              been defined.

       bg [jobspec ...]
              Resume each suspended job jobspec in the background, as if it had been started  with
              &.   If  jobspec  is not present, the shell's notion of the current job is used.  bg
              jobspec returns 0 unless run when job control is disabled or, when run with job con‐
              trol  enabled,  any  specified jobspec was not found or was started without job con‐
              trol.

       bind [-m keymap] [-lpsvPSV]
       bind [-m keymap] [-q function] [-u function] [-r keyseq]
       bind [-m keymap] -f filename
       bind [-m keymap] -x keyseq:shell-command
       bind [-m keymap] keyseq:function-name
       bind readline-command
              Display current readline key and function bindings, bind a key sequence to  a  read‐
              line  function  or macro, or set a readline variable.  Each non-option argument is a
              command as it would appear in .inputrc, but each binding or command must  be  passed
              as  a  separate  argument;  e.g., '"\C-x\C-r": re-read-init-file'.  Options, if sup‐
              plied, have the following meanings:
              -m keymap
                     Use keymap as the keymap to be affected by the subsequent bindings.   Accept‐
                     able  keymap  names  are  emacs,  emacs-standard, emacs-meta, emacs-ctlx, vi,
                     vi-move, vi-command, and vi-insert.  vi is equivalent to vi-command; emacs is
                     equivalent to emacs-standard.
              -l     List the names of all readline functions.
              -p     Display  readline  function names and bindings in such a way that they can be
                     re-read.
              -P     List current readline function names and bindings.
              -s     Display readline key sequences bound to macros and the strings they output in
                     such a way that they can be re-read.
              -S     Display readline key sequences bound to macros and the strings they output.
              -v     Display readline variable names and values in such a way that they can be re-
                     read.
              -V     List current readline variable names and values.
              -f filename
                     Read key bindings from filename.
              -q function
                     Query about which keys invoke the named function.
              -u function
                     Unbind all keys bound to the named function.
              -r keyseq
                     Remove any current binding for keyseq.
              -x keyseq:shell-command
                     Cause  shell-command  to  be  executed  whenever  keyseq  is  entered.   When
                     shell-command  is  executed, the shell sets the READLINE_LINE variable to the
                     contents of the readline line buffer and the READLINE_POINT variable  to  the
                     current location of the insertion point.  If the executed command changes the
                     value of READLINE_LINE or READLINE_POINT, those new values will be  reflected
                     in the editing state.

              The return value is 0 unless an unrecognized option is given or an error occurred.

       break [n]
              Exit  from  within  a for, while, until, or select loop.  If n is specified, break n
              levels.  n must be ≥ 1.  If n is greater than the number  of  enclosing  loops,  all
              enclosing  loops are exited.  The return value is non-zero when n is ≤ 0; Otherwise,
              break returns 0 value.

       builtin shell-builtin [arguments]
              Execute the specified shell builtin, passing it arguments, and return its exit  sta‐
              tus.   This  is  useful  when  defining a function whose name is the same as a shell
              builtin, retaining the functionality of the builtin within  the  function.   The  cd
              builtin is commonly redefined this way.  The return status is false if shell-builtin
              is not a shell builtin command.

       caller [expr]
              Returns the context of any active subroutine call (a shell function or a script exe‐
              cuted with the . or source builtins).  Without expr, caller displays the line number
              and source filename of the current subroutine call.  If a  non-negative  integer  is
              supplied  as expr, caller displays the line number, subroutine name, and source file
              corresponding to that position in the current  execution  call  stack.   This  extra
              information  may be used, for example, to print a stack trace.  The current frame is
              frame 0.  The return value is 0 unless the shell is not executing a subroutine  call
              or expr does not correspond to a valid position in the call stack.

       cd [-L|[-P [-e]]] [dir]
              Change  the  current  directory  to dir.  The variable HOME is the default dir.  The
              variable CDPATH defines the search path for the directory containing dir.   Alterna‐
              tive  directory names in CDPATH are separated by a colon (:).  A null directory name
              in CDPATH is the same as the current directory, i.e., ``.''.  If dir begins  with  a
              slash (/), then CDPATH is not used. The -P option says to use the physical directory
              structure instead of following symbolic links (see also the -P  option  to  the  set
              builtin  command);  the  -L  option forces symbolic links to be followed.  If the -e
              option is supplied with -P, and the current working directory cannot be successfully
              determined  after a successful directory change, cd will return an unsuccessful sta‐
              tus.  An argument of - is equivalent to $OLDPWD.  If a non-empty directory name from
              CDPATH  is used, or if - is the first argument, and the directory change is success‐
              ful, the absolute pathname of the new working directory is written to  the  standard
              output.   The  return value is true if the directory was successfully changed; false
              otherwise.

       command [-pVv] command [arg ...]
              Run command with args suppressing the normal shell  function  lookup.  Only  builtin
              commands or commands found in the PATH are executed.  If the -p option is given, the
              search for command is performed using a default value fo