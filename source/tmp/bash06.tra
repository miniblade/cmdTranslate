t搜索先前的事件。
       字符搜索后退（M-C-]）
              读取一个字符，并将点移动到该字符的上一个匹配项。
              否定计数搜索后续事件。
       跳过-CSI-序列
              读取足够多的字符以使用多键序列，例如为其定义的序列
              像Home和End这样的键。此类序列以控制序列指示符开始
              （CSI），通常是ESC- [。如果此序列绑定到“\ [”，则生成此序列
              除非显式绑定到readline命令，否则序列将无效
              将杂散字符插入编辑缓冲区。默认情况下，这是未绑定的，
              但通常与ESC- [。
       插入注释（M-＃）
              如果没有数字参数，则readline comment-begin变量的值为
              插入当前行的开头。如果提供了数字参数，
              此命令用作切换：如果行开头的字符执行
              不匹配comment-begin的值，插入值，否则为charac-
              comment-begin中的ters将从行的开头删除。在任一情况下，
              接受该行，就像输入换行符一样。 com的默认值
              ment-begin导致此命令使当前行成为shell注释。如果一个
              数字参数导致注释字符被删除，该行将是exe-
              由贝壳提供。
       全球完整词（M-g）
              点之前的单词被视为路径名扩展的模式，带有aster-
              isk隐式附加。此模式用于生成匹配文件列表
              可能的完成名称。
       glob-expand-word（C-x *）
              点之前的单词被视为路径名扩展的模式和列表
              插入匹配的文件名，替换该单词。如果是数字参数
              如果提供，则在路径名扩展之前附加星号。
       glob-list-expansions（C-x g）
              由glob-expand-word生成的扩展列表是dis-
              玩了，重新划线。如果提供了数字参数，则为星号
              在路径名扩展之前附加。
       翻斗功能
              将所有函数及其键绑定打印到readline输出流。如果
              提供了一个数字参数，输出的格式可以是这样
              成为inputrc文件的一部分。
       翻斗变量
              将所有可设置的readline变量及其值打印到readline输出
              流。如果提供了数字参数，则以这种方式格式化输出
              它可以成为inputrc文件的一部分。
       翻斗宏
              打印绑定到宏的所有readline键序列及其输出的字符串。
              如果提供了数字参数，则输出的格式可以是这样
              成为inputrc文件的一部分。
       display-shell-version（C-x C-v）
              显示有关当前bash实例的版本信息。

   可编程完成
       当尝试对完成规范的命令的参数进行单词完成时
       使用完整的内置函数定义了compification（compspec）（参见SHELL BUILTIN COM-
       下面的MANDS），调用可编程完成工具。

       首先，识别命令名称。如果命令字是空字符串（完成
       尝试在空行的开头），使用-E选项定义的任何compspec
       完成使用。如果已为该命令定义了compspec，则使用compspec
       生成该单词的可能完成列表。如果命令字是完整的
       pathname，首先搜索完整路径名的compspec。如果没有找到compspec
       对于完整路径名，尝试查找后面的部分的compspec
       最后的斜线。如果这些搜索没有导致compspec，则任何compspec定义为
       -D选项完成用作默认值。

       找到compspec后，它将用于生成匹配单词列表。如果一个
       找不到compspec，默认的bash完成如上面的Completing中所述
       执行。

       首先，使用compspec指定的操作。只有前缀为的匹配项
       正在填写的单词将被退回。当-f或-d选项用于文件名或
       目录名称完成，shell变量FIGNORE用于过滤匹配。

       将生成由路径名扩展模式指定到-G选项的任何完成
       下一个。模式生成的单词不需要与正在完成的单词匹配。该
       GLOBIGNORE shell变量不用于过滤匹配，但是FIGNORE变量是
       用过的。

       接下来，将考虑指定为-W选项的参数的字符串。字符串是
       首先使用IFS特殊变量中的字符作为分隔符进行拆分。壳报价
       很荣幸。然后使用大括号扩展，波浪扩展，参数扩展每个单词
       和变量扩展，命令替换和算术扩展，如上所述
       在扩展下。使用上面在Word Split-下面描述的规则拆分结果
       婷。扩展的结果与正在完成的单词匹配前缀，
       并且匹配的单词成为可能的完成。

       生成这些匹配后，使用指定的任何shell函数或命令
       -F和-C选项被调用。当调用命令或函数时，COMP_LINE，
       COMP_POINT，COMP_KEY和COMP_TYPE变量分配值如上所述
       壳变量。如果正在调用shell函数，则COMP_WORDS和COMP_CWORD变量
       还设置了ables。调用函数或命令时，第一个参数是
       正在完成参数的命令的名称，第二个参数是单词
       正在完成，第三个参数是在完成的单词之前的单词
       当前的命令行。没有过滤生成的完成对词
       已完成;函数或命令完全自由地生成
       火柴。

       首先调用使用-F指定的任何函数。该函数可以使用任何shell
       设施，包括下面描述的compgen，用于生成匹配。它
       必须将可能的完成放在COMPREPLY数组变量中。

       接下来，在相当于的环境中调用使用-C选项指定的任何命令
       命令替换。它应该打印一个完成列表，每行一个，到标准
       输出。如有必要，可以使用反斜杠来转义换行符。

       生成所有可能的完成后，使用-X指定的任何过滤器
       选项应用于列表。过滤器是用于路径名扩展的模式;一个 ＆
       在模式中替换为正在完成的单词的文本。文字和可能
       用反斜杠逃脱;在尝试匹配之前删除反斜杠。任何补充 - 
       匹配模式的将从列表中删除。领先！否定了
       燕鸥;在这种情况下，任何与模式不匹配的完成都将被删除。

       最后，使用-P和-S选项指定的任何前缀和后缀都会添加到每个内存中。
       完成列表的ber，结果返回到readline完成代码为
       可能的完成列表。

       如果先前应用的操作不生成任何匹配项，则使用-o dirnames选项
       在定义compspec时，提供完成，目录名称完成
       尝试。

       如果在定义compspec时提供了-o plusdirs选项以完成，则为directory
       尝试完成名称，并将任何匹配添加到其他操作的结果中。

       默认情况下，如果找到compspec，它生成的任何内容都将返回到完成
       代码作为完整的可能完成集。默认的bash完成不是
       尝试，并禁用文件名完成的readline默认值。如果-o bashde-
       在定义compspec时提供了fault选项来完成，bash默认为
       如果compspec不生成匹配，则尝试尝试。如果-o default选项是
       在定义compspec时提供完成，readline的默认完成将是
       如果compspec（以及，如果尝试，默认的bash完成）生成no，则执行
       火柴。

       当compspec表明需要完成目录名称时，可编程的com-
       pletion函数强制readline将斜杠附加到符号的已完成名称
       指向目录的链接，取决于mark-directories readline变量的值，
       无论mark-symlinked-directories readline变量的设置如何。

       有一些动态修改完成的支持。这在使用时最有用
       与完整-D指定的默认完成相结合。它有可能
       shell函数作为完成处理程序执行，以指示应该完成
       通过返回124的退出状态重试。如果shell函数返回124，则更改
       compspec与正在尝试完成的命令相关联（提供
       作为执行函数时的第一个参数），可编程完成从重新开始
       一开始，尝试为该命令找到新的compspec。这允许一组
       尝试完成时动态构建的完成次数，而不是被加载
       一次全部。

       例如，假设有一个compspecs库，每个都保存在一个文件中
       在命令名称的作用下，将加载以下默认完成函数
       动态完成：

       _completion_loader（）
       {
            。 “/etc/bash_completion.d/$1.sh”> / dev / null 2>＆1 &&返回124
       }
       完成-D -F _completion_loader


历史
       启用set builtin的-o history选项后，shell将提供对该内置的访问权限
       命令历史记录，以前键入的命令列表。 HISTSIZE变量的值
       用作要保存在历史列表中的命令数。最后一个HISTSIZE的文本
       命令（默认为500）已保存。 shell先前将每个命令存储在历史列表中
       参数和变量扩展（参见上面的EXPANSION）但历史扩展后
       根据shell变量HISTIGNORE和HISTCONTROL的值执行。

       在启动时，历史记录是从变量HISTFILE命名的文件初始化的
       （默认〜/ .bash_history）。如果必要，则截断由HISTFILE值命名的文件
       sary，包含不超过HISTFILESIZE值指定的行数。
       读取历史文件时，将跟随以历史注释字符开头的行
       紧接着一个数字被解释为前一个历史记录行的时间戳。这些
       可选地显示时间戳，具体取决于HISTTIMEFORMAT变量的值。
       当交互式shell退出时，将从历史列表中复制最后的$ HISTSIZE行
       到$ HISTFILE。如果启用了histappend shell选项（请参阅shopt的说明
       在下面的SHELL BUILTIN命令下），行将附加到历史文件中，否则
       历史文件被覆盖。如果未设置HISTFILE，或者历史文件是
       不可写，历史没有保存。如果设置了HISTTIMEFORMAT变量，则为时间戳
       被写入历史文件，用历史注释字符标记，因此它们可能是
       在shell会话中保留。这使用历史注释字符来区分
       来自其他历史记录行的时间戳。保存历史记录后，历史文件是trun-
       包含不超过HISTFILESIZE行。如果没有设置HISTFILESIZE，则没有trunca-
       执行。

       内置命令fc（参见下面的SHELL BUILTIN命令）可用于列出或编辑和
       重新执行历史列表的一部分。内置的历史记录可用于显示或
       修改历史列表并操纵历史文件。使用命令行编辑时，
       搜索命令在每种编辑模式下都可用，它们提供对历史列表的访问。

       shell允许控制在历史列表中保存哪些命令。 HISTCON-
       TROL和HISTIGNORE变量可以设置为使shell只保存一部分
       输入的命令。 cmdhist shell选项（如果启用）会导致shell尝试
       在同一个历史记录条目中保存多行命令的每一行，在其中添加分号
       保持句法正确性所必需的。 lithist shell选项导致shell
       使用嵌入的换行符而不是分号保存命令。请参阅说明
       在SHELL BUILTIN COMMANDS下面的shopt内置有关设置和取消设置的信息
       shell选项。

历史扩张
       shell支持历史扩展功能，类似于历史记录扩展
       CSH。本节介绍可用的语法功能。此功能已启用
       默认情况下，对于交互式shell，可以使用该组的+ H选项禁用
       内置命令（参见下面的SHELL BUILTIN命令）。非交互式shell不执行
       历史扩展默认情况下。

       历史扩展将历史列表中的单词引入输入流中
       容易重复的命令，将前一个命令的参数插入当前输入
       line，或快速修复以前命令中的错误。

       在读取完整行之后，在shell之前立即执行历史记录扩展
       把它分解成文字。它分两部分进行。首先是确定哪一行
       从历史列表中替换时使用。第二是选择部分内容
       包含在当前行中的行。从历史中选择的线是事件，
       并且该行的部分是单词。各种改性剂可用 - 
       能够操纵选定的单词。这条线以同样的方式被分成了几个字
       当读取输入时，使几个元字符分隔的单词被引号括起来
       被认为是一个词。历史扩展是由他的外观引入的 - 
       保守党扩张人物，这是！默认情况下。只有反斜杠（\）和单引号才可以
       引用历史扩展字符。

       如果在历史之后立即发现，几个字符会抑制历史扩张
       扩展字符，即使它没有引用：空格，制表符，换行符，回车符和=。
       如果启用了extglob shell选项，（也将禁止扩展。

       内置shopt可设置的几个shell选项可用于定制行为
       历史扩张。如果启用了histverify shell选项（请参阅
       shopt builtin under），并且正在使用readline，历史替换不是立即的
       传递给shell解析器。而是将扩展的行重新加载到readline编辑中 - 
       缓冲区进一步修改。如果正在使用readline，则使用histreedit shell
       选项已启用，失败的历史记录替换将重新加载到readline编辑中
       缓冲纠正。可以使用history builtin命令的-p选项查看
       在使用之前，历史扩展会做些什么。内置历史记录的-s选项可以
       用于将命令添加到历史列表的末尾而不实际执行它们，所以
       他们可以随后召回。

       shell允许控制历史扩展机制使用的各种字符
       （参见Shell变量下面的histchars说明）。 shell使用历史记录
       注释字符以在写入历史文件时标记历史时间戳。

   活动指示人
       事件指示符是对历史列表中的命令行条目的引用。除非
       reference是绝对的，事件是相对于历史列表中的当前位置。

       ！开始历史记录替换，除非后跟空白，换行符，运输
              return，=或（（当使用内置的shopt启用extglob shell选项时）。
       ！n请参阅命令行n。
       ！-n请参阅当前命令减去n。
       ！请参阅上一个命令。这是`！-1'的同义词。
       ！串
              请参阅历史列表中当前位置之前的最新命令
              以字符串开头。
       ！？串[？]
              请参阅历史列表中当前邮件之前的最新命令
              包含字符串。落后？如果立即跟随字符串，则可以省略
              通过换行符。
       ^ ^ STRING1 ^字符串2
              快速替换。重复上一个命令，将string1替换为string2。
              相当于``!!：s / string1 / string2 /''（参见下面的修饰符）。
       ！＃到目前为止输入的整个命令行。

   Word指示符
       Word指示符用于从事件中选择所需的单词。答：分开事件
       来自单词指示符的规范。如果单词指示符开始，则可以省略
       使用^，$，*， - 或％。单词从行的开头编号，第一行
       单词由0（零）表示。单词被插入到由sin-分隔的当前行中
       gle空间。

       0（零）
              第0个字。对于shell，这是命令字。
       n第n个字。
       ^第一个参数。也就是说，单词1。
       $最后一个论点。
       ％这个词与最近的`？string？'相匹配？搜索。
       x-y一系列单词; `-y'缩写为'0-y'。
       *所有的话，但第零。这是“1- $”的同义词。这不是错误
              如果事件中只有一个单词，则使用*;返回空字符串
              那种情况。
       x *缩写x- $。
       x-缩写x- $喜欢x *，但省略了最后一个单词。

       如果提供的字指示符没有事件规范，则前一个命令是
       用作活动。

   修饰符
       在可选的单词指示符之后，可能会出现一个或多个序列的序列
       降低修饰符，每个修饰符前面都有一个`：'。

       h删除尾随文件名组件，只留下头部。
       t删除所有前导文件名组件，留下尾部。
       r删除表单.xxx的尾部后缀，保留基本名称。
       e删除除尾随后缀之外的所有内容。
       p打印新命令但不执行它。
       引用替换的单词，逃避进一步的替换。
       x引用替换的单词与q一样，但在空白和换行符处分成单词。
       S /老/新/
              在事件行中替换new为第一次出现的old。任何分隔符都可以
              用来代替/。如果最后一个分隔符是最后一个字符，则它是可选的
              事件线。分隔符可以引用旧的和新的单个背面 - 
              削减。如果＆出现在新的，它将被旧的替换。一个反斜杠就会引用
              ＆。如果old为null，则将其设置为最后一个旧的替换，或者，如果之前没有
              历史替换发生了，最后一个字符串在！？string [？]中搜索。
       并重复上一次替换。
       g导致在整个事件行上应用更改。这是结合使用的
              用`：s'（例如，`：gs / old / new /'）或`：＆'。如果与`：s'一起使用，任何分隔符都可以
              用于代替/，如果它是最后一个字符，则最终分隔符是可选的
              事件线。 a可以用作g的同义词。
       G对事件行中的每个单词应用以下`s'修饰符一次。

SHELL BUILTIN COMMANDS
       除非另有说明，否则本节中的每个内置命令都记录为接受
       选项前面带有 - 接受 - 表示选项的结束。 ：，真实，虚假，
       并测试builtins不接受选项，不要 - 特别是。退出，退出，
       break，continue，let和shift内置接受和处理以 - 开头的参数
       不要求 - 。其他接受参数但未指定为的内置函数
       接受选项解释以 - 作为无效选项和要求 - 来开头的参数
       防止这种解释。
       ：[参数]
              没有效果;除了扩展参数和执行任何操作之外，该命令不会执
              指定的重定向。返回零退出代码。

        。文件名[参数]
       源文件名[参数]
              在当前shell环境中从filename读取并执行命令并返回
              从filename执行的最后一个命令的退出状态。如果文件名没有
              包含斜杠，PATH中的文件名用于查找包含文件的目录 - 
              名称。在PATH中搜索的文件不需要是可执行的。当bash不在时
              posix模式，如果在PATH中找不到文件，则搜索当前目录。如果
              shopt builtin命令的sourcepath选项被关闭，PATH则没有
              搜索。如果提供了任何参数，它们将成为位置参数
              文件名已执行。否则，位置参数不变。该
              返回状态是脚本中退出的最后一个命令的状态（如果不是，则为0）
              命令被执行），如果找不到或无法读取文件名，则为false。

       别名[-p] [name [= value] ...]
              没有参数的别名或带-p选项的别名会打印表单中的别名列表
              别名name =标准输出的值。提供参数时，别名为
              为每个给出其值的名称定义。值的尾随空格导致
              扩展别名时要检查别名替换的下一个字。对于每一个
              参数列表中没有提供值的名称，名称和值
              别名被打印出来。除非给出没有别名的名称，否则别名返回true
              已定义。

       bg [jobspec ...]
              在后台恢复每个暂停的作业jobspec，就像它已经开始一样
              ＆。如果jobspec不存在，则使用shell的当前作业概念。 BG
              除非在禁用作业控制时运行，或者在使用作业控制运行时运行，否则jobspec将返回0
              启用了控制，未找到任何指定的jobspec或在没有作业的情况下启动
              特伦。

       绑定[-m keymap] [-lpsvPSV]
       bind [-m keymap] [-q function] [-u function] [-r keyseq]
       bind [-m keymap] -f filename
       bind [-m keymap] -x keyseq：shell-command
       bind [-m keymap] keyseq：function-name
       绑定readline-command
              显示当前的readline键和功能绑定，将键序列绑定到read-
              行函数或宏，或设置readline变量。每个非选项参数都是a
              命令，因为它将出现在.inputrc中，但必须传递每个绑定或命令
              作为一个单独的论点;例如，''\ C-x \ C-r“：re-read-init-file'。选项，如果支持
              合作，具有以下含义：
              -m keymap
                     使用keymap作为受后续绑定影响的键映射。接受-
                     能够的键映射名称是emacs，emacs-standard，emacs-meta，emacs-ctlx，vi，
                     vi-move，vi-command和vi-insert。 vi相当于vi-command; emacs是
                     相当于emacs-standard。
              -l列出所有readline函数的名称。
              -p以可能的方式显示readline函数名称和绑定
                     重读。
              -P列出当前的readline函数名称和绑定。
              -s显示绑定到宏的readline键序列及其输出的字符串
                     这样一种方式可以重新阅读。
              -S显示绑定到宏的readline键序列及其输出的字符串。
              -v以这样的方式显示readline变量名称和值
                     读。
              -V列出当前的readline变量名称和值。
              -f文件名
                     从文件名中读取键绑定。
              -q功能
                     查询哪些键调用命名函数。
              -u功能
                     取消绑定绑定到指定函数的所有键。
              -r keyseq
                     删除keyseq的任何当前绑定。
              -x keyseq：shell-command
                     导致在输入keyseq时执行shell命令。什么时候
                     执行shell-command后，shell将READLINE_LINE变量设置为
                     readline行缓冲区的内容和READLINE_POINT变量
                     插入点的当前位置。如果执行的命令改变了
                     READLINE_LINE或READLINE_POINT的值将反映这些新值
                     在编辑状态。

              除非给出无法识别的选项或发生错误，否则返回值为0。

       休息[n]
              从for，while，until或select循环中退出。如果指定了n，则中断n
              水平。 n必须≥1。如果n大于封闭循环的数量，则全部
              退出封闭循环。当n≤0时，返回值不为零;除此以外，
              break返回0值。

       内置shell-builtin [参数]
              执行指定的shell内置，传递参数，并返回其退出sta
              土族。这在定义名称与shell相同的函数时很有用
              内置，保留功能内置功能。 cd
              内置通常以这种方式重新定义。如果是shell-builtin，则返回状态为false
              不是shell内置命令。

       来电者[expr]
              返回任何活动子例程调用的上下文（shell函数或脚本exe-
              与...同伴。或源内置）。如果没有expr，调用者将显示行号
              和当前子程序调用的源文件名。如果是非负整数
              作为expr提供，调用者显示行号，子例程名称和源文件
              对应于当前执行调用堆栈中的该位置。这个额外的
              例如，可以使用信息来打印堆栈跟踪。目前的框架是
              除非shell没有执行子程序调用，否则返回值为0
              或expr不对应于调用堆栈中的有效位置。

       cd [-L | [-P [-e]]] [dir]
              将当前目录更改为dir。变量HOME是默认目录。该
              变量CDPATH定义包含dir的目录的搜索路径。 Alterna-
              CDPATH中的目录名称由冒号（:)分隔。空目录名称
              在CDPATH中与当前目录相同，即“。”。如果dir以a开头
              斜杠（/），然后不使用CDPATH。 -P选项表示使用物理目录
              结构而不是遵循符号链接（另请参阅集合的-P选项
              内置命令）; -L选项强制遵循符号链接。如果是-e
              选项随-P提供，当前工作目录无法成功
              在成功更改目录后确定，cd将返回一个不成功的目标
              土族。 - 的参数相当于$ OLDPWD。如果是非空目录名称
              使用CDPATH，或者如果 - 是第一个参数，并且目录更改成功 - 
              ful，新工作目录的绝对路径名写入标准
              输出。如果目录已成功更改，则返回值为true;假
              除此以外。

       命令[-pVv]命令[arg ...]
              使用args运行命令可以抑制正常的shell函数查找。只有内置
              执行PATH中的命令或命令。如果给出-p选项，则
              使用默认值fo执行搜索命令
