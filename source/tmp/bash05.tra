在可能的完成列表的公共前缀的字符中
              显示无需修改。设置为大于零的值时，常见
              显示可能时，长度超过此值的前缀将替换为省略号
              完成完成。
       completion-query-items（100）
              这确定了何时查询用户查看可能的com-的数量
              由possible-completions命令生成的pletion。它可以设置为任何inte-
              ger值大于或等于零。如果可能的完成次数是
              如果大于或等于此变量的值，则询问用户是否
              不是他希望看到他们;否则他们只是在终端上列出。
       convert-meta（On）
              如果设置为On，readline将转换第8位设置为ASCII的字符
              通过剥离第八位并为转义字符添加前缀的键序列（in
              效果，使用转义作为元前缀）。
       禁用完成（关闭）
              如果设置为On，则readline将禁止字完成。完成字符将是
              插入到行中，好像它们已映射到自插入一样。
       编辑模式（emacs）
              控制readline是否以一组类似于Emacs或vi的键绑定开头。
              编辑模式可以设置为emacs或vi。
       echo-control-characters（开）
              当设置为On时，在表明它们支持它的操作系统上，readline回显
              与从键盘产生的信号对应的字符。
       启用键盘（关闭）
              设置为On时，readline将尝试启用应用程序键盘
              调用。某些系统需要此功能才能启用箭头键。
       enable-meta-key（On）
              设置为On时，readline将尝试启用终端的任何元修饰键
              声称在呼叫时提供支持。在许多终端上，元密钥用于
              发送八位字符。
       expand-tilde（关闭）
              如果设置为On，则当readline尝试单词完成时执行波形扩展。
       历史保留点（关闭）
              如果设置为“开”，则历史记录代码会尝试将点放在每个位置的相同位置
              使用上一个历史或下一个历史记录检索的历史记录行。
       历史大小（0）
              设置历史列表中保存的最大历史条目数。如果设置为
              零，历史列表中的条目数不受限制。
       水平滚动模式（关闭）
              设置为On时，使readline使用单行显示，滚动输入
              当它变得比屏幕宽度长时，在单个屏幕线上水平放置
              而不是包装到新的行。
       input-meta（Off）
              如果设置为On，readline将启用8位输入（也就是说，它不会剥离
              无论终端声称它是什么，它所读取的字符都是高位
              可以支持。名称meta-flag是此变量的同义词。
       isearch-terminators（``C- [C-J''）
              应该终止增量搜索而没有子句的字符串
              将角色作为命令执行。如果没有给出这个变量a
              值，字符ESC和C-J将终止增量搜索。
       keymap（emacs）
              设置当前的readline键映射。有效的键映射名称集是emacs，
              emacs-standard，emacs-meta，emacs-ctlx，vi，vi-command和vi-insert。 vi等同于
              对vi-command; emacs相当于emacs-standard。默认值为
              emacs的;编辑模式的值也会影响默认的键盘映射。
       标记目录（开）
              如果设置为On，则已完成的目录名称会附加斜杠。
       mark-modified-lines（Off）
              如果设置为“开”，则会使用前面的内容显示已修改的历史记录行
              星号（*）。
       mark-symlinked-directories（Off）
              如果设置为On，则作为目录的符号链接的已完成名称具有斜杠
              附加（取决于mark-directories的值）。
       match-hidden-files（On）
              此变量设置为On时，会使readline与名称以的文件匹配
              一个'。'执行文件名完成时（隐藏文件）。如果设置为关闭，则
              '。'必须由用户提供要完成的文件名。
       menu-complete-display-prefix（关闭）
              如果设置为“开”，则菜单完成将显示可能列表的公共前缀
              在循环列表之前完成（可能是空的）。
       output-meta（关闭）
              如果设置为On，readline将显示直接设置第8位的字符
              而不是作为元前缀的转义序列。
       页面完成（开）
              如果设置为On，则readline使用内部更类似的寻呼机来显示屏幕
              一次可能的完成。
       水平打印完成（关闭）
              如果设置为On，则readline将显示水平排序的匹配的完成
              字母顺序，而不是在屏幕上。
       revert-all-at-newline（关闭）
              如果设置为On，则readline将在返回之前撤消对历史记录行的所有更改
              接受行已执行。默认情况下，历史记录行可能会被修改并保留
              对readline调用的vidual撤消列表。
       show-all-if-ambiguous（Off）
              这会改变完成函数的默认行为。如果设置为On，则为单词
              有多个可能的完成导致匹配被立即列出
              但是没有响铃。
       show-all-if-unmodified（Off）
              这以类似于的方式改变完成函数的默认行为
              显示-ALL-如果歧义。如果设置为On，则具有多个可能的单词的单词
              没有任何可能的部分完成的情况（可能的完成没有
              共享一个公共前缀）导致匹配立即列出而不是响铃
              钟声。
       跳过完成文本（关闭）
              如果设置为On，则在插入单个时会改变默认的完成行为
              匹配到线。它只在中间执行完成时才有效
              字。如果启用，则readline不会在完成时插入字符
              在完成的单词中的点之后匹配字符，因此单词的部分
              跟随游标不重复。
       visible-stats（关闭）
              如果设置为On，则附加表示stat（2）报告的文件类型的字符
              列出可能的完成时的文件名。

   Readline条件构造
       Readline实现了与条件编译功能类似的功能
       C预处理器，允许执行键绑定和变量设置
       测试结果。使用了四种解析器指令。

       $ if $ if结构允许根据编辑模式终端进行绑定
              正在使用，或使用readline的应用程序。测试的文本延伸到了
              队伍的尽头;隔离它不需要任何字符。

              mode $ if指令的mode =形式用于测试readline是否在
                     emacs或vi模式。这可以与set keymap com-一起使用
                     例如，要在emacs-standard和emacs-ctlx中设置绑定
                     键盘映射仅在readline以emacs模式开始时才显示。

              术语术语=表单可能用于包括特定于终端的键绑定
                     绑定终端功能键输出的键序列。这个单词
                     在=的右侧对着termi-的全名进行测试
                     nal和终端名称在第一个之前的部分 - 。这允许太阳
                     例如，匹配sun和sun-cmd。

              应用
                     应用程序构造用于包括特定于应用程序的设置。
                     每个使用readline库的程序都会设置应用程序名称，以及
                     初始化文件可以测试特定值。这可以用来
                     将键序列绑定到对特定程序有用的函数。例如，
                     以下命令添加引用当前或上一个的键序列
                     bash中的单词：

                     $如果Bash
                     ＃引用当前或上一个单词
                     “\ C-xq”：“\ eb \”\ ef \“”
                     $ ENDIF

       $ endif此命令，如上例所示，终止$ if命令。

       $ else如果测试失败，则执行$ if指令的此分支中的命令。

       $包括
              该指令将一个文件名作为参数，并读取命令和绑定 - 
              来自该文件。例如，以下指令将读取/ etc / inputrc：

              $ include / etc / inputrc

   搜索
       Readline提供了搜索命令历史记录的命令（参见下面的HISTORY）
       对于包含指定字符串的行。有两种搜索模式：增量和非增量
       增加的。

       在用户键入搜索字符串之前开始增量搜索。每个
       输入搜索字符串的字符，readline显示历史记录中的下一个条目
       匹配到目前为止键入的字符串。增量搜索只需要很多字符
       根据需要找到所需的历史记录条目。字符中存在的字符值
       isearch-terminators变量用于终止增量搜索。如果那个变量
       没有赋值Escape和Control-J字符将终止增量 - 
       心理搜索。 Control-G将中止增量搜索并恢复原始行。
       搜索终止时，包含搜索字符串的历史记录条目将成为
       当前行。

       要在历史记录列表中查找其他匹配条目，请键入Control-S或Control-R作为
       需用合适。这将在历史记录中向后或向前搜索以进行下一个条目匹配
       到目前为止输入的搜索字符串。绑定到readline命令的任何其他键序列都将
       终止搜索并执行该命令。例如，换行符将终止
       搜索并接受该行，从而从历史列表中执行该命令。

       Readline会记住最后一个增量搜索字符串。如果没有输入两个Control-R
       定义新搜索字符串的任何插入字符，任何记住的搜索字符串
       用过的。

       非增量搜索在开始搜索匹配之前读取整个搜索字符串
       历史路线。搜索字符串可以由用户键入或者是内容的一部分
       当前行。

   Readline命令名称
       以下是命令名称和默认键序列的列表
       他们受约束。默认情况下，没有附带键序列的命令名称是未绑定的。
       在以下描述中，point指的是当前光标位置，而mark指的是
       到set-mark命令保存的光标位置。点和标记之间的文本是
       被称为该地区。

   移动命令
       行首（C-a）
              移动到当前行的开头。
       行尾（C-e）
              移到行尾。
       forward-char（C-f）
              向前移动一个角色。
       反向字符（C-b）
              移回一个角色。
       前向词（M-f）
              前进到下一个单词的结尾。单词由字母数字字符组成
              acters（字母和数字）。
       后向词（M-b）
              移回当前或上一个单词的开头。单词由组成
              字母数字字符（字母和数字）。
       壳正向词
              前进到下一个单词的结尾。单词由非引用shell分隔
              元字符。
       壳反向词
              移回当前或上一个单词的开头。单词由非分隔
              引用shell元字符。
       透明屏幕（C-l）
              清除屏幕，将当前行保留在屏幕顶部。辩论 - 
              ，刷新当前行而不清除屏幕。
       重绘电流线
              刷新当前行。

   操纵历史的命令
       接受（换行，返回）
              无论光标在哪里，都接受该行。如果此行非空，请添加
              它根据HISTCONTROL变量的状态到历史列表中。如果
              line是已修改的历史记录行，然后将历史记录行还原为其原始行
              州。
       前历史（C-p）
              从历史列表中获取上一个命令，然后在列表中返回。
       次历史（C-n）
              从历史列表中获取下一个命令，在列表中向前移动。
       历史起点（M- <）
              移至历史记录的第一行。
       历史结束（M->）
              移动到输入历史记录的末尾，即当前输入的行。
       反向搜索历史（C-r）
              从当前行开始向后搜索，并在历史记录中“向上”移动
              必要。这是一种增量搜索。
       前向搜索历史（C-s）
              从当前行开始向前搜索并在历史记录中“向下”移动
              必要。这是一种增量搜索。
       非增量反向搜索历史（M-p）
              使用非增量值向后搜索从当前行开始的历史记录
              mental search搜索用户提供的字符串。
       非增量前向搜索历史（M-n）
              使用非增量搜索字符串来搜索历史记录
              由用户提供。
       历史搜索前进
              通过历史记录搜索开头之间的字符串
              当前的路线和要点。这是一种非增量搜索。
       历史搜索落后
              在历史记录中向后搜索开始之间的字符串
              当前的线和点。这是一种非增量搜索。
       yank-nth-arg（M-C-y）
              将第一个参数插入上一个命令（通常是第二个单词
              前一行）。使用参数n，插入前一个第n个单词
              命令（上一个命令中的单词以单词0开头）。一个消极的论点
              插入上一个命令末尾的第n个单词。一旦参数n为
              在计算中，提取的参数就好像“！n”历史扩展已被指定
              田间。
       yank-last-arg（M-。，M-_）
              将最后一个参数插入上一个命令（前一个命令的最后一个字 - 
              保守党入境）。使用数字参数，其行为与yank-nth-arg完全相同。连续
              调用yank-last-arg后退回历史列表，插入最后一个单词
              （依次为第一次调用的参数指定的单词）依次为每一行。任何
              提供给这些连续调用的数字参数决定了移动的方向
              通过历史。负参数会切换历史记录中的方向
              （后退或前锋）历史扩展设施用于提取最后一个
              参数，好像已经指定了“！$”历史扩展。
       壳扩展线（M-C-e）
              像shell一样扩展行。这将执行别名和历史记录扩展
              以及所有shell字扩展。请参阅下面的历史扩展a
              历史扩张的描述。
       历史扩展线（M- ^）
              在当前行上执行历史记录扩展。请参阅下面的历史扩展a
              历史扩张的描述。
       魔术空间
              在当前行上执行历史记录扩展并插入空格。见历史
              以下扩展用于描述历史扩展。
       别名扩展线
              在当前行上执行别名扩展。有关说明，请参见上面的ALIASES
              别名扩展。
       历史和别名扩展线
              在当前行上执行历史记录和别名扩展。
       insert-last-argument（M-。，M-_）
              yank-last-arg的同义词。
       操作并获取下一个（C-o）
              接受当前行执行并获取相对于当前行的下一行
              从历史租用线进行编辑。任何参数都会被忽略。
       编辑执行命令（C-xC-e）
              在当前命令行上调用编辑器，并将结果作为shell命令执行
              mands。 Bash尝试调用$ VISUAL，$ EDITOR和emacs作为编辑器
              订购。

   更改文本的命令
       delete-char（C-d）
              删除点上的字符。如果point位于该行的开头，则有
              行中没有字符，并且键入的最后一个字符未绑定
              delete-char，然后返回EOF。
       backward-delete-char（Rubout）
              删除光标后面的字符。给定数字参数时，保存
              在杀戮戒指上删除了文字。
       前后 - 删除 - 木炭
              删除光标下的字符，除非光标位于行的末尾，
              在这种情况下，光标后面的字符将被删除。
       引用插入（C-q，C-v）
              将该下一个字符逐字添加到行中。这是插入字符的方法
              比如C-q。
       制表符插入（C-v TAB）
              插入制表符。
       自插入（a，b，A，1，！，...）
              插入键入的字符。
       转置字符（C-t）
              在点前移点前移动角色，移动点
              前进也是如此。如果point位于该行的末尾，那么这将转换为两者
              点之前的字符。否定论点没有效果。
       转置词（M-t）
              在点之后拖动单词之前的单词，将该点移动到该单词之后
              好。如果point位于该行的末尾，则会将最后两个单词转置为
              线。
       upcase-word（M-u）
              大写当前（或后续）单词。使用否定参数，大写
              上一个字，但不要移动点。
       downcase-word（M-l）
              小写当前（或后续）单词。使用否定参数，小写
              上一个字，但不要移动点。
       大写字（M-c）
              将当前（或后续）单词大写。用负面论证，大写
              前一个词，但不要移动点。
       覆盖模式
              切换覆盖模式。使用显式正数字参数，切换到
              覆盖模式。使用显式非正数字参数，切换到插入
              模式。此命令仅影响emacs模式; vi模式的覆盖方式不同。
              每次调用readline（）都以插入模式启动。在覆盖模式下，字符绑定
              自我插入在点处替换文本而不是将文本推向右侧。
              绑定到backward-delete-char的字符用a替换点之前的字符
              空间。默认情况下，此命令未绑定。

   杀戮和Yanking
       杀线（C-k）
              将文本从点到终止。
       反向杀线（C-x Rubout）
              向后杀到行的开头。
       unix-line-discard（C-u）
              从点向后杀死到行的开头。已保存的文本已保存
              杀戮戒指。
       杀，整线
              杀死当前行上的所有字符，无论哪个点。
       杀词（M-d）
              从点到当前单词的结尾，或者如果在单词之间，到达结尾
              下一个字。字边界与前向字使用的边界相同。
       向后杀词（M-Rubout）
              杀掉点后面的词。字边界与背面使用的边界相同
              病房字。
       shell-kill-word（M-d）
              从点到当前单词的结尾，或者如果在单词之间，到达结尾
              下一个字。字边界与shell-forward-word使用的边界相同。
       shell-backward-kill-word（M-Rubout）
              杀掉点后面的词。字边界与使用的边界相同
              壳反向词。
       unix-word-rubout（C-w）
              使用空格作为单词边界，杀掉单词后面的单词。被杀死的文字
              被保存在杀戮戒指上。
       UNIX的文件名，擦去
              使用空格和斜线字符作为单词，杀掉单词后面的单词
              边界。被杀死的文本保存在kill-ring上。
       删除 - 水平空间（M- \）
              删除点周围的所有空格和制表符。
       杀区
              杀死当前区域的文本。
       复制区域作为杀
              将区域中的文本复制到kill缓冲区。
       复制反向词
              将点前的单词复制到kill buffer。单词边界是相同的
              反向词。
       复制正向词
              将以下单词复制到kill buffer。单词边界是相同的
              作为前瞻性词。
       猛拉（C-y）
              将杀伤环的顶部猛击到缓冲点处。
       yank-pop（M-y）
              旋转杀环，并猛拉新的顶部。只能在yank或yank-pop之后工作。

   数字参数
       数字参数（M-0，M-1，...，M--）
              将此数字添加到已累积的参数中，或者启动新参数。 M--
              开始一个负面的论点。
       通用参数的
              这是指定参数的另一种方法。如果此命令后跟一个或
              更多数字，可选地带有前导减号，这些数字定义参数。
              如果命令后跟数字，则再次执行universal-argument结束
              数字参数，但否则被忽略。作为一种特殊情况，如果是这个命令
              紧接着是一个既不是数字也不是减号的字符，
              下一个命令的计数乘以4。参数计数是ini
              一个，所以第一次执行此函数使参数计数为四，
              第二次使参数计数为16，依此类推。

   完成
       完成（TAB）
              尝试在点之前对文本执行完成。 Bash尝试完成
              将文本视为变量（如果文本以$开头），用户名（如果是文本
              以〜）开头，主机名（如果文本以@开头）或命令（包​​括别名）
              和功能）反过来。如果这些都不产生匹配，则文件名完成
              尝试。
       可能完成（M-？）
              在点之前列出文本的可能完成情况。
       插入完成（M- *）
              在由生成的点之前插入文本的所有完成
              可能完井。
       菜单完成
              与完成类似，但用一个匹配替换要完成的单词
              可能的完成列表。重复执行菜单完成步骤
              可能的完成列表，依次插入每个匹配。在结束时
              完成列表，铃声是响铃（根据钟式设置）和
              原始文本已恢复。 n的参数在列表中向前移动n个位置
              比赛;可以使用否定参数在列表中向后移动。这个
              命令旨在绑定到TAB，但默认情况下不绑定。
       菜单完成后向
              与菜单完成相同，但在可能的补充列表中向后移动
              tions，好像菜单完整已被给予否定的论点。这个命令是
              默认情况下不绑定。
       删除 - 炭或列表
              如果不在行的开头或结尾，则删除光标下的字符
              （比如delete-char）。如果在行尾，行为与可能的行为相同
              pletions。默认情况下，此命令未绑定。
       完整文件名（M- /）
              在点之前的文本上尝试完成文件名。
       可能的文件名完成次数（C-x /）
              在点之前列出文本的可能完成，将其视为文件名。
       完整用户名（M-〜）
              在点之前尝试完成文本，将其视为用户名。
       可能的用户名完成次数（C-x~）
              在点之前列出文本的可能完成，将其视为用户名。
       完全变量（M- $）
              在点之前尝试完成文本，将其视为shell变量。
       可能变量完成（C-x $）
              在点之前列出文本的可能完成，将其视为shell变量
              能够。
       完整主机名（M- @）
              在点之前尝试完成文本，将其视为主机名。
       可能的主机名完成次数（C-x @）
              在点之前列出文本的可能完成，将其视为主机名。
       完成命令（M-！）
              在点之前尝试完成文本，将其视为命令名称。命令
              完成尝试将文本与别名，保留字，shell函数匹配
              tions，shell builtins，最后是可执行文件名，按顺序排列。
       可能的命令完成（C-x！）
              在点之前列出文本的可能完成，将其视为命令
              名称。
       动态完整历史（M-TAB）
              在点之前尝试完成文本，将文本与来自的行进行比较
              可能完成匹配的历史列表。
       dabbrev-扩大
              在点之前的文本上尝试菜单完成，将文本与行进行比较
              从历史列表中可能完成匹配。
       完成括号（M- {）
              执行文件名完成并插入所包含的可能完成列表
              在大括号内，所以列表可供shell使用（参见上面的Brace Expansion）。

   键盘宏
       start-kbd-macro（C-x（）
              开始保存键入当前键盘宏的字符。
       end-kbd-macro（C-x））
              停止保存键入当前键盘宏的字符并存储默认值
              nition。
       call-last-kbd-macro（C-x e）
              通过在宏中创建字符，重新执行定义的最后一个键盘宏
              看起来好像键入了键盘。

   杂
       re-read-init-file（C-x C-r）
              读入inputrc文件的内容，并合并任何绑定或变量
              在那里找到了作业。
       中止（C-g）
              中止当前的编辑命令并响铃终端的铃声（取决于设置 - 
              钟式的）。
       do-uppercase-version（M-a，M-b，M-x，...）
              如果元化字符x是小写，则运行绑定到cor-的命令
              响应大写字符。
       前缀元（ESC）
              Metafy下一个字符输入。 ESC f相当于Meta-f。
       撤消（C-_，C-x C-u）
              增量撤消，分别记住每一行。
       恢复线（M-r）
              撤消对此行所做的所有更改。这就像执行撤销命令一样
              将该行恢复到初始状态的时间。
       波浪扩展（M-＆）
              对当前单词执行波浪扩展。
       设定标记（C- @，M- <空格>）
              将标记设置为该点。如果提供了数字参数，则标记设置为
              那个位置。
       交换点和标记（C-x C-x）
              用标记交换点。当前光标位置设置为保存的位置
              和旧光标位置保存为标记。
       字符搜索（C-]）
              读取一个字符，并将点移动到该字符的下一个匹配项。一个
              消极的国家
