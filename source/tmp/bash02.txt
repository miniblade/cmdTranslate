 has no value, the default
              value is 10.  If it does not exist, EOF signifies the end of input to the shell.
       INPUTRC
              The filename for the readline startup file, overriding  the  default  of  ~/.inputrc
              (see READLINE below).
       LANG   Used  to  determine  the  locale category for any category not specifically selected
              with a variable starting with LC_.
       LC_ALL This variable overrides the value of LANG and any other LC_  variable  specifying  a
              locale category.
       LC_COLLATE
              This  variable determines the collation order used when sorting the results of path‐
              name expansion, and  determines  the  behavior  of  range  expressions,  equivalence
              classes, and collating sequences within pathname expansion and pattern matching.
       LC_CTYPE
              This  variable determines the interpretation of characters and the behavior of char‐
              acter classes within pathname expansion and pattern matching.
       LC_MESSAGES
              This variable determines the locale used to translate double-quoted strings preceded
              by a $.
       LC_NUMERIC
              This variable determines the locale category used for number formatting.
       LINES  Used  by  the  select  compound  command to determine the column length for printing
              selection lists.  Automatically set upon receipt of a SIGWINCH.
       MAIL   If this parameter is set to a file or directory name and the  MAILPATH  variable  is
              not  set,  bash  informs  the  user  of the arrival of mail in the specified file or
              Maildir-format directory.
       MAILCHECK
              Specifies how often (in seconds) bash checks for mail.  The default is  60  seconds.
              When  it  is time to check for mail, the shell does so before displaying the primary
              prompt.  If this variable is unset, or set to a value that is not a  number  greater
              than or equal to zero, the shell disables mail checking.
       MAILPATH
              A  colon-separated  list  of  file  names to be checked for mail.  The message to be
              printed when mail arrives in a particular file may be specified  by  separating  the
              file  name  from  the  message with a `?'.  When used in the text of the message, $_
              expands to the name of the current mailfile.  Example:
              MAILPATH='/var/mail/bfox?"You have mail":~/shell-mail?"$_ has mail!"'
              Bash supplies a default value for this variable, but the location of the  user  mail
              files that it uses is system dependent (e.g., /var/mail/$USER).
       OPTERR If set to the value 1, bash displays error messages generated by the getopts builtin
              command (see SHELL BUILTIN COMMANDS below).  OPTERR is initialized to  1  each  time
              the shell is invoked or a shell script is executed.
       PATH   The  search path for commands.  It is a colon-separated list of directories in which
              the shell looks for commands (see COMMAND EXECUTION below).   A  zero-length  (null)
              directory  name in the value of PATH indicates the current directory.  A null direc‐
              tory name may appear as two adjacent colons, or as an  initial  or  trailing  colon.
              The  default  path is system-dependent, and is set by the administrator who installs
              bash.  A common value is ``/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin''.
       POSIXLY_CORRECT
              If this variable is in the environment when bash starts, the shell enters posix mode
              before  reading the startup files, as if the --posix invocation option had been sup‐
              plied.  If it is set while the shell is running, bash enables posix mode, as if  the
              command set -o posix had been executed.
       PROMPT_COMMAND
              If set, the value is executed as a command prior to issuing each primary prompt.
       PROMPT_DIRTRIM
              If  set  to  a number greater than zero, the value is used as the number of trailing
              directory components to retain when expanding the \w and \W  prompt  string  escapes
              (see PROMPTING below).  Characters removed are replaced with an ellipsis.
       PS1    The  value  of this parameter is expanded (see PROMPTING below) and used as the pri‐
              mary prompt string.  The default value is ``\s-\v\$ ''.
       PS2    The value of this parameter is expanded as with PS1 and used as the secondary prompt
              string.  The default is ``> ''.
       PS3    The  value of this parameter is used as the prompt for the select command (see SHELL
              GRAMMAR above).
       PS4    The value of this parameter is expanded as with PS1 and the value is printed  before
              each command bash displays during an execution trace.  The first character of PS4 is
              replicated multiple times, as necessary, to indicate multiple levels of indirection.
              The default is ``+ ''.
       SHELL  The  full  pathname to the shell is kept in this environment variable.  If it is not
              set when the shell starts, bash assigns to it  the  full  pathname  of  the  current
              user's login shell.
       TIMEFORMAT
              The  value  of  this  parameter is used as a format string specifying how the timing
              information for pipelines prefixed with the time reserved word should be  displayed.
              The  %  character  introduces an escape sequence that is expanded to a time value or
              other information.  The escape sequences and their  meanings  are  as  follows;  the
              braces denote optional portions.
              %%        A literal %.
              %[p][l]R  The elapsed time in seconds.
              %[p][l]U  The number of CPU seconds spent in user mode.
              %[p][l]S  The number of CPU seconds spent in system mode.
              %P        The CPU percentage, computed as (%U + %S) / %R.

              The  optional p is a digit specifying the precision, the number of fractional digits
              after a decimal point.  A value of 0 causes no decimal point or fraction to be  out‐
              put.   At  most  three  places after the decimal point may be specified; values of p
              greater than 3 are changed to 3.  If p is not specified, the value 3 is used.

              The optional l specifies a longer format, including minutes, of the form  MMmSS.FFs.
              The value of p determines whether or not the fraction is included.

              If   this   variable   is   not   set,   bash   acts   as   if   it  had  the  value
              $'\nreal\t%3lR\nuser\t%3lU\nsys%3lS'.  If the value is null, no  timing  information
              is displayed.  A trailing newline is added when the format string is displayed.
       TMOUT  If set to a value greater than zero, TMOUT is treated as the default timeout for the
              read builtin.  The select command terminates if input does not  arrive  after  TMOUT
              seconds when input is coming from a terminal.  In an interactive shell, the value is
              interpreted as the number of seconds to wait for input  after  issuing  the  primary
              prompt.   Bash terminates after waiting for that number of seconds if input does not
              arrive.
       TMPDIR If set, bash uses its value as the name of a directory in which bash creates  tempo‐
              rary files for the shell's use.
       auto_resume
              This  variable  controls  how the shell interacts with the user and job control.  If
              this variable is set, single word simple commands without redirections  are  treated
              as  candidates  for  resumption  of  an existing stopped job.  There is no ambiguity
              allowed; if there is more than one job beginning with the string typed, the job most
              recently  accessed  is selected.  The name of a stopped job, in this context, is the
              command line used to start it.  If set to the value exact, the string supplied  must
              match  the  name  of a stopped job exactly; if set to substring, the string supplied
              needs to match a substring of the name of a stopped job.  The substring  value  pro‐
              vides functionality analogous to the %?  job identifier (see JOB CONTROL below).  If
              set to any other value, the supplied string must be a  prefix  of  a  stopped  job's
              name; this provides functionality analogous to the %string job identifier.
       histchars
              The  two  or  three characters which control history expansion and tokenization (see
              HISTORY EXPANSION below).  The first character is the history  expansion  character,
              the  character  which  signals  the start of a history expansion, normally `!'.  The
              second character is the quick substitution character, which is used as shorthand for
              re-running  the previous command entered, substituting one string for another in the
              command.  The default is `^'.  The optional third character is the  character  which
              indicates  that the remainder of the line is a comment when found as the first char‐
              acter of a word, normally `#'.  The history comment character causes history substi‐
              tution  to  be skipped for the remaining words on the line.  It does not necessarily
              cause the shell parser to treat the rest of the line as a comment.

   Arrays
       Bash provides one-dimensional indexed and associative array variables.  Any variable may be
       used  as  an indexed array; the declare builtin will explicitly declare an array.  There is
       no maximum limit on the size of an array, nor any requirement that members  be  indexed  or
       assigned  contiguously.  Indexed arrays are referenced using integers (including arithmetic
       expressions)  and  are  zero-based;  associative  arrays  are  referenced  using  arbitrary
       strings.

       An  indexed  array is created automatically if any variable is assigned to using the syntax
       name[subscript]=value.  The subscript is treated as  an  arithmetic  expression  that  must
       evaluate  to a number.  If subscript evaluates to a number less than zero, it is used as an
       offset from one greater than the array's maximum index (so a subcript of -1 refers  to  the
       last  element  of  the array).  To explicitly declare an indexed array, use declare -a name
       (see SHELL BUILTIN COMMANDS below).  declare -a name[subscript] is also accepted; the  sub‐
       script is ignored.

       Associative arrays are created using declare -A name.

       Attributes  may be specified for an array variable using the declare and readonly builtins.
       Each attribute applies to all members of an array.

       Arrays are assigned to using compound assignments of the  form  name=(value1  ...  valuen),
       where  each  value  is  of  the  form [subscript]=string.  Indexed array assignments do not
       require the bracket and subscript.  When assigning  to  indexed  arrays,  if  the  optional
       brackets  and subscript are supplied, that index is assigned to; otherwise the index of the
       element assigned is the last index assigned to by the statement plus one.  Indexing  starts
       at zero.

       When assigning to an associative array, the subscript is required.

       This  syntax  is  also  accepted  by the declare builtin.  Individual array elements may be
       assigned to using the name[subscript]=value syntax introduced above.

       Any element of an array  may  be  referenced  using  ${name[subscript]}.   The  braces  are
       required  to  avoid  conflicts  with  pathname expansion.  If subscript is @ or *, the word
       expands to all members of name.  These subscripts differ only when the word appears  within
       double  quotes.  If the word is double-quoted, ${name[*]} expands to a single word with the
       value of each array member separated by the first character of the  IFS  special  variable,
       and  ${name[@]}  expands  each element of name to a separate word.  When there are no array
       members, ${name[@]} expands to nothing.  If the double-quoted  expansion  occurs  within  a
       word,  the expansion of the first parameter is joined with the beginning part of the origi‐
       nal word, and the expansion of the last parameter is joined with the last part of the orig‐
       inal  word.  This is analogous to the expansion of the special parameters * and @ (see Spe‐
       cial Parameters above).  ${#name[subscript]} expands to the length  of  ${name[subscript]}.
       If  subscript is * or @, the expansion is the number of elements in the array.  Referencing
       an array variable without a subscript is equivalent to referencing the array  with  a  sub‐
       script of 0.

       An  array  variable  is  considered set if a subscript has been assigned a value.  The null
       string is a valid value.

       The unset builtin is used to destroy arrays.  unset name[subscript] destroys the array ele‐
       ment at index subscript.  Care must be taken to avoid unwanted side effects caused by path‐
       name expansion.  unset name, where name is an array, or unset name[subscript],  where  sub‐
       script is * or @, removes the entire array.

       The  declare,  local,  and  readonly builtins each accept a -a option to specify an indexed
       array and a -A option to specify an associative array.  If both options  are  supplied,  -A
       takes precedence.  The read builtin accepts a -a option to assign a list of words read from
       the standard input to an array.  The set and declare builtins display array values in a way
       that allows them to be reused as assignments.

EXPANSION
       Expansion  is  performed on the command line after it has been split into words.  There are
       seven kinds of expansion performed: brace expansion, tilde expansion, parameter  and  vari‐
       able  expansion,  command  substitution, arithmetic expansion, word splitting, and pathname
       expansion.

       The order of expansions is: brace  expansion,  tilde  expansion,  parameter,  variable  and
       arithmetic  expansion  and  command  substitution  (done  in a left-to-right fashion), word
       splitting, and pathname expansion.

       On systems that can support it, there is an additional expansion available: process substi‐
       tution.

       Only brace expansion, word splitting, and pathname expansion can change the number of words
       of the expansion; other expansions expand a single word to a single word.  The only  excep‐
       tions  to  this are the expansions of "$@" and "${name[@]}" as explained above (see PARAME‐
       TERS).

   Brace Expansion
       Brace expansion is a mechanism by which arbitrary strings may be generated.  This mechanism
       is  similar to pathname expansion, but the filenames generated need not exist.  Patterns to
       be brace expanded take the form of an optional preamble, followed by  either  a  series  of
       comma-separated  strings  or a sequence expression between a pair of braces, followed by an
       optional postscript.  The preamble is prefixed to each string contained within the  braces,
       and the postscript is then appended to each resulting string, expanding left to right.

       Brace  expansions  may be nested.  The results of each expanded string are not sorted; left
       to right order is preserved.  For example, a{d,c,b}e expands into `ade ace abe'.

       A sequence expression takes the form {x..y[..incr]}, where x and y are either  integers  or
       single  characters, and incr, an optional increment, is an integer.  When integers are sup‐
       plied, the expression expands to each number between x and y, inclusive.  Supplied integers
       may  be  prefixed  with  0  to  force each term to have the same width.  When either x or y
       begins with a zero, the shell attempts to force all generated terms  to  contain  the  same
       number  of digits, zero-padding where necessary.  When characters are supplied, the expres‐
       sion expands to each character lexicographically between x and  y,  inclusive.   Note  that
       both  x  and y must be of the same type.  When the increment is supplied, it is used as the
       difference between each term.  The default increment is 1 or -1 as appropriate.

       Brace expansion is performed before any other expansions, and  any  characters  special  to
       other expansions are preserved in the result.  It is strictly textual.  Bash does not apply
       any syntactic interpretation to the context of  the  expansion  or  the  text  between  the
       braces.

       A correctly-formed brace expansion must contain unquoted opening and closing braces, and at
       least one unquoted comma or a valid sequence  expression.   Any  incorrectly  formed  brace
       expansion  is left unchanged.  A { or , may be quoted with a backslash to prevent its being
       considered part of a brace expression.  To avoid conflicts with  parameter  expansion,  the
       string ${ is not considered eligible for brace expansion.

       This  construct  is typically used as shorthand when the common prefix of the strings to be
       generated is longer than in the above example:

              mkdir /usr/local/src/bash/{old,new,dist,bugs}
       or
              chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}

       Brace expansion introduces a slight incompatibility with historical  versions  of  sh.   sh
       does  not treat opening or closing braces specially when they appear as part of a word, and
       preserves them in the output.  Bash removes braces from words as  a  consequence  of  brace
       expansion.   For example, a word entered to sh as file{1,2} appears identically in the out‐
       put.  The same word is output as file1 file2 after expansion by bash.  If  strict  compati‐
       bility  with  sh  is desired, start bash with the +B option or disable brace expansion with
       the +B option to the set command (see SHELL BUILTIN COMMANDS below).

   Tilde Expansion
       If a word begins with an unquoted tilde character (`~'), all of  the  characters  preceding
       the  first unquoted slash (or all characters, if there is no unquoted slash) are considered
       a tilde-prefix.  If none of the characters in the tilde-prefix are quoted,  the  characters
       in  the  tilde-prefix  following  the  tilde are treated as a possible login name.  If this
       login name is the null string, the tilde is replaced with the value of the shell  parameter
       HOME.   If HOME is unset, the home directory of the user executing the shell is substituted
       instead.  Otherwise, the tilde-prefix is replaced with the home directory  associated  with
       the specified login name.

       If  the tilde-prefix is a `~+', the value of the shell variable PWD replaces the tilde-pre‐
       fix.  If the tilde-prefix is a `~-', the value of the shell variable OLDPWD, if it is  set,
       is  substituted.   If  the  characters following the tilde in the tilde-prefix consist of a
       number N, optionally prefixed by a `+' or a `-', the tilde-prefix is replaced with the cor‐
       responding  element  from the directory stack, as it would be displayed by the dirs builtin
       invoked with the tilde-prefix as an argument.  If the characters following the tilde in the
       tilde-prefix consist of a number without a leading `+' or `-', `+' is assumed.

       If the login name is invalid, or the tilde expansion fails, the word is unchanged.

       Each  variable  assignment is checked for unquoted tilde-prefixes immediately following a :
       or the first =.  In these cases, tilde expansion is also performed.  Consequently, one  may
       use  file  names  with  tildes  in assignments to PATH, MAILPATH, and CDPATH, and the shell
       assigns the expanded value.

   Parameter Expansion
       The `$' character introduces  parameter  expansion,  command  substitution,  or  arithmetic
       expansion.   The  parameter  name or symbol to be expanded may be enclosed in braces, which
       are optional but serve to protect the variable to be expanded from  characters  immediately
       following it which could be interpreted as part of the name.

       When braces are used, the matching ending brace is the first `}' not escaped by a backslash
       or within a quoted string, and not within an embedded arithmetic expansion, command substi‐
       tution, or parameter expansion.

       ${parameter}
              The  value of parameter is substituted.  The braces are required when parameter is a
              positional parameter with more than one digit, or when parameter is  followed  by  a
              character which is not to be interpreted as part of its name.

       If  the first character of parameter is an exclamation point (!), a level of variable indi‐
       rection is introduced.  Bash uses the value of the variable formed from the rest of parame‐
       ter  as  the name of the variable; this variable is then expanded and that value is used in
       the rest of the substitution, rather than the value of parameter itself.  This is known  as
       indirect  expansion.   The  exceptions  to  this  are  the  expansions  of  ${!prefix*} and
       ${!name[@]} described below.  The exclamation point must immediately follow the left  brace
       in order to introduce indirection.

       In  each  of the cases below, word is subject to tilde expansion, parameter expansion, com‐
       mand substitution, and arithmetic expansion.

       When not performing substring expansion, using the forms documented below, bash tests for a
       parameter that is unset or null.  Omitting the colon results in a test only for a parameter
       that is unset.

       ${parameter:-word}
              Use Default Values.  If parameter is unset or null, the expansion of word is substi‐
              tuted.  Otherwise, the value of parameter is substituted.
       ${parameter:=word}
              Assign  Default  Values.   If  parameter  is unset or null, the expansion of word is
              assigned to parameter.  The value of  parameter  is  then  substituted.   Positional
              parameters and special parameters may not be assigned to in this way.
       ${parameter:?word}
              Display  Error  if  Null  or Unset.  If parameter is null or unset, the expansion of
              word (or a message to that effect if word is not present) is written to the standard
              error  and  the  shell,  if  it  is not interactive, exits.  Otherwise, the value of
              parameter is substituted.
       ${parameter:+word}
              Use Alternate Value.  If parameter is null or unset, nothing is substituted,  other‐
              wise the expansion of word is substituted.
       ${parameter:offset}
       ${parameter:offset:length}
              Substring  Expansion.   Expands  to up to length characters of parameter starting at
              the character specified by offset.  If length is omitted, expands to  the  substring
              of  parameter  starting at the character specified by offset.  length and offset are
              arithmetic expressions (see ARITHMETIC EVALUATION below).  If offset evaluates to  a
              number  less  than zero, the value is used as an offset from the end of the value of
              parameter.  If length evaluates to a number less than zero, and parameter is  not  @
              and not an indexed or associative array, it is interpreted as an offset from the end
              of the value of parameter rather than a number of characters, and the  expansion  is
              the  characters  between  the  two offsets.  If parameter is @, the result is length
              positional parameters beginning at offset.  If parameter is an  indexed  array  name
              subscripted  by @ or *, the result is the length members of the array beginning with
              ${parameter[offset]}.  A negative offset is taken relative to one greater  than  the
              maximum index of the specified array.  Substring expansion applied to an associative
              array produces undefined results.  Note that a negative  offset  must  be  separated
              from  the colon by at least one space to avoid being confused with the :- expansion.
              Substring indexing is zero-based unless the positional parameters are used, in which
              case the indexing starts at 1 by default.  If offset is 0, and the positional param‐
              eters are used, $0 is prefixed to the list.

       ${!prefix*}
       ${!prefix@}
              Names matching prefix.  Expands to the names of variables  whose  names  begin  with
              prefix,  separated  by  the  first character of the IFS special variable.  When @ is
              used and the expansion appears within double quotes, each variable name expands to a
              separate word.

       ${!name[@]}
       ${!name[*]}
              List  of  array  keys.   If  name is an array variable, expands to the list of array
              indices (keys) assigned in name.  If name is not an array, expands to 0 if  name  is
              set  and  null  otherwise.   When  @ is used and the expansion appears within double
              quotes, each key expands to a separate word.

       ${#parameter}
              Parameter length.  The length in characters of the value  of  parameter  is  substi‐
              tuted.   If  parameter  is * or @, the value substituted is the number of positional
              parameters.  If parameter is an array name subscripted by * or @, the value  substi‐
              tuted is the number of elements in the array.

       ${parameter#word}
       ${parameter##word}
              Remove  matching  prefix pattern.  The word is expanded to produce a pattern just as
              in pathname expansion.  If the pattern matches the beginning of the value of parame‐
              ter,  then  the  result of the expansion is the expanded value of parameter with the
              shortest matching pattern (the ``#'' case) or  the  longest  matching  pattern  (the
              ``##''  case)  deleted.   If  parameter  is @ or *, the pattern removal operation is
              applied to each positional parameter in turn, and the  expansion  is  the  resultant
              list.   If  parameter  is  an  array  variable  subscripted with @ or *, the pattern
              removal operation is applied to each member of the array in turn, and the  expansion
              is the resultant list.

       ${parameter%word}
       ${parameter%%word}
              Remove  matching  suffix pattern.  The word is expanded to produce a pattern just as
              in pathname expansion.  If the pattern matches a trailing portion  of  the  expanded
              value of parameter, then the result of the expansion is the expanded value of param‐
              eter with the shortest matching pattern (the ``%'' case)  or  the  longest  matching
              pattern  (the  ``%%''  case)  deleted.   If parameter is @ or *, the pattern removal
              operation is applied to each positional parameter in turn, and the expansion is  the
              resultant list.  If parameter is an array variable subscripted with @ or *, the pat‐
              tern removal operation is applied to each member of  the  array  in  turn,  and  the
              expansion is the resultant list.

       ${parameter/pattern/string}
              Pattern substitution.  The pattern is expanded to produce a pattern just as in path‐
              name expansion.  Parameter is expanded and the longest match of pattern against  its
              value is replaced with string.  If pattern begins with /, all matches of pattern are
              replaced with string.  Normally only the first match is replaced.  If pattern begins
              with  #, it must match at the beginning of the expanded value of parameter.  If pat‐
              tern begins with %, it must match at the end of the expanded value of parameter.  If
              string  is  null,  matches of pattern are deleted and the / following pattern may be
              omitted.  If parameter is @ or *, the substitution  operation  is  applied  to  each
              positional parameter in turn, and the expansion is the resultant list.  If parameter
              is an array variable subscripted with @ or *, the substitution operation is  applied
              to each member of the array in turn, and the expansion is the resultant list.

       ${parameter^pattern}
       ${parameter^^pattern}
       ${parameter,pattern}
       ${parameter,,pattern}
              Case  modification.   This  expansion  modifies the case of alphabetic characters in
              parameter.  The pattern is expanded to produce a pattern just as in pathname  expan‐
              sion.   The ^ operator converts lowercase letters matching pattern to uppercase; the
              , operator converts matching uppercase letters to lowercase.  The ^^ and  ,,  expan‐
              sions  convert  each matched character in the expanded value; the ^ and , expansions
              match and convert only the first character in the expanded  value.   If  pattern  is
              omitted,  it  is treated like a ?, which matches every character.  If parameter is @
              or *, the case modification operation is applied to  each  positional  parameter  in
              turn,  and  the  expansion is the resultant list.  If parameter is an array variable
              subscripted with @ or *, the case modification operation is applied to  each  member
              of the array in turn, and the expansion is the resultant list.

   Command Substitution
       Command substitution allows the output of a command to replace the command name.  There are
       two forms:

              $(command)
       or
              `command`

       Bash performs the expa