BASH（1）通用命令手册BASH（1）



名称
       bash  -  GNU Bourne-Again SHell

概要
       bash [选项] [文件]

版权
       Bash是自由软件基金会版权所有（C）1989-2011。

描述
       Bash是一个与sh兼容的命令语言解释器，它执行从标准输入或文件读取的命令
       Bash还包含了Korn和C shells(ksh 和csh) 的有用功能。

       Bash旨在成为Shell和IEEE POSIX规范的实现程序（IEEE标准1003.1）。 Bash可以配置为POSIX-
       符合默认值。

OPTIONS
       所有单字符shell选项都记录在内置命令集合中
       调用shell时，command可用作选项。另外，bash解释了
       调用它时的以下选项：

       -c string如果存在-c选项，则从字符串中读取命令。如果有
                 字符串后面的参数，它们被分配给位置参数，
                 从$ 0开始。
       -i如果存在-i选项，则shell是交互式的。
       -l使bash行为就好像它已被作为登录shell调用一样（参见下面的INVOCATION）。
       -r如果存在-r选项，则shell将受到限制（请参阅RESTRICTED SHELL
                 下面）。
       -s如果存在-s选项，或者在选项处理后没有参数，
                 然后从标准输入读取命令。这个选项允许
                 调用交互式shell时要设置的参数。
       -D在标准输出上打印所有以$开头的双引号字符串的列表
                 放。这些是在语言翻译时需要进行语言翻译的字符串
                 当前区域设置不是C或POSIX。这意味着-n选项;没有命令会
                 被执行。
       [ -  +] O [shopt_option]
                 shopt_option是内置商店接受的shell选项之一（参见SHELL
                 下面的建筑命令）。如果存在shopt_option，则-O设置该值
                 选项; + O取消它。如果没有提供shopt_option，则提供名称和值
                 shopt接受的shell选项打印在标准输出上。如果
                 调用选项为+ O，输出以可重用的格式显示
                 作为输入。
        -  A  - 表示选项结束并禁用进一步的选项处理。任何
                  - 之后的参数被视为文件名和参数。一个论点 - 
                 相当于 - 。

       Bash还解释了许多多字符选项。这些选项必须出现在
       要识别的单字符选项之前的命令行。

       --debugger
              安排在shell启动之前执行调试器配置文件。打开
              扩展调试模式（请参阅shopt的extdebug选项说明
              内置于下方）。
       自卸宝串
              相当于-D，但输出在GNU gettext po（可移植对象）文件中
              格式。
       自卸串
              相当于-D。
       --help在标准输出上显示用法消息并成功退出。
       --init-file文件
       --rcfile文件
              从文件而不是标准的个人初始化文件执行命令
              〜/ .bashrc如果shell是交互式的（参见下面的INVOCATION）。

        - 登录
              相当于-l。

       --noediting
              当shell是交互式时，不要使用GNU readline库来读取命令行
              略去。

       --noprofile
              不要读取系统范围的启动文件/ etc / profile或任何个人
              初始化文件〜/ .bash_profile，〜/ .bash_login或〜/ .profile。默认情况下，
              当bash作为登录shell调用时，bash会读取这些文件（请参阅下面的INVOCATION）。

       --norc如果是shell，请不要读取和执行个人初始化文件〜/ .bashrc
              互动。如果以sh调用shell，则默认情况下此选项处于启用状态。

       --posix
              更改bash的行为，其中默认操作与POSIX stan-不同
              dard匹配标准（posix模式）。

       --restricted
              外壳变得受限制（见下面的限制外壳）。

       --rpm-要求
              生成shell脚本运行所需的文件列表。这个
              暗示'-n'并受到与编译时错误检查相同的限制
              检查;命令替换，条件表达式和eval内置不是
              解析，因此可能会遗漏一些依赖项。

       --verbose
              相当于-v。

        - 版
              在标准输出上显示此bash实例的版本信息并退出
              成功。

ARGUMENTS
       如果参数处理后参数仍然存在，则-c和-s选项都不存在
       如果提供，则假定第一个参数是包含shell命令的文件的名称。
       如果以这种方式调用bash，则将$ 0设置为文件名和位置
       参数设置为其余参数。 Bash从中读取并执行命令
       文件，然后退出。 Bash的退出状态是执行的最后一个命令的退出状态
       剧本。如果未执行任何命令，则退出状态为0.首先尝试
       打开当前目录中的文件，如果没有找到文件，那么就是shell
       在PATH中的目录中搜索脚本。

INVOCATION
       登录shell是其参数零的第一个字符是 - 或者以。开头的一个
       --login选项。

       交互式shell是在没有非选项参数且没有-c选项的情况下启动的
       其标准输入和错误都连接到终端（由确定
       isatty（3）），或以-i选项开头的。 PS1已设置且$  - 如果bash为，则包含i
       交互式，允许shell脚本或启动文件测试此状态。

       以下段落描述了bash如何执行其启动文件。如果有任何文件
       存在但无法读取，bash报告错误。 Tildes在文件名中扩展为
       下面在EXPANSION部分的Tilde Expansion下描述。

       当bash作为交互式登录shell调用时，或作为非交互式shell调用
       --login选项，它首先从文件/etc/profile读取并执行命令，如果是这样的话文件已存在。读取该文件后，它会查找〜/.bash_profile，〜/.bash_login和 〜/.profile，按此顺序，从第一个存在的命令读取和执行命令
       并且是可读的。当shell启动禁止时，可以使用--noprofile选项
       这种行为。

       当登录shell退出时，bash从文件〜/.bash_logout读取并执行命令
       和/etc/bash.bash_logout，如果文件存在。

       当启动不是登录shell的交互式shell时，bash会读取并执行
       来自〜/.bashrc的命令，如果该文件存在的话。这可以通过使用--norc来禁止
       选项。 --rcfile文件选项将强制bash从文件中读取和执行命令
       而不是〜/ .bashrc。

       当bash以非交互方式启动时，例如，要运行shell脚本，它会查找
       环境中的变量BASH_ENV，如果出现在那里，则展开其值，并使用
       扩展值作为要读取和执行的文件的名称。 Bash表现得好像
       低位命令被执行：
              if [-n“$ BASH_ENV”];然后 。 “$ BASH_ENV”;科幻
       但PATH变量的值不用于搜索文件名。

       如果使用名称sh调用bash，它会尝试模仿历史的启动行为
       sh的版本尽可能接近，同时符合POSIX标准。
       当作为交互式登录shell或带有--login的非交互式shell调用时
       选项，它首先尝试从/etc/profile和〜/.profile中读取和执行命令
       那个命令。 --noprofile选项可用于禁止此行为。当被调用为
       一个名为sh的交互式shell，bash查找变量ENV，扩展其值
       如果已定义，则使用扩展值作为要读取和执行的文件的名称。
       由于以sh调用的shell不会尝试从任何其他命令读取和执行命令
       启动文件，--rcfile选项无效。用。调用的非交互式shell
       name sh不会尝试读取任何其他启动文件。当调用为sh时，bash进入
       读取启动文件后的posix模式。

       当bash以posix模式启动时，与--posix命令行选项一样，它遵循
       启动文件的POSIX标准。在此模式下，交互式shell扩展ENV变量
       从名称为扩展值的文件中读取和执行命令。没有
       读取其他启动文件。

       Bash尝试确定何时将其标准输入连接到网络运行
       工作连接，如由远程shell守护程序执行，通常是rshd或安全
       shell守护进程sshd。如果bash确定它以这种方式运行，它会读取并执行
       来自〜/ .bashrc的cutes命令，如果该文件存在且可读。如果，它不会这样做
       作为sh调用。 --norc选项可用于禁止此行为，以及--rcfile1
       选项可用于强制读取另一个文件，但rshd通常不会调用
       具有这些选项的shell或允许指定它们。

       如果以有效用户（组）id不等于真实用户启动shell
       （组）id，并且未提供-p选项，未读取任何启动文件，shell函数
       不是从环境继承的，SHELLOPTS，BASHOPTS，CDPATH和GLOBIGNORE
       变量（如果它们出现在环境中）将被忽略，并设置有效的用户ID
       到真正的用户ID。如果在调用时提供了-p选项，则启动行为为
       相同，但有效的用户ID不会重置。

定义
       本文档的其余部分将使用以下定义。
       空白空格或制表符。
       单词由shell视为单个单元的字符序列。又称为
              令牌。
       name仅由字母数字字符和下划线组成的单词，以及开头
              用字母字符或下划线。也称为标识符。
       元字符
              一个字符，当不加引号时，分隔单词。以下之一：
              | ＆; （）<>空格标签
       控制操作员
              执行控制功能的令牌。它是以下符号之一：
              || & && ; ;; （）| |＆<newline>

保留字
       保留字是对shell具有特殊含义的字。以下是
       在不加引号时被识别为保留，并且是简单命令的第一个单词（参见
       下面的SHELL GRAMMAR）或案例的第三个词或命令：
        ! case  do done elif else esac fi for function if in   select then until while { } time [[ ]]
SHELL GRAMMAR
   简单的命令
       一个简单的命令是一系列可选的变量赋值，后跟空格分隔
       单词和重定向，并由控制操作符终止。第一个单词指定
       要执行的命令，并作为参数零传递。其余的单词传递为
       调用命令的参数。

       简单命令的返回值是其退出状态，如果命令是termi，则返回128 + n
       由信号n。

   管道
       管道是由一个控制操作符分隔的一个或多个命令的序列
       |或|＆。管道的格式是：

              [时间[-p]] [！ ]命令[[|⎪|＆] command2 ...]

       命令的标准输出通过管道连接到command2的标准输入。
       此连接在命令指定的任何重定向之前执行（请参阅REDI-
       下面的评论）。如果使用|＆，则命令的标准错误连接到command2
       通过管道输入标准;它是2>＆1 |的简写。这种隐式重定向
       在命令指定的任何重定向之后执行标准错误。

       除非pipefail，否则管道的返回状态是最后一个命令的退出状态
       选项已启用。如果启用了pipefail，则管道的返回状态为值
       最后（最右边）命令以非零状态退出，如果所有命令退出则返回零
       成功。如果保留字！在管道之前，该管道的退出状态 - 
       line是如上所述的退出状态的逻辑否定。 shell等待
       管道中的所有命令在返回值之前终止。

       如果时间保留字在管道之前，则经过时间以及用户和系统时间
       管道终止时会报告其执行所消耗的内容。 -p选项更改
       输出格式为POSIX指定的格式。当shell处于posix模式时，它不会
       如果下一个标记以“ - ”开头，则将时间识别为保留字。 TIMEFORMAT
       可以将变量设置为指定定时信息应该如何的格式字符串
       显示;请参阅下面的Shell变量下的TIMEFORMAT说明。

       当shell处于posix模式时，时间可能后跟换行符。在这种情况下，
       shell显示shell及其子级占用的总用户和系统时间。该
       TIMEFORMAT变量可用于指定时间信息的格式。

       流水线中的每个命令作为单独的过程（即，在子壳中）执行。

   清单
       列表是由一个运算符分隔的一个或多个管道的序列;，＆，&&，
       或||，并可选择以;，＆或<newline>之一终止。

       在这些列表运算符中，&&和||具有相同的优先权，其次是;和＆，有
       同等优先权。

       一个或多个换行符的序列可以出现在列表中而不是分号中以进行分隔
       命令。

       如果命令由控制操作符＆终止，则shell在后台子进程中执行命令
       。 shell不会等待命令完成，而且
       返回状态为0.命令由a分隔;按顺序执行; shell等待
       为每个命令轮流终止。返回状态是最后一个的退出状态
       命令已执行。

       AND和OR列表是由&&和||分隔的一个或多个管道的序列控制
       运营商，分别。 AND和OR列表以左关联性执行。一个AND
       列表有表格

              command1 && command2

       当且仅当command1返回退出状态为零时，才执行command2。

       OR列表具有表单

              command1 ||命令2

       当且仅当command1返回非零退出状态时才执行command2。回报
       AND和OR列表的状态是列表中执行的最后一个命令的退出状态。

   复合命令
       复合命令是以下之一：

       （list）列表在子shell环境中执行（请参阅命令执行环境
              下面）。影响shell环境的变量赋值和内置命令
              命令完成后，命令不会保持有效。返回状态是
              列表的退出状态。

       {list; }
              list只是在当前的shell环境中执行。列表必须终止
              换行或分号。这称为组命令。返回状态
              是列表的退出状态。请注意，与元字符（和）不同，{和}
              是保留字，必须出现在允许保留字被识别的地方
              识别的。由于它们不会导致单词分隔，因此必须将它们与list by分开
              空白或其他shell元字符。

       （（表达））
              根据ARITHMETIC下面描述的规则评估表达式
              评价。如果表达式的值不为零，则返回状态为0;
              否则返回状态为1.这与let“expression”完全相同。

       [[表达]]
              根据条件表达式的计算，返回0或1的状态
              表达。表达式由下面描述的原色组成  
              CONDITIONAL EXPRESSIONS。不执行单词拆分和路径名扩展
              [[和]]之间的单词;波浪扩展，参数和变量扩展，
              算术扩展，命令替换，进程替换和引用删除
              执行。诸如-f之类的条件运算符必须不加引号才能被识别
              作为初选。

              与[[，<和>运算符一起使用时，使用当前值按字典顺​​序排序
              语言环境。

              当使用==和！=运算符时，运算符右侧的字符串是
              考虑一种模式并根据下面描述的规则进行匹配
              燕鸥匹配。如果启用了shell选项nocasematch，则执行匹配
              不考虑字母字符的情况。如果返回值为0
              字符串匹配（==）或不匹配（！=）模式，否则为1。任何部分
              可以引用模式以强制它匹配为字符串。

              可以使用另一个二元运算符=〜，其优先级与==和相同
              ！=。使用时，操作员右侧的字符串被视为a
              扩展正则表达式并相应地匹配（如在regex（3）中）。回报
              如果字符串与模式匹配，则值为0，否则为1。如果经常
              表达式在语法上是不正确的，条件表达式的返回值是
              2.如果启用了shell选项nocasematch，则不执行匹配
              关于字母字符的情况。可以引用该模式的任何部分
              强制它匹配为一个字符串。子字符串与括号内的子字符串匹配
              正则表达式中的压力保存在数组变量中
              BASH_REMATCH。索引为0的BASH_REMATCH元素是字符串的一部分
              匹配整个正则表达式。索引为n的BASH_REMATCH元素为
              匹配第n个带括号的子表达式的字符串部分。

              表达式可以使用以下运算符组合，以递减列出
              优先顺序：

              （表达）
                     返回表达式的值。这可以用于覆盖正常
                     运营商的优先权。
              ！表达
                     如果表达式为false，则为True。
              expression1 && expression2
                     如果expression1和expression2都为true，则为True。
              expression1 ||表达式2
                     如果expression1或expression2为true，则为true。

              &&和||如果expression1的值为，则运算符不会计算expression2
              足以确定整个条件表达式的返回值。

      for name [[in [word ...]]; ] do list; DONE
              扩展后面的单词列表，生成项目列表。变量
              能够依次将该名称设置为该列表的每个元素，并且每个元素都执行一次
              时间。如果省略in字，for命令对每个posi执行一次列表
              设置的参数（参见下面的参数）。返回状态是退出
              执行的最后一个命令的状态。如果扩展项目如下
              在结果为空列表中，不执行任何命令，返回状态为0。

       for（（expr1; expr2; expr3））;do list; DONE
              首先，根据所描述的规则评估算术表达式expr1
              在算术评估下面。然后算术表达式expr2进行评估
              反复进行，直到评估为零。每次expr2计算为非零
              执行value，list并计算算术表达式expr3。如果有的话
              表达式被省略，它的行为就好像它的计算结果为1.返回值是
              退出执行列表中最后一个命令的状态，如果是，则返回false
              表达式无效。

       select name [in word];do list; DONE
              扩展后面的单词列表，生成项目列表。这套
              扩展的单词打印在标准错误上，每个前面都有一个数字。如果
              在word中省略，打印位置参数（参见下面的参数）。
              然后显示PS3提示并从标准输入读取一行。如果
              line包含一个对应于其中一个显示单词的数字，然后是
              name的值设置为该单词。如果该行为空，则单词和提示符为
              再次显示。如果读取EOF，则命令完成。读取任何其他值
              导致name设置为null。读取的行保存在变量REPLY中。该
              每次选择后执行list，直到执行break命令。出口
              select的状态是列表中执行的最后一个命令的退出状态，如果是，则为零
              没有执行任何命令。

      case word in  [[（] pattern [| pattern] ...）list;; ] ... esac
              case命令首先扩展word，并尝试将其与每个模式匹配
              转向，使用与路径名扩展相同的匹配规则（请参阅路径名扩展 - 
              在下面）。使用波浪扩展，参数和变量扩展该词
              扩展，算术替换，命令替换，过程替换和
              引号删除。检查的每个模式使用波浪扩展参数进行扩展
              和变量扩展，算术替换，命令替换和过程
              代换。如果启用了shell选项nocasematch，则执行匹配
              不考虑字母字符的情况。当找到匹配时，
              执行相应的列表。如果;;使用运算符，没有后续匹配
              在第一次模式匹配后尝试。使用;代替;;导致执行
              继续处理与下一组模式相关联的列表。使用;;＆
              代替;;导致shell测试语句中的下一个模式列表if
              any，并在成功匹配时执行任何关联列表。退出状态为零
              如果没有模式匹配。否则，它是最后一个命令exe的退出状态
              列表中列出。

        if list;then list; [elif list;then list; ] ... [else list; ] fi
              if列表被执行。如果其退出状态为零，则执行then列表。
              否则，每个elif列表依次执行，如果其退出状态为零，则
              执行相应的列表并完成命令。否则，否则
              列表执行，如果存在。退出状态是最后一个退出状态
              执行命令，如果没有条件测试，则为零。

       while list-1;do list-2; DONE
       until list-1;do list-2; DONE
              只要最后一个命令，while命令就会连续执行列表list-2
              在列表列表-1中返回退出状态为零。 until命令是相同的
              到while命令，除了测试被否定; list-2只要执行就可以执行
              list-1中的最后一个命令返回非零退出状态。退出状态
              while和until命令是list-2中执行的最后一个命令的退出状态，
              如果没有执行则为零。

   协进程
       协处理是一个shell命令，前面是coproc保留字。协同进程是exe-
       在子shell中异步提取，就好像命令已经以＆con结尾
       控制操作员，在执行的外壳和主机之间建立双向管道
       塞斯。

       协同进程的格式是：

              coproc [NAME] command [redirections]

       这将创建一个名为NAME的协同进程。如果未提供NAME，则默认名称为COPROC。
       如果command是一个简单的命令，则不得提供NAME（见上文）;否则就是
       被解释为简单命令的第一个单词。当执行coproc时，
       shell在执行的上下文中创建一个名为NAME的数组变量（请参阅下面的数组）
       壳。命令的标准输出通过管道连接到文件描述符
       执行shell，并将该文件描述符分配给NAME [0]。命令的标准输入
       通过管道连接到执行shell中的文件描述符，并且
       文件描述符分配给NAME [1]。此管道在任何重定向之前建立
       由命令指定（参见下面的REDIRECTION）。文件描述符可以用作
       shell命令的参数和使用标准表达式的重定向的参数。这个过程
       为执行协同进程而生成的shell的ID可用作变量的值
       NAME_PID。 wait 内建命令可用于等待协处理器终止。

       协同进程的返回状态是命令的退出状态。

   壳函数定义
       shell函数是一个被称为简单命令并执行一个带一组新位置参数的复合命令
        Shell函数声明如下：

       name（）compound-command [重定向]
       函数名[（）]复合命令[重定向]
              这定义了一个名为name的函数。保留字功能是可选的。如果
              提供了函数保留字，括号是可选的。的身体
              function是复合命令compound-command（参见上面的Compound命令）。
              该命令通常是{和}之间的命令列表，但可以是任何命令
              在上面的复合命令下列出。只要名称是，就执行复合命令
              指定为简单命令的名称。任何重定向（请参阅下面的重定向）
              执行函数时执行定义函数时指定的值。
              除非发生语法错误或a，否则函数定义的退出状态为零
              已存在具有相同名称的只读函数。执行时，退出状态
              函数的函数是在正文中执行的最后一个命令的退出状态。 （看到
              功能如下。）
COMMENTS
       在非交互式shell中，或者是interactive_comments中的交互式shell
       购物中心内置的选项已启用（参见下面的SHELL BUILTIN命令），一个单词开头
       with＃会导致该行以及该行上的所有剩余字符被忽略。一个
       未启用interactive_comments选项的活动shell不允许注释。该
       交互式shell中默认启用interactive_comments选项。

QUOTING
       引用用于删除shell中某些字符或单词的特殊含义。
       引用可用于禁用特殊字符的特殊处理，以防止
       保留字不被识别，并防止参数扩展。

       上面在DEFINITIONS下面列出的每个元字符对shell都有特殊的含义
       如果要代表自己，必须引用。

       使用命令历史记录扩展功能时（参见下面的历史扩展），
       通常，必须引用历史扩展字符以防止历史扩展。

       有三种引用机制：转义字符，单引号和双引号。

       未引用的反斜杠（\）是转义字符。它保留了下一个字符的字面值
       <newline>除外。如果是\ <换行符>对
       出现，并且反斜杠本身没有引用，\ <newline>被视为一行con
       tinuation（即，它从输入流中删除并被有效忽略）。

       用单引号括起字符
       es保留每个字符的字面值
       报价。单引号之间可能不会出现单引号，即使以a开头也是如此
       反斜杠。

       用双引号括起字符可保留其中所有字符的字面值
       引号，但$，`，\和，当启用历史记录扩展时，除了！该
       字符$和`在双引号内保留其特殊含义。反斜杠
       只有当后面跟着以下字符之一时才保留其特殊含义：$，`，“，
       \，或<newline>。双引号可以在双引号内引用，前面加上a
       反斜杠。如果启用，将执行历史记录扩展，除非！出现在dou-
       使用反斜杠转义引号。之前的反斜杠！没有删除。

       在双引号中，特殊参数*和@具有特殊含义（参见PARAMETERS
       下面）。

       $'string'形式的单词是专门处理的。这个词扩展为字符串，背面 - 
       斜杠转义字符已按ANSI C标准的规定替换。反斜杠逃脱
       序列（如果存在）按如下方式解码：
              警报（铃）
              \ b退格
              。\ E
              \ E逃脱角色
              \ f表格饲料
              \ n新行
              \ r \ n回车
              \ t水平标签
              \ v垂直标签
              \\反斜杠
              单引号
              “双引号
              \ nnnn八位字符，其值为八进制值nnn（一到三个数字 - 
                     它的）
              \ xHH八位字符，其值为十六进制值HH（一个或两个
                     十六进制数字
              \ uHHHH Unicode（ISO / IEC 10646）字符，其值为十六进制值
                     HHHH（一到四个十六进制数字）
              \ UHHHHHHHH
                     Unicode（ISO / IEC 10646）字符，其值为十六进制值
                     HHHHHHHH（一到八位十六进制数字）
              \ cx是control-x字符

       扩展结果是单引号，好像美元符号不存在一样。

       带有美元符号（$“string”）的双引号字符串将导致该字符串
       根据当前的语言环境进行翻译。如果当前的语言环境是C或POSIX，那么
       lar符号被忽略了。如果字符串被翻译和替换，则替换为双
       引。

参数
       参数是存储值的实体。它可以是名称，数字或其中之一
       特殊参数下列出的特殊字符。变量是一个参数
       用名字表示。变量具有值和零个或多个属性。属性是
       使用declare builtin命令分配（请参阅SHELL BUILTIN命令中的声明）。

       如果已为其分配了值，则会设置该参数。空字符串是有效值。
       设置变量后，只能使用unset builtin命令取消设置（参见SHELL
       下面的建筑命令）。

       可以通过表单的语句分配变量

              名称= [值]

       如果未给出值，则为变量分配空字符串。所有值都经过波浪形
       扩展，参数和变量扩展，命令替换，算术扩展，
       和报价删除（见下面的扩展）。如果变量的整数属性设置为
       然后将值计算为算术表达式，即使$（（...））扩展不是
       使用（参见下面的算术扩展）。除了例外，不执行单词拆分
       “$ @”如下面特殊参数下所述。不执行路径名扩展。
       赋值语句也可以作为别名，声明，排版，导出的参数出现，
       readonly和本地内置命令。

       在赋值语句为shell变量赋值的上下文中
       数组索引，+ =运算符可用于追加或添加到变量的前一个
       值。当+ =应用于已设置整数属性的变量时，
       value被计算为算术表达式并添加到变量的当前值，
       这也被评估。当使用复合赋值将+ =应用于数组变量时
       （参见下面的数组），变量的值不会被设置（就像使用=时一样），而新的值 - 
       ues被附加到数组，从大于数组的最大索引开始（对于
       索引数组）或作为关联数组中的附加键值对添加。什么时候
       应用于字符串值变量，值被扩展并附加到变量's
       值。

   位置参数
       位置参数是由除了单个之外的一个或多个数字表示的参数
       数字0.位置参数是在调用shell时从shell的参数赋值的，
       并且可以使用set builtin命令重新分配。位置参数可能不是
       分配给赋值语句。位置参数暂时被替换
       执行shell函数时（参见下面的功能）。

       当扩展由多个数字组成的位置参数时，它必须是
       用括号括起来（见下面的扩展）。

   特殊参数
       shell专门处理几个参数。这些参数只能被引用;
       不允许分配给他们。
       *从一个开始扩展到位置参数。当扩张发生时
              在双引号内，它使用每个参数的值扩展为单个单词
              由IFS特殊变量的第一个字符分隔。也就是说，“$ *”是
              相当于“$ 1c $ 2c ...”，其中c是IFS值的第一个字符
              变量。如果未设置IFS，则参数由空格分隔。如果IFS为null，
              参数连接时没有插入分隔符。
       @从一个开始扩展到位置参数。当扩张发生时
              在双引号内，每个参数都会扩展为单独的单词。也就是说，“$ @”是
              相当于“$ 1”“$ 2”...如果双引号扩展发生在一个单词中，
              第一个参数的扩展与原始的初始部分相结合
              nal word，并且最后一个参数的扩展与最后一部分连接在一起
              原来的字。当没有位置参数时，“$ @”和$ @展开到
              没有（即，他们被删除）。
       ＃扩展为十进制的位置参数数。
       ？扩展到最近执行的前台管道的退出状态。
        - 通过set builtin扩展到调用时指定的当前选项标志
              命令，或shell本身设置的命令（例如-i选项）。
       $扩展为shell的进程ID。在（）子shell中，它扩展到进程
              当前shell的ID，而不是子shell。
       ！扩展到最近执行的后台的进程ID（异步）
              命令。
       0扩展为shell或shell脚本的名称。这是在shell初始化时设置的
              灰。如果使用命令文件调用bash，则将$ 0设置为该名称
              文件。如果使用-c选项启动bash，则将$ 0设置为第一个参数
              在要执行的字符串之后，如果存在。否则，它被设置为
              用于调用bash的文件名，由参数zero指定。
       _在shell启动时，设置为用于调用shell或shell的绝对路径名
              正在环境或参数列表中传递的脚本。随后，
              扩展后扩展到上一个命令的最后一个参数。也设置为
              用于调用执行并放置在环境中的每个命令的完整路径名
              导出到该命令。检查邮件时，此参数保存的名称
              当前正在检查的邮件文件。

   壳变量
       以下变量由shell设置：

       BASH扩展为用于调用此bash实例的完整文件名。
       BASHOPTS
              以冒号分隔的已启用shell选项列表。列表中的每个单词都是有效的
              shopt builtin命令的-s选项的参数（参见SHELL BUILTIN命令
              下面）。出现在BASHOPTS中的选项是由shopt报告的选项。如果
              这个变量是在bash启动时的环境中，每个shell选项都在
              列表将在读取任何启动文件之前启用。该变量是只读的。
       BASHPID
              扩展为当前bash进程的进程ID。这与$$不同
              某些情况，例如不需要bash重新初始化的子shell
              化的。
       BASH_ALIASES
              一个关联数组变量，其成员对应于内部列表
              由别名内置维护的别名。添加到此数组的元素显示在
              别名列表;取消设置数组元素会导致从别名中删除别名
              名单。
       BASH_ARGC
              一个数组变量，其值是每个帧中的参数数量
              当前bash执行调用堆栈。当前子程序的参数个数 - 
              tine（用。或源执行的shell函数或脚本）位于顶部
              堆。执行子程序时，将推送传递的参数数量
              到BASH_ARGC。 shell仅在处于扩展调试模式时才设置BASH_ARGC（请参阅
              下面内置shopt的extdebug选项的描述）
       BASH_ARGV
              包含当前bash执行中所有参数的数组变量
              调用堆栈。最后一个子程序调用的最后一个参数位于顶部
              堆;初始调用的第一个参数位于底部。当一个子程序
              执行后，提供的参数将被推送到BASH_ARGV。外壳设置
              BASH_ARGV仅在扩展调试模式下（参见extdebug的说明）
              购买内置商店的选项）
       BASH_CMDS
              一个关联数组变量，其成员对应于内部哈希表
              由内置哈希维护的命令。添加到此数组的元素显示在
              哈希表;未设置的数组元素导致从哈希中删除命令
              表。
       BASH_COMMAND
              除非shell是，否则当前正在执行或即将执行的命令
              作为陷阱的结果执行命令，在这种情况下，它是命令执行 - 
              在陷阱的时候。
       BASH_EXECUTION_STRING
              -c调用选项的命令参数。
       BASH_LINENO
              一个数组变量，其成员是源文件中的行号，其中每个变量
              调用了FUNCNAME的响应成员。 $ {BASH_LINENO [$ i]}是中的行号
              源文件（$ {BASH_SOURCE [$ i + 1]}）其中调用$ {FUNCNAME [$ i]}（或
              $ {BASH_LINENO [$ i-1]}如果在另一个shell函数中引用的话）。使用LINENO来
              获取当前行号。
       BASH_REMATCH
              一个数组变量，其成员由=〜二元运算符赋值给[[
              条件命令。索引为0的元素是字符串匹配的部分
              整个正则表达式。索引为n的元素是。的部分
              匹配第n个带括号的子表达式的字符串。该变量是只读的。
       BASH_SOURCE
              一个数组变量，其成员是相应的源文件名
              定义了FUNCNAME数组变量中的shell函数名称。 shell函数
              $ {FUNCNAME [$ i]}在文件$ {BASH_SOURCE [$ i]}中定义，并从
              $ {BASH_SOURCE [$ I + 1]}。
       BASH_SUBSHELL
              每次生成子shell或子shell环境时增加1。该
              初始值为0。
       BASH_VERSINFO
              一个只读数组变量，其成员包含此实例的版本信息
              bash。分配给数组成员的值如下：
              BASH_VERSINFO [0]主要版本号（发行版）。
              BASH_VERSINFO [1]次要版本号（版本）。
              BASH_VERSINFO [2]补丁级别。
              BASH_VERSINFO [3]构建版本。
              BASH_VERSINFO [4]发布状态（例如，beta1）。
              BASH_VERSINFO [5] MACHTYPE的值。
       BASH_VERSION
              扩展为描述此bash实例版本的字符串。
       COMP_CWORD
              包含当前光标位置的单词$ {COMP_WORDS}的索引。
              此变量仅在可编程组件调用的shell函数中可用。
              许可设施（见下面的可编程完成）。
       COMP_KEY
              用于调用当前完成函数的键（或键序列的最终键）
              灰。
       COMP_LINE
              当前的命令行。此变量仅在shell函数中可用
              可编程完井设施调用的外部命令（见程序 - 
              mable完成下面）。
       COMP_POINT
              当前光标位置相对于当前开头的索引
              命令。如果当前光标位置在当前命令的末尾，则
              此变量的值等于$ {#COMP_LINE}。此变量仅可用
              在shell函数和由可编程完成调用的外部命令中
              设施（见下面的可编程完成）。
       COMP_TYPE
              设置为与尝试完成的类型相对应的整数值
              导致调用完成函数：TAB，正常完成，？，列表 - 
              连续标签后的完成，！，用于列出部分单词的备选方案
              完成，@，列出完成，如果单词未被修改，或列出％，用于菜单
              完成。此变量仅在shell函数和外部函数中可用
              由可编程完成设施调用的mands（参见可编程完成
              下面）。
       COMP_WORDBREAKS
              readline库在处理时作为单词分隔符处理的字符集
              形成单词完成。如果COMP_WORDBREAKS未设置，则会失去其特殊的适当性 - 
              关系，即使它随后被重置。
       COMP_WORDS
              一个数组变量（参见下面的数组），由变量中的单个单词组成
              租用命令行。使用时，该行被拆分为单词，因为readline会将其拆分
              COMP_WORDBREAKS如上所述。此变量仅在shell函数中可用
              可编程完成设施调用的tions（参见可编程完成
              下面）。
       COPROC创建一个数组变量（参见下面的数组），用于保存输出的文件描述符
              来自并输入到未命名的协同处理（参见上面的Coprocesses）。
       DIRSTACK
              一个数组变量（参见下面的数组），包含目标的当前内容
              保守党堆栈。目录按照它们显示的顺序出现在堆栈中
              dirs builtin。分配给此数组变量的成员可用于修改
              已经在堆栈中的目录，但必须使用pushd和popd内置函数
              添加和删​​除目录。对此变量的赋值不会更改当前值
              目录。如果未设置DIRSTACK，它将失去其特殊属性，即使它是
              随后重置。
       EUID扩展为当前用户的有效用户ID，在shell启动时初始化。
              这个变量是只读的。
       FUNCNAME
              一个数组变量，包含当前在exe中的所有shell函数的名称
              cution call stack。索引为0的元素是当前正在执行的任何元素
              shell函数。最底部的元素（索引最高的元素）是“main”。
              此变量仅在执行shell函数时存在。分配给FUNC-
              NAME无效并返回错误状态。如果未设置FUNCNAME，则会丢失它
              特殊属性，即使它随后被重置。

              此变量可与BASH_LINENO和BASH_SOURCE一起使用。 FUNC的每个元素 - 
              NAME在BASH_LINENO和BASH_SOURCE中有相应的元素来描述调用
              堆。例如，$ {FUNCNAME [$ i]}是从文件$ {BASH_SOURCE [$ i + 1]}中调用的
              在行号$ {BASH_LINENO [$ i]}。内置呼叫者显示当前呼叫
              堆栈使用此信息。
       GROUPS一个数组变量，包含当前用户为mem的组列表
              BER。对GROUPS的分配无效并返回错误状态。如果是GROUPS
              未设置，即使随后重置，它也会失去其特殊属性。
       HISTCMD
              当前命令的历史记录编号或历史记录列表中的索引。如果
              HISTCMD未设置，即使随后重置，它也会丢失其特殊属性。
       HOSTNAME
              自动设置为当前主机的名称。
       HOSTTYPE
              自动设置为唯一描述其上的机器类型的字符串
              bash正在执行。默认值取决于系统。
       LINENO每次引用此参数时，shell都会替换一个十进制数字
              在脚本或内部重新发送当前的顺序行号（以1开头）
              功能。如果不在脚本或函数中，则不保证替换值
              有意义。如果LINENO未设置，即使它失去了它的特殊属性
              随后被重置。
       MACHTYPE
              自动设置为完全描述bash所在系统类型的字符串
              以标准GNU cpu-company-system格式执行。默认为系统 - 
              依赖。
       MAPFILE
              创建一个数组变量（请参阅下面的数组）以保存mapfile读取的文本
              没有提供变量名时内置。
       OLDPWD cd命令设置的上一个工作目录。
       OPTARG getopts builtin命令处理的最后一个选项参数的值（参见
              SHELL BUILTIN COMMANDS如下）。
       OPTIND getopts builtin命令要处理的下一个参数的索引（参见
              SHELL BUILTIN COMMANDS如下）。
       OSTYPE自动设置为描述bash所在操作系统的字符串
              执行。默认值取决于系统。
       PIPESTATUS
              一个数组变量（参见下面的数组），其中包含一个退出状态值列表
              最近执行的前台管道中的进程（可能包含
              只有一个命令）。
       PPID shell的父进程ID。这个变量是只读的。
       PWD cd命令设置的当前工作目录。
       RANDOM每次引用此参数时，0到32767之间的随机整数都是
              erated。可以通过赋值来初始化随机数序​​列
              随机。如果RANDOM未设置，它将失去其特殊属性，即使它是subse-
              很快重置。
       READLINE_LINE
              readline行缓冲区的内容，用于“bind -x”（参见SHELL BUILTIN
              下面的命令）。
       READLINE_POINT
              插入点在readline行缓冲区中的位置，用于“绑定”
              -x“（参见下面的SHELL BUILTIN命令）。
       REPLY设置为read builtin命令读取的输入行，当没有参数支持时
              合股。
       SECONDS
              每次引用此参数时，自shell调用以来的秒数
              退回。如果为SECONDS分配了值，则后续返回的值
              references是分配后的秒数加上分配的值。
              如果SECONDS未设置，它将失去其特殊属性，即使它是随后的
              重启。
       SHELLOPTS
              以冒号分隔的已启用shell选项列表。列表中的每个单词都是有效的
              set builtin命令的-o选项的参数（请参阅SHELL BUILTIN命令
              下面）。 SHELLOPTS中出现的选项是由set -o报告的选项。如果
              这个变量是在bash启动时的环境中，每个shell选项都在
              列表将在读取任何启动文件之前启用。该变量是只读的。
       SHLVL每次启动bash实例时增加1。
       UID扩展为当前用户的用户标识，在shell启动时初始化。这个
              变量是只读的。

       shell使用以下变量。在某些情况下，bash会指定一个默认值
       变量;这些情况如下所述。

       BASH_ENV
              如果在bash执行shell脚本时设置了此参数，则其值为
              作为包含初始化shell的命令的文件名，如〜/ .bashrc。
              BASH_ENV的值受参数扩展，命令替换和
              算术扩展在被解释为文件名之前。 PATH不习惯
              搜索结果文件名。
       BASH_XTRACEFD
              如果设置为对应于有效文件描述符的整数，bash将写入
              将-x设置为该文件描述符时生成的跟踪输出。文件
              当取消设置BASH_XTRACEFD或分配新值时，将关闭描述符。解封
              BASH_XTRACEFD或为其分配空字符串会导致将跟踪输出发送到
              标准错误。请注意，将BASH_XTRACEFD设置为2（标准错误文件
              描述符）然后取消设置将导致标准错误被关闭。
       CDPATH cd命令的搜索路径。这是以冒号分隔的目录列表
              其中shell查找cd命令指定的目标目录。一个
              样本值为“。：〜：/ usr”。
       列
              select复合命令用于确定打印时的端子宽度
              选择清单。收到SIGWINCH后自动设置。
       COMPREPLY
              一个数组变量，bash从中读取a生成的可能完成
              可编程完成工具调用的shell函数（参见Programmable
              完成下面）。
       EMACS如果bash在shell以值“t”开头时在环境中找到此变量，
              它假定shell在Emacs shell缓冲区中运行并禁用行
              编辑。
       ENV类似于BASH_ENV;在POSIX模式下调用shell时使用。
       FCEDIT fc内置命令的默认编辑器。
       FIGNORE
              执行文件名完成时要忽略的以冒号分隔的后缀列表
              （见下面的READLINE）。一个文件名，其后缀与FIGNORE中的一个条目匹配
              从匹配的文件名列表中排除。示例值为“.o：〜”。
       FUNCNEST
              如果设置为大于0的数值，则定义最大函数嵌套级别。
              超过此嵌套级别的函数调用将导致当前命令
              中止。
       GLOBIGNORE
              以冒号分隔的模式列表，用于定义要忽略的文件名集
              路径名扩展。如果文件名也与路径名扩展模式匹配
              匹配GLOBIGNORE中的一个模式，它将从匹配列表中删除。
       HISTCONTROL
              以冒号分隔的值列表，用于控制命令在历史记录中的保存方式
              名单。如果值列表包括ignorespace，则以空格开头的行
              字符未保存在历史记录列表中。 ignoredups的值会导致行
              匹配以前的历史记录条目以保存。 ignoreboth的值是
              ignorespace和ignoredups的简写。 erasedups的值会导致之前的所有内容
              匹配要从该行之前的历史列表中删除的当前行的行
              得救了。忽略上面列表中没有的任何值。如果未设置HISTCONTROL，或
              不包含有效值，shell解析器读取的所有行都保存在
              历史列表，受HISTIGNORE的价值限制。第二行和后续行
              未测试多行复合命令，并将其添加到历史记录中
              无论HISTCONTROL的值如何。
       HISTFILE
              保存命令历史记录的文件的名称（请参阅下面的历史记录）。该
              默认值是〜/ .bash_history。如果未设置，则不会保存命令历史记录
              一个交互式shell退出。
       HISTFILESIZE
              历史文件中包含的最大行数。当这个变量是
              如果分配了一个值，则必要时通过删除旧的 - 来截断历史文件
              est条目，包含不超过该行数。默认值为
              500.历史文件在写入时也会被截断为此大小
              交互式shell退出。
       HISTIGNORE
              用冒号分隔的模式列表，用于决定应该使用哪些命令行
              保存在历史列表中。每个模式都锚定在行的开头
              并且必须匹配整行（不附加隐式`*'）。每种模式都是
              在应用HISTCONTROL指定的检查后对该行进行测试。在
              除了正常的shell模式匹配字符外，`＆'匹配前一个
              历史路线。 `＆'可以使用反斜杠进行转义;之前删除了反斜杠
              尝试比赛。多行化合物的第二行和后续行
              未经测试，并且无论HISTIG的价值如何，都被添加到历史记录中
              NORE。
       HISTSIZE
              命令历史记录中要记住的命令数（请参阅下面的历史记录）。该
              默认值为500。
       HISTTIMEFORMAT
              如果设置此变量且不为null，则其值将用作strf-的格式字符串
              time（3）打印与显示的每个历史条目相关联的时间戳
              历史建立。如果设置了此变量，则会将时间戳记写入历史记录
              文件，以便它们可以跨shell会话保留。这使用历史评论
              用于区分时间戳与其他历史记录行的字符。
       HOME当前用户的主目录; cd builtin com的默认参数
              普通话。执行波浪扩展时也使用此变量的值。
       HOSTFILE
              包含与应读取的/ etc / hosts格式相同的文件名
              当shell需要完成主机名时。可能的主机名列表 - 
              在shell运行时可能会改变tions;下次主机名完成
              在更改值后尝试，bash将新文件的内容添加到
              现有清单。如果设置了HOSTFILE但没有值，或者没有命名读取
              有能力的文件，bash尝试读取/ etc / hosts以获取可能的主机名列表
              落成。取消设置HOSTFILE时，将清除主机名列表。
       IFS内部字段分隔符，用于扩展后的分词和
              使用read builtin命令将行拆分为单词。默认值为
              ``<空间> <标签> <换行符> ''。
       IGNOREEOF
              控制交互式shell在接收EOF字符时的操作
              唯一的输入。如果设置，则该值是连续EOF字符的数量
              必须在bash退出之前输入输入行上的第一个字符。如果
              变量存在但没有数值，或
 没有价值，默认
              值为10.如果不存在，则EOF表示shell的输入结束。
       INPUTRC
              readline启动文件的文件名，覆盖默认的〜/ .inputrc
              （见下面的READLINE）。
       LANG用于确定未明确选择的任何类别的区域设置类别
              变量以LC_开头。
       LC_ALL此变量覆盖LANG的值以及指定a的任何其他LC_变量
              区域类别。
       LC_COLLATE
              此变量确定排序路径结果时使用的归类顺序 - 
              名称扩展，并确定范围表达式的行为，等价
              路径名扩展和模式匹配中的类和整理序列。
       LC_CTYPE
              此变量确定字符的解释和char-的行为
              路径名扩展和模式匹配中的acter类。
       LC_MESSAGES
              此变量确定用于转换前面引用的双引号字符串的语言环境
              一个$。
       LC_NUMERIC
              此变量确定用于数字格式的区域设置类别。
       LINES select复合命令用于确定打印的列长度
              选择清单。收到SIGWINCH后自动设置。
       MAIL如果此参数设置为文件或目录名称，则MAILPATH变量为
              未设置，bash通知用户邮件到达指定文件或
              Maildir格式目录。
       MAILCHECK
              指定bash检查邮件的频率（以秒为单位）。默认值为60秒。
              当需要检查邮件时，shell会在显示主邮件之前执行此操作
              提示。如果未设置此变量，或设置的值不是更大的数字
              大于或等于零，shell禁用邮件检查。
       MAILPATH
              要检查邮件的以冒号分隔的文件名列表。消息是
              当邮件到达特定文件时打印可以通过分离来指定
              带有“？”的消息中的文件名。在消息文本中使用时，$ _
              扩展为当前邮件文件的名称。例：
              MAILPATH ='/ var / mail / bfox？“你有邮件”：〜/ shell-mail？“$ _有邮件！”'
              Bash为此变量提供默认值，但提供用户邮件的位置
              它使用的文件是系统相关的（例如，/ var / mail / $ USER）。
       OPTERR如果设置为值1，则bash显示由内置的getopts生成的错误消息
              命令（参见下面的SHELL BUILTIN命令）。 OPTERR每次初始化为1
              调用shell或执行shell脚本。
       PATH命令的搜索路径。它是以冒号分隔的目录列表
              shell查找命令（请参阅下面的COMMAND EXECUTION）。零长度（null）
              PATH值中的目录名称表示当前目录。一个空的指示
              保守名称可以显示为两个相邻的冒号，或者作为初始或尾随冒号。
              默认路径是系统相关的，由安装的管理员设置
              庆典。一个常见的值是``/ usr / gnu / bin：/ usr / local / bin：/ usr / ucb：/ bin：/ usr / bin''。
       POSIXLY_CORRECT
              如果此变量在bash启动时处于环境中，则shell将进入posix模式
              在读取启动文件之前，好像-posix调用选项已经支持
              合股。如果在shell运行时设置它，则bash启用posix模式，就好像
              命令集-o posix已被执行。
       PROMPT_COMMAND
              如果设置，则在发出每个主要提示之前将该值作为命令执行。
       PROMPT_DIRTRIM
              如果设置为大于零的数字，则将该值用作尾随数
              扩展\ w和\ W提示字符串转义时保留的目录组件
              （见下面的提示）。删除的字符将替换为省略号。
       PS1此参数的值已扩展（请参阅下面的PROMPTING）并用作pri
              玛丽提示字符串。默认值为``\ s- \ v \ $''。
       PS2此参数的值与PS1一样展开，并用作辅助提示
              串。默认为“>”。
       PS3此参数的值用作select命令的提示符（请参阅SHELL
              上面的GRAMMAR）。
       PS4此参数的值与PS1一样扩展，之前打印该值
              每个命令bash在执行跟踪期间显示。 PS4的第一个字符是
              必要时多次复制以指示多个间接级别。
              默认为“+”。
       SHELL shell的完整路径名保存在此环境变量中。如果不是
              在shell启动时设置，bash为其分配当前的完整路径名
              用户的登录shell。
       TIMEFORMAT
              此参数的值用作指定时序方式的格式字符串
              应显示以时间保留字为前缀的管道信息。
              ％字符引入了一个转义为时间值或的转义序列
              其他信息。逃逸序列及其含义如下;该
              大括号表示可选部分。
              %%一个字面％。
              ％[p] [l] R以秒为单位的经过时间。
              ％[p] [l] U在用户模式下花费的CPU秒数。
              ％[p] [l] S在系统模式下花费的CPU秒数。
              ％P CPU百分比，计算方式为（％U +％S）/％R。

              可选p是指定精度，小数位数的数字
              小数点后。值为0表示没有小数点或分数超出
              放。最多可以指定小数点后的三个位置; p的值
              大于3将更改为3.如果未指定p，则使用值3。

              可选的l指定MMmSS.FFs格式的更长格式，包括分钟。
              p的值确定是否包括分数。

              如果未设置此变量，则bash就像具有该值一样
              $ '\ nreal \ T％3LR \ n用户\ T％3LU \ NSYS％3LS'。如果该值为null，则没有计时信息
              被展示。显示格式字符串时，将添加尾随换行符。
       TMOUT如果设置为大于零的值，TMOUT将被视为默认超时
              读内置。如果在TMOUT之后输入未到达，则select命令终止
              输入来自终端的秒数。在交互式shell中，值为
              解释为发出主要数据后等待输入的秒数
              提示。如果输入没有，则等待该秒数后Bash终止
              到达。
       TMPDIR如果设置，bash使用其值作为bash创建节点的目录的名称
              用于shell的rary文件。
       auto_resume
              此变量控制shell如何与用户和作业控件交互。如果
              设置此变量后，将处理不带重定向的单字简单命令
              作为恢复现有停工的候选人。没有含糊之处
              允许;如果有一个以键入的字符串开头的多个作业，则该作业最多
              最近访问被选中。在这种情况下，已停止作业的名称是
              用于启动它的命令行。如果设置为exact，则必须提供字符串
              完全匹配已停止作业的名称;如果设置为substring，则提供字符串
              需要匹配已停止作业名称的子字符串。子串值pro-
              提供类似于％的功能？作业标识符（参见下面的JOB CONTROL）。如果
              设置为任何其他值，提供的字符串必须是已停止作业的前缀
              名称;这提供了类似于％字符串作业标识符的功能。
       histchars
              控制历史扩展和标记化的两个或三个字符（参见
              下面的历史扩展）。第一个字符是历史扩展字符，
              表示历史扩展开始的字符，通常是“！”。该
              第二个字符是快速替换字符，用作速记
              重新运行上一个输入的命令，用一个字符串代替另一个字符串
              命令。默认为“^”。可选的第三个字符是字符
              表示当找到第一个字符时，该行的其余部分是注释
              一句话，通常是'＃'。历史评论字符导致历史记录替代
              要跳过该行上剩余的单词的tution。它不一定
              使shell解析器将该行的其余部分视为注释。

   数组
       Bash提供一维索引和关联数组变量。任何变量都可能是
       用作索引数组; declare 内建函数将显式声明一个数组。有
       没有数组大小的最大限制，也没有要求成员编入索引或
       连续分配。索引数组使用整数引用（包括算术）
       表达式）并且基于零;关联数组使用任意引用
       字符串。

       如果使用语法分配任何变量，则会自动创建索引数组
       名称[下标] =值。下标被视为必须的算术表达式
       评估一个数字。如果下标的计算结果小于零，则将其用作
       从一个大于数组的最大索引的偏移量（所以-1的子标题指的是
       数组的最后一个元素）。要显式声明索引数组，请使用declare -a name
       （参见下面的SHELL BUILTIN命令）。声明-a name [下标]也被接受;子
       脚本被忽略。

       使用declare -A name创建关联数组。

       可以使用declare和readonly 内建函数为数组变量指定属性。
       每个属性都适用于数组的所有成员。

       数组被赋值为使用形式名称=（value1 ... valuen）的复合赋值，
       其中每个值的格式为[subscript] = string。索引数组赋值没有
       需要括号和下标。分配给索引数组时，如果是可选的
       提供括号和下标，该索引被分配给;否则索引
       已分配的元素是语句分配的最后一个索引加一。索引开始
       在零。

       分配给关联数组时，下标是必需的。

       声明内置也接受此语法。各个数组元素可以是
       分配使用上面介绍的名称[subscript] = value语法。

       可以使用$ {name [subscript]}引用数组的任何元素。大括号是
       要求避免与路径名扩展冲突。如果下标是@或*，那么这个词
       扩展到名称的所有成员。这些下标仅在单词出现时才有所不同
       双引号。如果单词是双引号，$ {name [*]}会扩展为单个单词
       每个数组成员的值由IFS特殊变量的第一个字符分隔，
       和$ {name [@]}将name的每个元素扩展为一个单独的单词。没有数组的时候
       成员，$ {name [@]}扩展为空。如果双引号扩展发生在a
       单词，第一个参数的扩展与原始的初始部分相连接
       最后一个字，最后一个参数的扩展与原始的最后一部分相结合
       内在的词。这类似于特殊参数*和@的扩展（参见Spe-
       上面的cial参数）。 $ {＃name [下标]}扩展为$ {name [下标]}的长度。
       如果下标是*或@，则扩展是数组中元素的数量。引用
       没有下标的数组变量相当于引用带有子代的数组
       脚本0。

       如果已为下标指定值，则认为数组变量已设置。 null
       string是一个有效值。

       未设置的内置用于销毁数组。未设置的名称[下标]破坏了数组元素 - 
       索引下标。必须注意避免路径引起的不良副作用 - 
       名称扩展。取消设置名称，其中name是数组，或取消设置名称[下标]，其中sub-
       script是*或@，删除整个数组。

       declare，local和readonly内置函数都接受-a选项来指定索引
       array和-A选项以指定关联数组。如果提供了两个选项，则为-A
       优先。 read builtin接受-a选项来分配从中读取的单词列表
       数组的标准输入。 set和declare builtins以某种方式显示数组值
       这允许他们作为作业重复使用。

扩张
       在将命令行拆分为单词后，将在命令行上执行扩展。有
       执行七种扩展：支撑扩展，波浪扩展，参数和变量
       扩展，命令替换，算术扩展，分词和路径名
       扩张。

       扩展的顺序是：支撑扩展，波浪扩展，参数，变量和
       算术扩展和命令替换（以从左到右的方式完成），单词
       拆分和路径名扩展。

       在可以支持它的系统上，还有一个额外的扩展可用：进程替代
       形式予以。

       只有大括号扩展，单词拆分和路径名扩展才能改变单词的数量
       扩张;其他扩展将单个单词扩展为单个单词。唯一的例外 - 
       对此的扩展是“$ @”和“$ {name [@]}”的扩展，如上所述（参见PARAME-
       TERS）。

   支持扩张
       支撑扩展是一种可以生成任意字符串的机制。这个机制
       类似于路径名扩展，但生成的文件名不需要存在。模式
       采用可选序言的形式进行扩展，然后是一系列的
       逗号分隔的字符串或一对大括号之间的序列表达式，后跟一个
       可选的附言。前导码以括号内包含的每个字符串为前缀，
       然后将postscript附加到每个结果字符串，从左到右展开。

       Brace扩展可以嵌套。每个扩展字符串的结果都没有排序;剩下
       保持正确的秩序。例如，{d，c，b} e扩展为“ade ace abe”。

       序列表达式采用{x..y [.. incr]}的形式，其中x和y是整数或
       单个字符和incr（可选的增量）是一个整数。当整数是支持
       plied，表达式扩展到x和y之间的每个数字，包括0和y。提供的整数
       可以以0为前缀以强制每个术语具有相同的宽度。当x或y时
       从零开始，shell尝试强制所有生成的术语包含相同的内容
       必要时的位数，零填充。提供字符时，表达 - 
       sion在x和y之间按字典顺序扩展到每个字符，包括在内。注意
       x和y必须是相同的类型。当提供增量时，它被用作
       每个术语之间的差异。根据需要，默认增量为1或-1。

       在任何其他扩展之前执行大括号扩展，以及任何特殊的字符
       结果中保留了其他扩展。这是严格的文字。 Bash不适用
       任何语法解释扩展的上下文或文本之间的文本
       括号。

       正确形成的支撑膨胀必须包含不带引号的开口和闭合支撑，以及
       至少一个不带引号的逗号或有效的序列表达式。任何错误形成的支撑
       扩张保持不变。一个{或者，可以用反斜杠引用以防止其存在
       被认为是大括号表达的一部分。为避免与参数扩展冲突，
       string $ {不被视为有资格进行大括号扩展。

       当字符串的公共前缀为时，此构造通常用作速记
       生成的时间比上例更长：

              mkdir / usr / local / src / bash / {old，new，dist，bugs}
       要么
              chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}

       支撑扩展引入了与sh的历史版本的轻微不兼容。 SH
       当它们作为单词的一部分出现时，不会特别处理打开或关闭括号，以及
       在输出中保留它们。 Bash从大括号中删除大括号
       扩张。例如，输入sh作为文件{1,2}的单词在out-out中出现相同
       放。在bash扩展后，同一个单词输出为file1 file2。如果严格兼容
       需要使用sh的bility，使用+ B选项启动bash或使用禁用括号扩展
       set命令的+ B选项（参见下面的SHELL BUILTIN命令）。

   Tilde扩张
       如果一个单词以不带引号的代字号（“〜”）开头，则前面是所有字符
       第一个未加引号的斜杠（或所有字符，如果没有未加引号的斜杠）被考虑
       一个波浪号前缀。如果没有引用tilde-prefix中的字符，则为字符
       在代字号后面的波浪号前缀被视为可能的登录名。如果这
       login name是空字符串，tilde替换为shell参数的值
       家。如果未设置HOME，则替换执行shell的用户的主目录
       代替。否则，tilde-prefix将替换为与之关联的主目录
       指定的登录名。

       如果波浪号前缀是“〜+”，则shell变量PWD的值将替换波浪号 - 前 - 
       固定。如果tilde-prefix是“〜 - ”，则shell变量OLDPWD的值（如果已设置）
       被取代。如果波浪号前缀中波浪号后面的字符由a组成
       数字N，可选地以“+”或“ - ”为前缀，代字号前缀替换为cor-
       来自目录堆栈的响应元素，因为它将由内置的dirs显示
       使用tilde-prefix作为参数调用。如果字符后面的波浪号
       tilde-prefix由一个没有前导“+”或“ - ”的数字组成，假定为“+”。

       如果登录名无效，或者代字号扩展失败，则该字不变。

       在以下情况之后立即检查每个变量赋值的未加引号的波浪号前缀：
       或者第一个=。在这些情况下，还执行波浪扩展。因此，有人可能
       在PATH，MAILPATH和CDPATH以及shell的赋值中使用带有波浪号的文件名
       分配扩展值。

   参数扩展
       `$'字符引入了参数扩展，命令替换或算术
       扩张。要展开的参数名称或符号可以用大括号括起来
       是可选的，但用于保护变量立即从字符扩展
       跟随它可以被解释为名称的一部分。

       使用大括号时，匹配的结束括号是第一个没有反斜杠转义的`}'
       或者在带引号的字符串中，而不是在嵌入式算术扩展中，命令substi-
       tution，或参数扩展。

       $ {}参数
              参数的值被替换。当参数为a时，需要括号
              具有多个数字的位置参数，或者当参数后跟a时
              不应被解释为其名称一部分的字符。

       如果参数的第一个字符是感叹号（！），则变量indi-的级别
       反思是介绍的。 Bash使用由其余参数形成的变量的值
       ter作为变量的名称;然后展开此变量并使用该值
       替换的其余部分，而不是参数本身的值。这被称为
       间接扩张。对此的例外是$ {！prefix *}和扩展
       $ {！name [@]}如下所述。感叹号必须紧跟左支撑
       为了引入间接。

       在下面的每个案例中，单词都受波形扩展，参数扩展，
       mand替换和算术扩展。

       当不执行子串扩展时，使用下面记录的表单，bash测试a
       未设置的参数或null。省略冒号只会导致参数测试
       这是未设置的。

       $ {参数：-word}
              使用默认值。如果参数未设置或为null，则单词的扩展为substi-
              tuted。否则，参数的值将被替换。
       $ {参数：=词}
              分配默认值。如果参数未设置或为null，则单词的扩展为
              分配给参数。然后替换参数的值。位置
              不能以这种方式分配参数和特殊参数。
       $ {参数：？单词}
              如果为空或未设置则显示错误。如果参数为null或未设置，则扩展
              如果单词不存在，则将单词（或该效果的消息）写入标准
              错误和shell，如果不是交互式，则退出。否则，值
              参数被替换。
       $ {参数：+单词}
              使用替代值。如果参数为null或未设置，则不替换任何内容，其他 - 
              明智的是，词语的扩展被取代了。
       $ {参数：偏移}
       $ {参数：偏移量：长度}
              子串扩展。从最开始扩展到参数的最大长度字符
              offset指定的字符。如果省略length，则扩展为子字符串
              参数从offset指定的字符开始。长度和偏移量
              算术表达式（参见下面的算术评估）。如果偏移评估为a
              如果数字小于零，则该值用作值的末尾的偏移量
              参数。如果length的计算结果小于零，且参数不是@
              而不是索引或关联数组，它被解释为从末尾开始的偏移量
              参数的值而不是一些字符，而扩展是
              两个偏移之间的字符。如果参数为@，则结果为length
              从偏移开始的位置参数。如果参数是索引数组名称
              由@或*下标，结果是以数组开头的长度成员
              $ {参数[偏移]}。相对于大于1的负偏移
              指定数组的最大索引。子串扩展应用于关联
              数组产生未定义的结果。请注意，必须分隔负偏移
              从冒号到至少一个空间，以避免与： - 扩展混淆。
              除非使用位置参数，否则子串索引是从零开始的
              case索引默认从1开始。如果offset是0，那么位置参数 - 
              使用eters，$ 0以列表为前缀。

       $ {！前缀*}
       $ {！前缀@}
              名称匹配前缀。扩展为名称以变量开头的变量的名称
              前缀，由IFS特殊变量的第一个字符分隔。什么时候
              使用和扩展出现在双引号内，每个变量名称扩展为a
              单词。

       $ {！名称[@]}
       $ {！名称[*]}
              数组键列表。如果name是数组变量，则展开到数组列表
              名称中指定的索引（键）。如果name不是数组，则如果name为，则展开为0
              set，否则为null。使用@时，扩展显示在double内
              引号，每个键扩展为一个单独的单词。

       $ {＃参数}
              参数长度。参数值的字符长度为substi-
              tuted。如果参数是*或@，则替换的值是位置数
              参数。如果参数是由*或@下标的数组名称，则值为substi-
              tuted是数组中元素的数量。

       $ {参数＃字}
       $ {参数##字}
              删除匹配的前缀模式。这个词被扩展为产生一个模式
              在路径名扩展中。如果模式匹配参数值的开头
              ter，那么扩展的结果就是参数的扩展值
              最短匹配模式（“＃”情况）或最长匹配模式（
              ``##''case）已删除。如果参数是@或*，则模式删除操作为
              依次应用于每个位置参数，并且扩展是结果
              名单。如果参数是使用@或*下标的数组变量，则为模式
              删除操作依次应用于数组的每个成员，并进行扩展
              是结果列表。

       $ {参数％字}
       $ {参数%%词}
              删除匹配的后缀模式。这个词被扩展为产生一个模式
              在路径名扩展中。如果模式匹配展开的尾部
              参数的值，那么扩展的结果是参数的扩展值
              使用最短的匹配模式（“％”的情况）或最长的匹配
              模式（``%%''案例）已删除。如果参数是@或*，则删除模式
              操作依次应用于每个位置参数，扩展为
              结果清单。如果参数是使用@或*下标的数组变量，那么
              tern删除操作依次应用于数组的每个成员，并且
              扩展是结果列表。

       $ {参数/模式/字符串}
              模式替换。扩展模式以产生一种模式，就像在路径中一样
              名称扩展。参数被扩展并且模式与其最长匹配
              value被替换为string。如果模式以/开头，则模式的所有匹配都是
              用字符串替换。通常只替换第一场比赛。如果模式开始
              使用＃，它必须在参数的扩展值的开头匹配。如果pat-
              tern以％开头，它必须在参数的扩展值的末尾匹配。如果
              string为null，删除模式的匹配，并且/ following模式可以是
              省略。如果参数是@或*，则替换操作将应用于每个参数
              依次定位参数，扩展是结果列表。如果参数
              是使用@或*下标的数组变量，应用替换操作
              依次对数组的每个成员，扩展是结果列表。

       $ {参数M模式}
       $ {参数^^模式}
       $ {参数，模式}
       $ {参数,,模式}
              案例修改。此扩展修改了字母字符的大小写
              参数。扩展模式以生成模式，就像路径名扩展一样
              锡永。 ^运算符将匹配模式的小写字母转换为大写;该
              ，operator将匹配的大写字母转换为小写。 ^^和,,扩展 - 
              sions转换扩展值中的每个匹配字符; ^和，扩展
              匹配并仅转换展开值中的第一个字符。如果模式是
              省略，它被视为一个？，它匹配每个字符。如果参数是@
              或者*，将大小写修改操作应用于每个位置参数
              转，扩展是结果列表。如果参数是数组变量
              使用@或*下标，案例修改操作适用于每个成员
              依次是数组，扩展是结果列表。

   命令替换
       命令替换允许输出命令来替换命令名称。有
       两种形式：

              $（命令）
       要么
              `command`

       Bash执行expa
nsion通过执行命令并替换命令替换
       使用命令的标准输出，删除任何尾随换行符。嵌入式新 - 
       不删除行，但可以在分词期间删除它们。命令替代
       tution $（cat文件）可以用等效但更快的$（<file）替换。

       当使用旧式反引号形式的替换时，反斜杠保留其字面值
       除了后跟$，`或\时的含义。第一个反引号前面没有后面的 - 
       斜杠终止命令替换。使用$（命令）表单时，所有字符
       括号之间组成命令;没有人特别对待。

       命令替换可以嵌套。要在使用反引号表单时进行嵌套，请转义
       带有反斜杠的内部反引号。

       如果替换出现在双引号内，则单词拆分和路径名扩展为
       未对结果执行。

   算术扩展
       算术扩展允许评估算术表达式和替换
       结果。算术扩展的格式是：

              $（（表达式））

       该表达式被视为在双引号内，但在双引号内
       括号不予特别处理。表达式中的所有标记都经过参数
       扩展，字符串扩展，命令替换和引用删除。算术扩展
       sions可能是嵌套的。

       评估是根据ARITHMETIC EVALUA-下列规则进行的。
       TION。如果表达式无效，bash会打印一条消息，指示失败并且没有替换 - 
       发生了。

   流程替代
       支持命名管道（FIFO）或支持命名管道的系统支持进程替换
       / dev / fd命名打开文件的方法。它采用<（list）或>（list）的形式。这个过程
       list的输入或输出连接到FIFO或/ dev / fd中的某个文件。名字
       作为扩展的结果，该文件作为参数传递给当前命令
       锡永。如果使用>（列表）表单，则写入文件将为列表提供输入。如果
       使用<（list）表单时，应该读取作为参数传递的文件以获取out-
       列表。

       可用时，过程替换与参数和变量同时执行
       能够扩展，命令替换和算术扩展。

   单词分裂
       shell扫描参数扩展，命令替换和算术的结果
       单词拆分中双引号内未出现的扩展。

       shell将IFS的每个字符视为分隔符，并拆分另一个字符的结果
       扩展到这些角色的文字。如果未设置IFS，或其值完全正确
       <space> <tab> <newline>，默认情况下，然后是<space>，<tab>和<newline>的序列。
       忽略前面扩展的结果的开始和结束，以及任何序列
       不在开头或结尾的IFS字符用于分隔单词。如果IFS有值
       除了默认值，那么空格字符空格和制表符的序列就是
       在单词的开头和结尾处被忽略，只要空格字符在
       IFS的值（IFS空白字符）。 IFS中任何非IFS白色字符 - 
       空格以及任何相邻的IFS空白字符，用于分隔字段。一系列的
       IFS空白字符也被视为分隔符。如果IFS的值为null，则为no
       发生单词分裂。

       保留显式空参数（“”或“”）。不带引号的隐式空参数，结果 - 
       从没有值的参数的扩展中删除。如果参数有
       没有值在双引号内扩展，null参数结果并保留。

       请注意，如果未发生扩展，则不执行拆分。

   路径名扩展
       分词后，除非设置了-f选项，否则bash会扫描每个单词以查找字符。
       acters *，？和[。如果出现其中一个字符，则该单词被视为a
       模式，并替换为按字母顺序排序的文件名列表
       燕鸥。如果找不到匹配的文件名，并且未启用shell选项nullglob，
       这个词保持不变。如果设置了nullglob选项，并且未找到匹配项，则
       字被删除。如果设置了failglob shell选项，但未找到匹配项，则会出现错误
       打印消息并且不执行该命令。如果是shell选项nocaseglob是
       启用后，执行匹配而不考虑字母字符的情况。什么时候
       一个模式用于路径名扩展，字符“。”在名称的开头或
       除非shell选项dotglob，否则必须明确匹配斜杠后面的斜杠
       已设定。匹配路径名时，必须始终明确匹配斜杠字符。
       在其他情况下，“。”字符不会被特别处理。请参阅说明
       关于nocaseglob，nullglob的描述，请在SHELL BUILTIN COMMANDS下面购买
       failglob和dotglob shell选项。

       GLOBIGNORE shell变量可用于限制与pat-匹配的文件名集
       燕鸥。如果设置了GLOBIGNORE，则每个匹配的文件名也与其中一个模式匹配
       在GLOBIGNORE中从匹配列表中删除。文件名“。”和“..”是
       设置GLOBIGNORE时始终忽略且不为null。但是，将GLOBIGNORE设置为非
       null值具有启用dotglob shell选项的效果，因此所有其他文件名都是如此
       以“。”开头会匹配。为了获得忽略文件名的旧行为，
       用“。”打开，使“。*”成为GLOBIGNORE中的一种模式。 dotglob选项是
       未设置GLOBIGNORE时禁用。

       模式匹配

       除特殊模式字符外，模式中出现的任何字符
       如下所述，匹配自己。 NUL字符可能不会出现在模式中。背面 - 
       斜线逃脱了以下角色;匹配时丢弃转义反斜杠。
       如果要按字面匹配，则必须引用特殊模式字符。

       特殊模式字符具有以下含义：

              *匹配任何字符串，包括空字符串。当globstar shell
                     选项已启用，*用于路径名扩展上下文，两个相邻
                     用作单个模式的cent * s将匹配所有文件，零个或多个direc-
                     托儿所和子目录。如果后跟一个/，则两个相邻的*将匹配
                     只有目录和子目录。
              ？匹配任何单个字符。
              [...]匹配任何一个附带的字符。一对字符分开
                     用连字符表示范围表达式;任何在其间排序的角色
                     这两个字符，包括使用当前区域设置的整理
                     序列和字符集匹配。如果第一个字符跟着
                     [是一个！或者^ ^然后匹配任何未包含的字符。排序
                     范围表达式中的字符顺序由当前区域设置决定
                     以及LC_COLLATE shell变量的值（如果已设置）。 A  - 可能匹配
                     将它包含在集合中的第一个或最后一个字符中。 A]可能是
                     通过将其包含在集合中的第一个字符进行匹配。

                     在[和]中，可以使用语法指定字符类
                     [：class：]，其中class是POSIX中定义的以下类之一
                     标准：
                     alnum alpha ascii空白cntrl数字图表下部打印punct空间上部词
                     xdigit
                     字符类匹配属于该类的任何字符。这个单词
                     字符类匹配字母，数字和字符_。

                     在[和]中，可以使用语法[= c =]指定等价类，
                     它匹配具有相同排序权重的所有字符（由...定义）
                     当前的语言环境）作为字符c。

                     在[和]中，语法[.symbol。]匹配整理符号符号。

       识别了几个扩展模式匹配运算符。在以下描述中，
       模式列表是由|分隔的一个或多个模式的列表。复合图案可以
       使用以下一个或多个子模式形成：

              ？（模式列表）
                     匹配给定模式的零次或一次出现
              *（模式列表）
                     匹配给定模式的零次或多次出现
              +（模式列表）
                     匹配给定模式的一次或多次出现
              @（模式列表）
                     匹配给定模式之一

       如果使用内置shopt启用了extglob shell选项，则遵循模式匹配
       运营商也被认可：

              ！（模式列表）
                     匹配除了给定模式之外的任何内容

   报价删除
       在前面的扩展之后，所有未加引号出现的字符为\，'和“
       没有导致上述扩展之一被删除。

REDIRECTION
       在执行命令之前，可以使用特殊的nota重定向其输入和输出
       由shell解释。重定向也可用于打开和关闭文件
       当前的shell执行环境。可以在以下重定向运算符之前
       或出现在简单命令中的任何位置或可能遵循命令。重定向是亲
       按从左到右的顺序排列。

       可以在每个重定向之前可以在文件描述符号之前
       用{varname}形式的单词。在这种情况下，对于每个重定向运算符，除了&&
       和< -   - ，shell将分配一个大于10的文件描述符并将其分配给var-
       名称。如果>＆ - 或<＆ - 前面有{varname}，则varname的值定义文件
       要关闭的描述符。

       在以下描述中，如果省略文件描述符号，则第一个
       重定向运算符的字符是<，重定向是指标准输入
       （文件描述符0）。如果重定向运算符的第一个字符是>，则重定向
       rection指标准输出（文件描述符1）。

       除非另有说明，否则在以下描述中的重定向运算符后面的单词
       注意到，需要进行支撑扩展，波浪扩展，参数扩展，命令子
       排除，算术扩展，引用删除，路径名扩展和单词拆分。如果
       它扩展到多个单词，bash报告错误。

       请注意，重定向的顺序非常重要。例如，命令

              ls> dirlist 2>＆1

       在命令时将标准输出和标准错误都指向文件dirlist

              ls 2>＆1> dirlist

       仅将标准输出指向文件dirlist，因为标准错误是重复的
       在标准输出重定向到dirlist之前从标准输出。

       如上所述，Bash在重定向时使用它们时会处理多个文件名
       在下表中：

              的/ dev / FD / FD
                     如果fd是有效整数，则重复文件描述符fd。
              的/ dev /标准输入
                     文件描述符0是重复的。
              的/ dev /标准输出
                     文件描述符1是重复的。
              的/ dev /标准错误
                     文件描述符2是重复的。
              的/ dev / TCP /主机/端口
                     如果host是有效的主机名或Internet地址，则port是整数端口
                     数字或服务名称，bash尝试打开与相关的TCP连接
                     支持套接字。
              的/ dev / UDP /主机/端口
                     如果host是有效的主机名或Internet地址，则port是整数端口
                     数字或服务名称，bash尝试打开与相关的UDP连接
                     支持套接字。

       无法打开或创建文件会导致重定向失败。

       使用大于9的文件描述符的重定向应尽可能小心使用
       与shell在内部使用的文件描述符冲突。

   重定向输入
       输入的重定向导致名称来自word扩展的文件
       打开读取文件描述符n，或标准输入（文件描述符0），如果n是
       未标明。

       重定向输入的一般格式是：

              [N] <字

   重定向输出
       输出的重定向导致其名称来自word扩展的文件
       打开用于写入文件描述符n，或标准输出（文件描述符1），如果n是
       未标明。如果文件不存在则创建;如果确实存在，则会被截断
       零尺寸。

       重定向输出的一般格式是：

              [N]>字

       如果重定向运算符是>，则set builtin的noclobber选项已经完成
       启用后，如果名称由扩展名称生成的文件，重定向将失败
       单词存在，是一个常规文件。如果重定向运算符是> |，或重定向
       operator is>并且未启用set builtin命令的noclobber选项，redi-
       即使以word命名的文件存在，也会尝试执行此操作。

   附加重定向输出
       以这种方式重定向输出会导致名称由扩展产生的文件
       要打开以附加到文件描述符n或标准输出（文件
       描述符1）如果未指定n。如果该文件不存在，则创建该文件。

       附加输出的一般格式是：

              [N] >>字

   重定向标准输出和标准错误
       此构造允许标准输出（文件描述符1）和标准错误
       输出（文件描述符2）重定向到名称为扩展名的文件
       字。

       重定向标准输出和标准错误有两种格式：

              ＆>字
       和
              >＆字

       在这两种形式中，第一种是优选的。这在语义上等同于

              >字2>＆1

   附加标准输出和标准错误
       此构造允许标准输出（文件描述符1）和标准错误
       输出（文件描述符2）将附加到名称为单词扩展的文件。

       附加标准输出和标准错误的格式为：

              ＆>>字

       这在语义上等同于

              >>字2>＆1

   这里的文件
       这种类型的重定向指示shell从当前源读取输入，直到a
       可以看到仅包含分隔符（没有尾随空格）的行。所有的线都读了
       然后将该点用作命令的标准输入。

       here-documents的格式是：

              << [ - ]字
                      这里文档
              分隔符

       没有参数扩展，命令替换，算术扩展或路径名扩展
       是在单词上执行的。如果引用单词中的任何字符，则分隔符是结果
       引用删除单词，并且不会展开here-document中的行。如果是的话
       不带引号，here-document的所有行都经过参数扩展，命令子
       结果和算术扩展。在后一种情况下，字符序列\ <newline>
       被忽略，\必须用于引用字符\，$和`。

       如果重定向运算符是<<  - ，则从输入中删除所有前导制表符
       行和包含分隔符的行。这允许shell脚本中的here-documents
       以自然的方式缩进。

   这里的弦乐
       这里文档的一个变体，格式是：

              <<<字

       该字被扩展并在其标准输入上提供给命令。

   复制文件描述符
       重定向运算符

              [N] <＆字

       用于复制输入文件描述符。如果word扩展为一个或多个数字，则
       由n表示的文件描述符被作为该文件描述符的副本。如果是数字
       在word中没有指定打开输入的文件描述符，发生重定向错误。如果
       word求值为 - ，文件描述符n关闭。如果未指定n，则为标准
       使用输入（文件描述符0）。

       运营商

              [N]>＆字

       类似地用于复制输出文件描述符。如果没有指定n，则stan-
       使用dard输出（文件描述符1）。如果单词中的数字未指定文件
       描述符打开输出，发生重定向错误。作为一个特例，如果n省略 - 
       ted，word不会扩展为一个或多个数字，标准输出和标准错误
       如前所述重定向。

   移动文件描述符
       重定向运算符

              [N] <＆digit-

       将文件描述符数字移动到文件描述符n或标准输入（文件描述 - 
       tor 0）如果未指定n。数字在复制到n后关闭。

       同样，重定向运算符

              [N]>＆digit-

       将文件描述符数字移动到文件描述符n，或标准输出（文件描述 - 
       tor 1）如果没有指定n。

   打开阅读和写作的文件描述符
       重定向运算符

              [N] <>字

       导致名称为word扩展的文件被打开以进行读取和写入
       如果未指定n，则在文件描述符n上或在文件描述符0上。如果文件有
       它不存在，它被创造出来。

ALIASES
       别名允许字符串在用作a的第一个单词时替换单词
       简单的命令。 shell维护一个别名列表，可以设置和取消设置
       别名和unalias内置命令（请参阅下面的SHELL BUILTIN命令）。第一个字
       如果不带引号，则检查每个简单命令以查看它是否具有别名。如果是这样，那个词
       由别名的文本替换。字符/，$，`，和=以及任何shell
       上面列出的元字符或引号可能不会出现在别名中。该
       替换文本可能包含任何有效的shell输入，包括shell元字符。该
       替换文本的第一个单词是针对别名测试的，但是与单词相同
       正在扩展的别名不会再次展开。这意味着可以将ls替换为ls
       例如，ls -F和bash不会尝试递归扩展替换文本。如果
       别名值的最后一个字符是空白，然后是下一个命令字
       还检查别名是否有别名扩展。

       使用alias命令创建和列出别名，并使用unalias com-删除
       普通话。

       在替换文本中没有使用参数的机制。如果参数是
       需要时，应使用shell函数（参见下面的功能）。

       当shell不是交互式时，别名不会扩展，除非expand_aliases shell
       使用shopt设置选项（参见SHELL BUILTIN COMMANDS下的shopt说明
       下面）。

       关于别名的定义和使用的规则有些令人困惑。总是打击
       在执行任何命令之前，读取至少一个完整的输入行
       线。读取命令时会扩展别名，而不会在执行时扩展别名。因此，一个
       与另一个命令出现在同一行的别名定义直到生效才会生效
       读取下一行输入。该行上别名定义后面的命令
       不受新别名的影响。当函数执行时，这种行为也是一个问题
       cuted。读取函数定义时会扩展别名，而不是函数定义时
       执行，因为函数定义本身就是一个复合命令。作为结果，
       在执行该函数之后，函数中定义的别名才可用。至
       安全，始终将别名定义放在单独的行上，并且不要在复合中使用别名
       命令。

       对于几乎所有目的，别名都被shell函数取代。

功能
       如上所述在SHELL GRAMMAR中定义的shell函数存储了一系列的
       为以后的执行提供支持。当shell函数的名称用作简单命令时
       name，执行与该函数名关联的命令列表。功能是
       在当前shell的上下文中执行;没有创建新的流程来解释它们
       （与shell脚本的执行形成对比）。执行函数时，
       函数的参数在执行期间成为位置参数。 spe-
       更新cial参数＃以反映更改。特殊参数0不变。该
       FUNCNAME变量的第一个元素设置为函数的名称，而函数
       正在执行。

       shell执行环境的所有其他方面在函数和函数之间是相同的
       它的调用者有以下例外：DEBUG和RETURN陷阱（参见说明书
       除非函数具有，否则不会继承在SHELL BUILTIN COMMANDS下面建立的陷阱
       被赋予trace属性（参见下面声明内置的描述）或-o
       functrace shell选项已使用set builtin启用（在这种情况下所有函数都已启用）
       继承DEBUG和RETURN陷阱），除非-o，否则不会继承ERR陷阱
       errtrace shell选项已启用。

       可以使用local builtin命令声明函数本地的变量。 Ordinar-
       ily，变量及其值在函数和调用者之间共享。

       FUNCNEST变量，如果设置为大于0的数值，则定义最大函数
       筑巢水平。超出限制的函数调用会导致整个命令
       中止。

       如果在函数中执行内置命令返回，则该函数完成并执行
       函数调用后，使用下一个命令恢复。任何与之相关的命令
       在执行恢复之前执行RETURN陷阱。当一个函数完成时，val-
       位置参数和特殊参数＃的ues将恢复为值
       他们在执行函数之前就已经有了。

       可以使用declare或typeset的-f选项列出函数名称和定义
       内置命令。声明或排版的-F选项仅列出函数名称
       （如果启用了extdebug shell选项，则可选择包含源文件和行号）。
       可以导出函数，以便子shell自动使用-f定义它们
       导出内置的选项。可以使用-f选项删除函数定义
       未设置的内置。请注意，可能会导致shell函数和具有相同名称的变量
       在传递给shell的子项的环境中的多个具有相同名称的条目中。
       如果这可能导致问题，应该小心。

       函数可以是递归的。 FUNCNEST变量可用于限制深度
       函数调用堆栈并限制函数调用的数量。默认情况下，没有限制
       强加于递归调用的数量。

算术评估
       在某些情况下，shell允许计算算术表达式（参见
       let和declare内置命令和算术扩展）。评估完成
       固定宽度的整数，没有检查溢出，虽然除以0并且被捕获
       标记为错误。运算符及其优先级，关联性和值是
       与C语言相同。以下运算符列表分为以下级别
       等优先运算符。级别按优先级递减的顺序列出。

       id ++ id--
              变量后增量和后减量
       ++ id --id
              变量预增量和预减量
        -  +一元减号和加号
       ！ 〜逻辑和按位否定
       **取幂
       * /％乘法，除法，余数
       +  - 加法，减法
       << >>左右按位移位
       <=> = <>
              对照
       ==！=平等和不平等
       ＆按位AND
       ^按位异或
       |按位OR
       &&逻辑AND
       ||逻辑或
       EXPR EXPR：EXPR
              条件运算符
       = * = / =％= + =  -  = << = >> =＆= ^ = | =
              分配
       expr1，expr2
              逗号

       允许Shell变量作为操作数;参数扩展在之前执行
       表达式被评估。在表达式中，shell变量也可以引用
       不使用参数扩展语法的名称。一个null变量或未设置的shell变量
       在不使用参数扩展语法的情况下按名称引用时计算结果为0。该
       变量的值在引用时或在何时被计算为算术表达式
       使用declare -i赋予整数属性的变量被赋值。
       null值的计算结果为0. shell变量不需要转换其整数属性
       在表达式中使用。

       前导0的常量被解释为八进制数。前导0x或0X表示
       十六进制。否则，数字采用[base＃] n的形式，其中可选的基数为deci
       表示算术基数的2到64之间的数字，n是其中的数字
       基础。如果省略base＃，则使用基数10。大于9的数字代表
       由小写字母，大写字母，@和_按顺序排列。如果基地
       小于或等于36，小写和大写字母可互换使用
       表示10到35之间的数字。

       按优先顺序评估运算符。括号中的子表达式是评估 - 
       首先，可以覆盖上面的优先规则。

有条件的表达
       条件表达式由[[复合命令和测试和[builtin com-]使用
       mands测试文件属性并执行字符串和算术比较。表达式
       由以下一元或二元原色组成。如果有任何文件参数
       初选的格式为/ dev / fd / n，然后检查文件描述符n。如果是文件
       其中一个原色的参数是/ dev / stdin，/ dev / stdout或/ dev / stderr，file之一
       分别检查描述符0,1或2。

       除非另有规定，对文件进行操作的原色遵循符号链接和操作
       吃了链接的目标，而不是链接本身。

       与[[，<和>运算符一起使用时，使用当前语言环境按字典顺序排序。
       测试命令使用ASCII排序进行排序。

       -一份文件
              如果文件存在则为真。
       -b文件
              如果文件存在则为真，并且是块特殊文件。
       -c文件
              如果文件存在则为真，并且是字符特殊文件。
       -d文件
              如果文件存在且为目录，则为True。
       -e文件
              如果文件存在则为真。
       -f文件
              如果文件存在且为常规文件，则为True。
       -g文件
              如果文件存在且为set-group-id，则为True。
       -h文件
              如果文件存在且为符号链接，则为True。
       -k文件
              如果文件存在且设置了“粘性”位，则为真。
       -p文件
              如果文件存在则为真，并且是命名管道（FIFO）。
       -r文件
              如果文件存在且可读，则为True。
       -s文件
              如果文件存在且大小大于零，则为True。
       -t fd如果文件描述符fd打开并引用终端，则为真。
       -u文件
              如果文件存在且其set-user-id位已设置，则为True。
       -w文件
              如果文件存在且可写，则为True。
       -x文件
              如果文件存在且可执行，则为True。
       -G文件
              如果文件存在并且由有效组ID拥有，则为True。
       -L文件
              如果文件存在且为符号链接，则为True。
       -N档案
              如果文件存在且自上次读取以来已被修改，则为真。
       -O文件
              如果文件存在并且由有效用户标识拥有，则为True。
       -S文件
              如果文件存在且为套接字，则为True。
       file1 -ef file2
              如果file1是真的
d file2指的是相同的设备和inode编号。
       file1 -nt file2
              如果file1比file2更新（根据修改日期），或者如果file1更新，则为True
              存在而file2没有。
       file1 -ot file2
              如果file1早于file2，或者file2存在且file1不存在，则为True。
       -o optname
              如果启用了shell选项optname，则为True。请参阅下面的选项列表
              下面的set builtin的-o选项的描述。
       -v varname
              如果设置了shell变量varname，则为True（已分配值）。
       -z字符串
              如果字符串的长度为零，则为True。
       串
       -n string
              如果字符串的长度不为零，则为True。

       string1 == string2
       string1 = string2
              如果字符串相等则为True。 =应该与POSIX的测试命令一起使用
              一致性。

       string1！= string2
              如果字符串不相等则为True。

       string1 <string2
              如果string1按字典顺序在string2之前排序，则为True。

       string1> string2
              如果string1按字典顺序在string2之后排序，则为True。

       arg1 OP arg2
              OP是-eq，-ne，-lt，-le，-gt或-ge之一。这些算术二元运算符
              如果arg1等于，不等于，小于，小于或等于，则返回true，
              分别大于，或大于或等于arg2。 Arg1和arg2可能是
              正整数或负整数。

简单的命令扩展
       当执行一个简单的命令时，shell执行以下扩展，分配 - 
       从左到右的重叠和重定向。

       1.解析器标记为变量赋值的单词（前面的那些）
              命令名称）和重定向被保存以供以后处理。

       2.扩展不是变量赋值或重定向的单词。如果有的话
              扩展后的单词仍然存在，第一个单词被视为命令的名称
              其余的词是争论。

       3.重定向按照上述REDIRECTION中的描述进行。

       4.每个变量赋值中=后的文本经历波浪扩展，参数 - 
              以前的扩展，命令替换，算术扩展和引用删除
              被分配给变量。

       如果未生成命令名称，则变量赋值会影响当前的shell环境。
       否则，变量将添加到已执行命令的环境中，而不是
       影响当前的shell环境。如果任何分配尝试分配值
       对于只读变量，发生错误，并且命令以非零状态退出。

       如果没有命令名称结果，则执行重定向，但不影响当前shell
       环境。重定向错误导致命令以非零状态退出。

       如果在扩展后留下命令名称，则执行如下所述。
       否则，该命令退出。如果其中一个扩展包含命令替换，
       命令的退出状态是最后一个命令替换的退出状态
       形成。如果没有命令替换，则命令以状态为零退出。

命令执行
       将命令拆分为单词后，如果它导致一个简单的命令和一个
       可选的参数列表，采取以下操作。

       如果命令名称不包含斜杠，则shell会尝试找到它。如果存在
       通过该名称的shell函数，该函数如上面在FUNCTIONS中所述被调用。
       如果名称与函数不匹配，shell将在shell列表中搜索它
       内建命令。如果找到匹配项，则调用该内置项。

       如果名称既不是shell函数也不是内置函数，并且不包含斜杠，bash
       搜索PATH的每个元素以查找包含可执行文件的目录
       名称。 Bash使用哈希表来记住可执行文件的完整路径名（请参阅哈希
       在SHELL BUILTIN COMMANDS下面）。执行PATH中目录的完整搜索
       仅当在哈希表中找不到该命令时。如果搜索不成功，则
       shell搜索名为command_not_found_handle的已定义shell函数。如果那个功能 - 
       如果存在，则使用原始命令和原始命令的参数调用它
       作为参数，函数的退出状态成为shell的退出状态。如果
       如果没有定义该函数，shell会输出错误消息并返回退出状态
       127。

       如果搜索成功，或者命令名称包含一个或多个斜杠，则为shell
       在单独的执行环境中执行指定的程序。参数0设置为
       给定名称，并将命令的其余参数设置为给定的参数if
       任何。

       如果此执行失败，因为该文件不是可执行格式，并且该文件不是
       目录，它被假定为一个shell脚本，一个包含shell命令的文件。一个子
       生成shell以执行它。这个子shell重新初始化，因此效果是
       就好像调用了一个新shell来处理脚本一样，除了loca
       父母记住的命令数量（请参阅SHELL BUILTIN命令下的哈希）
       由孩子保留。

       如果程序是以＃！开头的文件，则第一行的其余部分指定一个
       该计划的口译员。 shell在运行时执行指定的解释器
       不自行处理此可执行格式的系统。相互之间的争论
       preter由第一个解释器名称后面的单个可选参数组成
       程序的行，然后是程序的名称，然后命令参数 - 
       如果有的话。

命令执行环境
       shell有一个执行环境，它包含以下内容：

       ·在调用时由shell继承的打开文件，由重定向支持修改
              与内建执行官合作

       ·当前工作目录由cd，pushd或popd设置，或由。继承
              shell调用

       ·文件创建模式掩码，由umask设置或从shell的父级继承

       ·陷阱设置的当前陷阱

       ·由变量赋值或set或者继承的shell参数
              shell的父级环境

       ·shell函数在执行期间定义或从shell的父元素继承
              环境

       ·调用时启用的选项（默认情况下或使用命令行参数）或
              按集

       ·由shopt启用的选项

       ·使用别名定义的shell别名

       ·各种进程ID，包括后台作业，$$的值和
              PPID的值

       当要执行除内置函数或shell函数之外的简单命令时，它就是
       在包含以下内容的单独执行环境中调用。除非其他 - 
       明智地指出，这些值是从shell继承而来的。


       ·shell的打开文件，以及redirec指定的任何修改和添加 - 
              这个命令

       ·当前的工作目录

       ·文件创建模式掩码

       ·标记为导出的shell变量和函数，以及为其导出的变量
              命令，在环境中传递

       ·shell捕获的陷阱被重置为从shell的父级继承的值，
              并忽略shell忽略的陷阱

       在这个单独的环境中调用的命令不会影响shell的执行环境
       换货。

       命令替换，用括号分组的命令和异步命令是
       在子shell环境中调用，该环境是shell环境的副本，但不包括
       shell捕获的陷阱将重置为shell从其父级继承的值
       在调用。还会执行作为管道的一部分调用的内置命令
       在子shell环境中。对子shell环境所做的更改不会影响
       shell的执行环境。

       产生执行命令替换的子shell继承了-e选项的值
       父shell。当不处于posix模式时，bash会清除这些子shell中的-e选项。

       如果命令后跟＆且作业控件未激活，则为默认标准输入
       该命令是空文件/ dev / null。否则，调用的命令继承
       由重定向修改的调用shell的文件描述符。

环境
       调用程序时，会给出一个称为环境的字符串数组。这是
       名称 - 值对的列表，格式为name = value。

       shell提供了几种操作环境的方法。在调用时，shell
       扫描自己的环境并为找到的每个名称创建一个参数，自动标记 - 
       将其导出到子进程。执行的命令继承环境。该
       export和declare -x命令允许添加和删除参数和函数
       来自环境。如果修改了环境中参数的值，则为新的
       价值成为环境的一部分，取代旧的。任何环境继承的环境
       执行命令由shell的初始环境组成，其值可以修改
       在shell中，少了unset命令删除的任何对，加上通过的任何添加
       export和declare -x命令。

       任何简单命令或功能的环境可以通过前缀临时增加 - 
       使用参数分配，如上面参数中所述。这些任务
       语句仅影响该命令所看到的环境。

       如果设置了-k选项（请参阅下面的set builtin命令），那么所有参数分配
       放置在命令的环境中，而不仅仅是命令名称之前的命令。

       当bash调用外部命令时，变量_被设置为的完整文件名
       命令并在其环境中传递给该命令。

退出状态
       执行命令的退出状态是waitpid系统调用或返回的值
       等效功能。然而，退出状态介于0到255之间，如下所述
       shell可能会特别使用125以上的值。从shell builtins和compound中退出状态
       命令也限于此范围。在某些情况下，shell会使用
       表示特定故障模式的特殊值。

       出于shell的目的，以零退出状态退出的命令已成功。一个
       退出状态为零表示成功。非零退出状态表示失败。当一个
       命令终止于致命信号N，bash使用128 + N的值作为退出状态。

       如果未找到命令，则为执行该命令而创建的子进程将返回状态127。
       如果找到命令但不可执行，则返回状态为126。

       如果命令因扩展或重定向期间的错误而失败，则退出状态为
       大于零。

       如果成功，Shell builtin命令返回状态0（true），如果成功则返回非零（false）状态
       执行时发生错误。所有内置函数都返回退出状态2以表示
       用法不正确。

       除非出现语法错误，否则Bash本身会返回最后执行的命令的退出状态
       发生，在这种情况下，它以非零值退出。另请参见exit builtin命令
       下面。

SIGNALS
       当bash是交互式的时候，在没有任何陷阱的情况下，它会忽略SIGTERM（因此kill 0
       不会杀死交互式shell），并且会捕获并处理SIGINT（以便等待
       内置是可中断的）。在所有情况下，bash都会忽略SIGQUIT。如果工作控制在
       效果，bash忽略SIGTTIN，SIGTTOU和SIGTSTP。

       由bash运行的非内置命令将信号处理程序设置为由。继承的值
       来自其父级的shell。当作业控制无效时，异步命令会忽略
       除了这些继承的处理程序之外，还有SIGINT和SIGQUIT。命令运行的结果
       命令替换忽略键盘生成的作业控制信号SIGTTIN，SIGTTOU，
       和SIGTSTP。

       收到SIGHUP后，shell默认退出。在退出之前，交互式shell
       将SIGHUP重新发送到所有正在运行或已停止的作业。已停止的作业将被发送到SIGCONT
       确保他们收到SIGHUP。防止shell将信号发送到
       特别的工作，应该使用disown builtin从jobs表中删除它（参见SHELL
       下面的BUILTIN命令）或标记为不使用disown -h接收SIGHUP。

       如果使用shopt设置了huponexit shell选项，则bash会在所有作业发送一个SIGHUP
       一个交互式登录shell退出。

       如果bash正在等待命令完成并收到陷阱所具有的信号
       如果已设置，则在命令完成之前不会执行陷阱。当bash在等待
       对于通过等待内置的异步命令，接收一个信号a
       已设置陷阱将导致等待内置立即返回退出状态
       大于128，紧接着执行陷阱。

工作控制
       作业控制是指有选择地停止（暂停）进程执行的能力
       并在以后继续（恢复）他们的执行。用户通常使用它
       通过操作系统内核联合提供的交互式界面来实现设施
       终端司机和bash。

       shell将作业与每个管道相关联。它保留了当前正在执行的表
       可以使用jobs命令列出的作业。当bash异步启动一个作业时（在
       背景），它打印一行看起来像：

              [1] 25647

       表示此作业是作业编号1，表示该作业中的最后一个进程的进程ID
       与此作业关联的管道是25647.单个管道中的所有进程都是
       同一份工作的成员。 Bash使用作业抽象作为工作控制的基础。

       为了便于实现作业控制的用户界面，操作系统
       维护当前终端进程组ID的概念。此流程组的成员
       （进程组ID等于当前终端进程组ID的进程）
       接收键盘生成的信号，如SIGINT。这些过程据说是在
       前景。后台进程是那些进程组ID与termi不同的进程
       最终的;这些过程不受键盘生成的信号的影响。只有前台进程
       允许读取或者如果用户如此指定stty tostop，则写入termi-
       最终。尝试读取的后台进程（写入stty tostop时的进程
       效果）终端由内核的终端驱动程序发送SIGTTIN（SIGTTOU）信号，
       除非被捕，否则暂停该过程。

       如果运行bash的操作系统支持作业控制，则bash包含facil-
       使用它。在进程的时候键入暂停字符（通常是^ Z，Control-Z）
       运行导致该进程停止并将控制权返回给bash。输入延迟
       暂停字符（通常是^ Y，Control-Y）会导致进程停止
       尝试从终端读取输入，并控制返回bash。用户可以
       然后操纵这个工作的状态，使用bg命令在后面继续它 - 
       地面，fg命令在前台继续它，或者kill命令来杀死它。一个
       ^ Z立即生效，并具有导致待定输出的附加副作用
       并输入要删除的内容。

       有很多方法可以引用shell中的作业。角色％介绍了一个
       工作规范（jobspec）。作业号n可以称为％n。工作也可能是
       引用使用用于启动它的名称的前缀，或使用出现的子字符串
       在其命令行中。例如，％ce指的是停止的作业。如果前缀匹配
       不止一个工作，bash报告错误。另一方面，使用％？ce指的是任何工作
       在命令行中包含字符串ce。如果子字符串匹配多个作业，
       bash报告错误。符号%%和％+是指shell的当前概念
       工作，这是最后一份工作，当它在前台或在后面开始时停止 - 
       地面。可以使用％ - 引用上一个作业。如果只有一个作业，％+
       和％ - 都可以用来指代那份工作。在与工作有关的输出中（例如，
       put of the jobs命令），当前作业总是标有+和前一个作业
       用 - 。单个％（没有伴随作业规范）也指当前
       工作。

       简单地命名一个作业可以用来将它带到前台：％1是``fg的同义词
       ％1''，将作业1从后台带入前景。同样，``％1＆''恢复
       作业1在后台，相当于“bg％1”。

       当作业改变状态时，shell立即学习。通常，bash会等到它
       在报告作业状态的变化之前打印一个提示，以便不相互关联
       破坏任何其他输出。如果启用了set builtin命令的-b选项，则使用bash
       立即报告此类更改。 SIGCHLD上的任何陷阱都是针对每个孩子执行的
       退出。

       如果在作业停止时（或者，如果checkjobs shell）尝试退出bash
       选项已经使用内置的shopt运行，运行），shell打印一个警告信息
       sage，如果启用了checkjobs选项，则列出作业及其状态。工作
       然后可以使用命令检查其状态。如果第二次尝试退出
       没有干预命令，shell不会打印另一个警告，并且任何停止
       工作被终止。

PROMPTING
       交互式执行时，bash在准备好读取时显示主提示符PS1
       当需要更多输入来完成命令时，命令和辅助提示PS2。
       Bash允许通过插入一些反斜杠来自定义这些提示字符串 - 
       转义特殊字符，解码如下：
              \ a一个ASCII铃铛字符（07）
              \ d“工作日月日期”格式的日期（例如“5月26日星期二”）
              \ d {格式}
                     格式传递给strftime（3）并将结果插入到
                     提示字符串;空格式导致特定于语言环境的时间表示
                     灰。大括号是必需的
              \ e ASCII转义字符（033）
              \ h主机名最多为第一个`。'
              \ H主机名
              \ j目前由shell管理的作业数量
              \ l shell的终端设备名称的基本名称
              \ n换行
              \ r \ n回车
              \ ss shell的名称，$ 0的基本名称（最终版本后面的部分）
                     削减）
              \ t当前时间为24小时HH：MM：SS格式
              \ T当前时间为12小时HH：MM：SS格式
              \ @当前时间为12小时上午/下午格式
              \当前时间为24小时HH：MM格式
              \ u当前用户的用户名
              \ v bash的版本（例如，2.00）
              \ v发布bash，版本+补丁级别（例如2.00.0）
              \ w当前工作目录，$ HOME缩写为波浪号（使用
                     PROMPT_DIRTRIM变量的值）
              \ W当前工作目录的基本名称，$ HOME缩写为a
                     波浪号
              \！此命令的历史编号
              \＃此命令的命令编号
              \ $如果有效UID为0，则为＃，否则为$
              \ nnn对应八进制数nnn的字符
              反斜杠
              \ [开始一系列非打印字符，可用于嵌入
                     终端控制序列进入提示
              \]结束一系列非打印字符

       命令编号和历史编号通常不同：a的历史编号
       command是它在历史列表中的位置，可能包括从中恢复的命令
       历史文件（参见下面的HISTORY），而命令编号是序列中的位置
       在当前shell会话期间执行的命令。字符串解码后，它是
       通过参数扩展，命令替换，算术扩展和引用进行扩展
       删除，取决于promptvars shell选项的值（请参阅的说明
       在SHELL BUILTIN COMMANDS下面的shopt命令）。

READLINE
       这是在使用交互式shell时处理读取输入的库，除非
        - 在shell调用时给出了nonoiting选项。使用时也使用行编辑
       读取内置的-e选项。默认情况下，行编辑命令与这些命令类似
       Emacs。还提供vi风格的线编辑界面。行编辑即可
       使用-o emacs或-o vi选项随时启用set builtin（请参阅SHELL
       下面的建筑命令）。要在shell运行后关闭行编辑，请使用+ o
       设置内置的emacs或+ o vi选项。

   Readline表示法
       在本节中，Emacs样式表示法用于表示击键。控制键是
       用C键表示，例如，C-n表示Control-N。类似地，元键由M键表示，因此
       M-x表示Meta-X。 （在没有元键的键盘上，M-x表示ESC x，即按下
       退出键然后是x键。这使得ESC成为元前缀。 M-C-x的组合意味着
       ESC-Control-x，或按Esc键，然后在按住x键的同时按住Control键。）

       Readline命令可以给出数字参数，通常用作重复计数。
       然而，有时，这是论证的重要标志。通过否定
       在向前方向上作用的命令的参数（例如，kill-line）导致该com-
       要求向后行动。带有参数的行为偏离的命令
       这在下面说明。

       当命令被描述为杀死文本时，将删除已删除的文本以备将来使用
       检索（yanking）。被杀死的文本保存在杀戮戒指中。连续的杀戮导致了
       文本要累积到一个单元中，可以一次全部拉出。做的命令
       不要杀死文本分开杀戮戒指上的文本块。

   读取线初始化
       通过将命令放入初始化文件（inputrc文件）来自定义Readline。
       此文件的名称取自INPUTRC变量的值。如果那个变量是
       未设置，默认为〜/ .inputrc。当使用readline库的程序启动时
       up，读取初始化文件，并设置键绑定和变量。有
       readline初始化文件中只允许一些基本结构。空行是
       忽略。以＃开头的行是注释。以$开头的行表示条件
       国家结构。其他行表示键绑定和变量设置。

       可以使用inputrc文件更改默认键绑定。其他使用它的程序
       库可以添加自己的命令和绑定。

       例如，放置

              M-Control-u：普遍参数
       要么
              C-Meta-u：普遍论证
       进入inputrc将使M-C-u执行readline命令universal-argument。

       识别以下符号字符名称：RUBOUT，DEL，ESC，LFD，NEWLINE，RET，
       RETURN，SPC，SPACE和TAB。

       除了命令名称之外，readline还允许将键绑定到插入的字符串
       按下键时（宏）。

   Readline键绑定
       用于控制inputrc文件中的键绑定的语法很简单。一切都是
       required是命令的名称或宏的文本以及宏的键序列
       应该受到约束。可以用以下两种方式之一指定名称：作为符号键名，pos-
       使用Meta-或Control-前缀，或作为关键序列。

       使用表单keyname：function-name或macro时，keyname是拼写的键的名称
       用英语说。例如：

              Control-u：通用参数
              Meta-Rubout：反向杀戮词
              Control-o：“>输出”

       在上面的例子中，C-u绑定到函数universal-argument，M-DEL绑定到
       函数backward-kill-word，和C-o绑定运行右边表示的宏
       手边（即将文本“输出”插入到行中）。

       在第二种形式，“keyseq”：function-name或macro，keyseq与上面的keyname不同
       表示整个键序列的字符串可以通过放置序列来指定
       在双引号内。可以使用一些GNU Emacs样式键转义，如下所示
       例如，但无法识别符号字符名称。

              “\ C-u”：普遍论证
              “\ C-x \ C-r”：重新读取-init-file
              “\ e [11~”：“功能键1”

       在此示例中，C-u再次绑定到函数universal-argument。 C-x C-r受约束
       到函数re-read-init-file，ESC [1 1~必然会插入文本``Function
       关键1''。

       完整的GNU Emacs样式转义序列是
              \ C-控制前缀
              \ M-元前缀
              \ e逃脱角色
              \\反斜杠
              \“文字”
              \'文字'

       除了GNU Emacs样式转义序列之外，还有第二组反斜杠转义符
       可供选择：
              警报（铃）
              \ b退格
              \ d删除
              \ f表格饲料
              \ n换行
              \ r \ n回车
              \ t水平标签
              \ v垂直标签
              \ nnnn八位字符，其值为八进制值nnn（一到三个数字 - 
                     它的）
              \ xHH八位字符，其值为十六进制值HH（一个或两个
                     十六进制数字

       输入宏的文本时，必须使用单引号或双引号来表示宏
       定义。假设未加引号的文本是函数名称。在宏体中，背面 - 
       上面描述的斜线逃逸被扩展。反斜杠将引用任何其他字符
       宏文本，包括“和”。

       Bash允许使用bind显示或修改当前的readline键绑定
       内置命令。可以在交互式使用期间通过使用-o来切换编辑模式
       set builtin命令的选项（参见下面的SHELL BUILTIN命令）。

   Readline变量
       Readline具有可用于进一步定制其行为的变量。变量可以
       在inputrc文件中设置一个表单的声明

              设置变量名称值

       除非另有说明，否则readline变量可以取值On或Off（不考虑
       案件）。无法识别的变量名称将被忽略。读取变量值时，为空或
       空值，“on”（不区分大小写），“1”等效于On。所有其他值都是
       相当于Off。变量及其默认值为：

       钟式（可听）
              控制当readline想要敲响终端铃时会发生什么。如果设置为
              没有，readline永远不会响铃。如果设置为visible，则readline使用可见
              如果有可用铃。如果设置为可听，则readline尝试响铃
              纳尔的钟声。
       bind-tty-special-chars（On）
              如果设置为On，则readline尝试绑定由特殊处理的控制字符
              内核的终端驱动程序与其readline等价物。
       comment-begin（``＃''）
              执行readline insert-comment命令时插入的字符串。
              此命令绑定到emacs模式下的M-＃和vi命令模式下的＃。
       完成 - 忽略 - 案例（关闭）
              如果设置为On，则readline在不区分大小写的情况下执行文件名匹配和完成
              时尚。
       completion-prefix-display-length（0）
              长度
在可能的完成列表的公共前缀的字符中
              显示无需修改。设置为大于零的值时，常见
              显示可能时，长度超过此值的前缀将替换为省略号
              完成完成。
       completion-query-items（100）
              这确定了何时查询用户查看可能的com-的数量
              由possible-completions命令生成的pletion。它可以设置为任何inte-
              ger值大于或等于零。如果可能的完成次数是
              如果大于或等于此变量的值，则询问用户是否
              不是他希望看到他们;否则他们只是在终端上列出。
       convert-meta（On）
              如果设置为On，readline将转换第8位设置为ASCII的字符
              通过剥离第八位并为转义字符添加前缀的键序列（in
              效果，使用转义作为元前缀）。
       禁用完成（关闭）
              如果设置为On，则readline将禁止字完成。完成字符将是
              插入到行中，好像它们已映射到自插入一样。
       编辑模式（emacs）
              控制readline是否以一组类似于Emacs或vi的键绑定开头。
              编辑模式可以设置为emacs或vi。
       echo-control-characters（开）
              当设置为On时，在表明它们支持它的操作系统上，readline回显
              与从键盘产生的信号对应的字符。
       启用键盘（关闭）
              设置为On时，readline将尝试启用应用程序键盘
              调用。某些系统需要此功能才能启用箭头键。
       enable-meta-key（On）
              设置为On时，readline将尝试启用终端的任何元修饰键
              声称在呼叫时提供支持。在许多终端上，元密钥用于
              发送八位字符。
       expand-tilde（关闭）
              如果设置为On，则当readline尝试单词完成时执行波形扩展。
       历史保留点（关闭）
              如果设置为“开”，则历史记录代码会尝试将点放在每个位置的相同位置
              使用上一个历史或下一个历史记录检索的历史记录行。
       历史大小（0）
              设置历史列表中保存的最大历史条目数。如果设置为
              零，历史列表中的条目数不受限制。
       水平滚动模式（关闭）
              设置为On时，使readline使用单行显示，滚动输入
              当它变得比屏幕宽度长时，在单个屏幕线上水平放置
              而不是包装到新的行。
       input-meta（Off）
              如果设置为On，readline将启用8位输入（也就是说，它不会剥离
              无论终端声称它是什么，它所读取的字符都是高位
              可以支持。名称meta-flag是此变量的同义词。
       isearch-terminators（``C- [C-J''）
              应该终止增量搜索而没有子句的字符串
              将角色作为命令执行。如果没有给出这个变量a
              值，字符ESC和C-J将终止增量搜索。
       keymap（emacs）
              设置当前的readline键映射。有效的键映射名称集是emacs，
              emacs-standard，emacs-meta，emacs-ctlx，vi，vi-command和vi-insert。 vi等同于
              对vi-command; emacs相当于emacs-standard。默认值为
              emacs的;编辑模式的值也会影响默认的键盘映射。
       标记目录（开）
              如果设置为On，则已完成的目录名称会附加斜杠。
       mark-modified-lines（Off）
              如果设置为“开”，则会使用前面的内容显示已修改的历史记录行
              星号（*）。
       mark-symlinked-directories（Off）
              如果设置为On，则作为目录的符号链接的已完成名称具有斜杠
              附加（取决于mark-directories的值）。
       match-hidden-files（On）
              此变量设置为On时，会使readline与名称以的文件匹配
              一个'。'执行文件名完成时（隐藏文件）。如果设置为关闭，则
              '。'必须由用户提供要完成的文件名。
       menu-complete-display-prefix（关闭）
              如果设置为“开”，则菜单完成将显示可能列表的公共前缀
              在循环列表之前完成（可能是空的）。
       output-meta（关闭）
              如果设置为On，readline将显示直接设置第8位的字符
              而不是作为元前缀的转义序列。
       页面完成（开）
              如果设置为On，则readline使用内部更类似的寻呼机来显示屏幕
              一次可能的完成。
       水平打印完成（关闭）
              如果设置为On，则readline将显示水平排序的匹配的完成
              字母顺序，而不是在屏幕上。
       revert-all-at-newline（关闭）
              如果设置为On，则readline将在返回之前撤消对历史记录行的所有更改
              接受行已执行。默认情况下，历史记录行可能会被修改并保留
              对readline调用的vidual撤消列表。
       show-all-if-ambiguous（Off）
              这会改变完成函数的默认行为。如果设置为On，则为单词
              有多个可能的完成导致匹配被立即列出
              但是没有响铃。
       show-all-if-unmodified（Off）
              这以类似于的方式改变完成函数的默认行为
              显示-ALL-如果歧义。如果设置为On，则具有多个可能的单词的单词
              没有任何可能的部分完成的情况（可能的完成没有
              共享一个公共前缀）导致匹配立即列出而不是响铃
              钟声。
       跳过完成文本（关闭）
              如果设置为On，则在插入单个时会改变默认的完成行为
              匹配到线。它只在中间执行完成时才有效
              字。如果启用，则readline不会在完成时插入字符
              在完成的单词中的点之后匹配字符，因此单词的部分
              跟随游标不重复。
       visible-stats（关闭）
              如果设置为On，则附加表示stat（2）报告的文件类型的字符
              列出可能的完成时的文件名。

   Readline条件构造
       Readline实现了与条件编译功能类似的功能
       C预处理器，允许执行键绑定和变量设置
       测试结果。使用了四种解析器指令。

       $ if $ if结构允许根据编辑模式终端进行绑定
              正在使用，或使用readline的应用程序。测试的文本延伸到了
              队伍的尽头;隔离它不需要任何字符。

              mode $ if指令的mode =形式用于测试readline是否在
                     emacs或vi模式。这可以与set keymap com-一起使用
                     例如，要在emacs-standard和emacs-ctlx中设置绑定
                     键盘映射仅在readline以emacs模式开始时才显示。

              术语术语=表单可能用于包括特定于终端的键绑定
                     绑定终端功能键输出的键序列。这个单词
                     在=的右侧对着termi-的全名进行测试
                     nal和终端名称在第一个之前的部分 - 。这允许太阳
                     例如，匹配sun和sun-cmd。

              应用
                     应用程序构造用于包括特定于应用程序的设置。
                     每个使用readline库的程序都会设置应用程序名称，以及
                     初始化文件可以测试特定值。这可以用来
                     将键序列绑定到对特定程序有用的函数。例如，
                     以下命令添加引用当前或上一个的键序列
                     bash中的单词：

                     $如果Bash
                     ＃引用当前或上一个单词
                     “\ C-xq”：“\ eb \”\ ef \“”
                     $ ENDIF

       $ endif此命令，如上例所示，终止$ if命令。

       $ else如果测试失败，则执行$ if指令的此分支中的命令。

       $包括
              该指令将一个文件名作为参数，并读取命令和绑定 - 
              来自该文件。例如，以下指令将读取/ etc / inputrc：

              $ include / etc / inputrc

   搜索
       Readline提供了搜索命令历史记录的命令（参见下面的HISTORY）
       对于包含指定字符串的行。有两种搜索模式：增量和非增量
       增加的。

       在用户键入搜索字符串之前开始增量搜索。每个
       输入搜索字符串的字符，readline显示历史记录中的下一个条目
       匹配到目前为止键入的字符串。增量搜索只需要很多字符
       根据需要找到所需的历史记录条目。字符中存在的字符值
       isearch-terminators变量用于终止增量搜索。如果那个变量
       没有赋值Escape和Control-J字符将终止增量 - 
       心理搜索。 Control-G将中止增量搜索并恢复原始行。
       搜索终止时，包含搜索字符串的历史记录条目将成为
       当前行。

       要在历史记录列表中查找其他匹配条目，请键入Control-S或Control-R作为
       需用合适。这将在历史记录中向后或向前搜索以进行下一个条目匹配
       到目前为止输入的搜索字符串。绑定到readline命令的任何其他键序列都将
       终止搜索并执行该命令。例如，换行符将终止
       搜索并接受该行，从而从历史列表中执行该命令。

       Readline会记住最后一个增量搜索字符串。如果没有输入两个Control-R
       定义新搜索字符串的任何插入字符，任何记住的搜索字符串
       用过的。

       非增量搜索在开始搜索匹配之前读取整个搜索字符串
       历史路线。搜索字符串可以由用户键入或者是内容的一部分
       当前行。

   Readline命令名称
       以下是命令名称和默认键序列的列表
       他们受约束。默认情况下，没有附带键序列的命令名称是未绑定的。
       在以下描述中，point指的是当前光标位置，而mark指的是
       到set-mark命令保存的光标位置。点和标记之间的文本是
       被称为该地区。

   移动命令
       行首（C-a）
              移动到当前行的开头。
       行尾（C-e）
              移到行尾。
       forward-char（C-f）
              向前移动一个角色。
       反向字符（C-b）
              移回一个角色。
       前向词（M-f）
              前进到下一个单词的结尾。单词由字母数字字符组成
              acters（字母和数字）。
       后向词（M-b）
              移回当前或上一个单词的开头。单词由组成
              字母数字字符（字母和数字）。
       壳正向词
              前进到下一个单词的结尾。单词由非引用shell分隔
              元字符。
       壳反向词
              移回当前或上一个单词的开头。单词由非分隔
              引用shell元字符。
       透明屏幕（C-l）
              清除屏幕，将当前行保留在屏幕顶部。辩论 - 
              ，刷新当前行而不清除屏幕。
       重绘电流线
              刷新当前行。

   操纵历史的命令
       接受（换行，返回）
              无论光标在哪里，都接受该行。如果此行非空，请添加
              它根据HISTCONTROL变量的状态到历史列表中。如果
              line是已修改的历史记录行，然后将历史记录行还原为其原始行
              州。
       前历史（C-p）
              从历史列表中获取上一个命令，然后在列表中返回。
       次历史（C-n）
              从历史列表中获取下一个命令，在列表中向前移动。
       历史起点（M- <）
              移至历史记录的第一行。
       历史结束（M->）
              移动到输入历史记录的末尾，即当前输入的行。
       反向搜索历史（C-r）
              从当前行开始向后搜索，并在历史记录中“向上”移动
              必要。这是一种增量搜索。
       前向搜索历史（C-s）
              从当前行开始向前搜索并在历史记录中“向下”移动
              必要。这是一种增量搜索。
       非增量反向搜索历史（M-p）
              使用非增量值向后搜索从当前行开始的历史记录
              mental search搜索用户提供的字符串。
       非增量前向搜索历史（M-n）
              使用非增量搜索字符串来搜索历史记录
              由用户提供。
       历史搜索前进
              通过历史记录搜索开头之间的字符串
              当前的路线和要点。这是一种非增量搜索。
       历史搜索落后
              在历史记录中向后搜索开始之间的字符串
              当前的线和点。这是一种非增量搜索。
       yank-nth-arg（M-C-y）
              将第一个参数插入上一个命令（通常是第二个单词
              前一行）。使用参数n，插入前一个第n个单词
              命令（上一个命令中的单词以单词0开头）。一个消极的论点
              插入上一个命令末尾的第n个单词。一旦参数n为
              在计算中，提取的参数就好像“！n”历史扩展已被指定
              田间。
       yank-last-arg（M-。，M-_）
              将最后一个参数插入上一个命令（前一个命令的最后一个字 - 
              保守党入境）。使用数字参数，其行为与yank-nth-arg完全相同。连续
              调用yank-last-arg后退回历史列表，插入最后一个单词
              （依次为第一次调用的参数指定的单词）依次为每一行。任何
              提供给这些连续调用的数字参数决定了移动的方向
              通过历史。负参数会切换历史记录中的方向
              （后退或前锋）历史扩展设施用于提取最后一个
              参数，好像已经指定了“！$”历史扩展。
       壳扩展线（M-C-e）
              像shell一样扩展行。这将执行别名和历史记录扩展
              以及所有shell字扩展。请参阅下面的历史扩展a
              历史扩张的描述。
       历史扩展线（M- ^）
              在当前行上执行历史记录扩展。请参阅下面的历史扩展a
              历史扩张的描述。
       魔术空间
              在当前行上执行历史记录扩展并插入空格。见历史
              以下扩展用于描述历史扩展。
       别名扩展线
              在当前行上执行别名扩展。有关说明，请参见上面的ALIASES
              别名扩展。
       历史和别名扩展线
              在当前行上执行历史记录和别名扩展。
       insert-last-argument（M-。，M-_）
              yank-last-arg的同义词。
       操作并获取下一个（C-o）
              接受当前行执行并获取相对于当前行的下一行
              从历史租用线进行编辑。任何参数都会被忽略。
       编辑执行命令（C-xC-e）
              在当前命令行上调用编辑器，并将结果作为shell命令执行
              mands。 Bash尝试调用$ VISUAL，$ EDITOR和emacs作为编辑器
              订购。

   更改文本的命令
       delete-char（C-d）
              删除点上的字符。如果point位于该行的开头，则有
              行中没有字符，并且键入的最后一个字符未绑定
              delete-char，然后返回EOF。
       backward-delete-char（Rubout）
              删除光标后面的字符。给定数字参数时，保存
              在杀戮戒指上删除了文字。
       前后 - 删除 - 木炭
              删除光标下的字符，除非光标位于行的末尾，
              在这种情况下，光标后面的字符将被删除。
       引用插入（C-q，C-v）
              将该下一个字符逐字添加到行中。这是插入字符的方法
              比如C-q。
       制表符插入（C-v TAB）
              插入制表符。
       自插入（a，b，A，1，！，...）
              插入键入的字符。
       转置字符（C-t）
              在点前移点前移动角色，移动点
              前进也是如此。如果point位于该行的末尾，那么这将转换为两者
              点之前的字符。否定论点没有效果。
       转置词（M-t）
              在点之后拖动单词之前的单词，将该点移动到该单词之后
              好。如果point位于该行的末尾，则会将最后两个单词转置为
              线。
       upcase-word（M-u）
              大写当前（或后续）单词。使用否定参数，大写
              上一个字，但不要移动点。
       downcase-word（M-l）
              小写当前（或后续）单词。使用否定参数，小写
              上一个字，但不要移动点。
       大写字（M-c）
              将当前（或后续）单词大写。用负面论证，大写
              前一个词，但不要移动点。
       覆盖模式
              切换覆盖模式。使用显式正数字参数，切换到
              覆盖模式。使用显式非正数字参数，切换到插入
              模式。此命令仅影响emacs模式; vi模式的覆盖方式不同。
              每次调用readline（）都以插入模式启动。在覆盖模式下，字符绑定
              自我插入在点处替换文本而不是将文本推向右侧。
              绑定到backward-delete-char的字符用a替换点之前的字符
              空间。默认情况下，此命令未绑定。

   杀戮和Yanking
       杀线（C-k）
              将文本从点到终止。
       反向杀线（C-x Rubout）
              向后杀到行的开头。
       unix-line-discard（C-u）
              从点向后杀死到行的开头。已保存的文本已保存
              杀戮戒指。
       杀，整线
              杀死当前行上的所有字符，无论哪个点。
       杀词（M-d）
              从点到当前单词的结尾，或者如果在单词之间，到达结尾
              下一个字。字边界与前向字使用的边界相同。
       向后杀词（M-Rubout）
              杀掉点后面的词。字边界与背面使用的边界相同
              病房字。
       shell-kill-word（M-d）
              从点到当前单词的结尾，或者如果在单词之间，到达结尾
              下一个字。字边界与shell-forward-word使用的边界相同。
       shell-backward-kill-word（M-Rubout）
              杀掉点后面的词。字边界与使用的边界相同
              壳反向词。
       unix-word-rubout（C-w）
              使用空格作为单词边界，杀掉单词后面的单词。被杀死的文字
              被保存在杀戮戒指上。
       UNIX的文件名，擦去
              使用空格和斜线字符作为单词，杀掉单词后面的单词
              边界。被杀死的文本保存在kill-ring上。
       删除 - 水平空间（M- \）
              删除点周围的所有空格和制表符。
       杀区
              杀死当前区域的文本。
       复制区域作为杀
              将区域中的文本复制到kill缓冲区。
       复制反向词
              将点前的单词复制到kill buffer。单词边界是相同的
              反向词。
       复制正向词
              将以下单词复制到kill buffer。单词边界是相同的
              作为前瞻性词。
       猛拉（C-y）
              将杀伤环的顶部猛击到缓冲点处。
       yank-pop（M-y）
              旋转杀环，并猛拉新的顶部。只能在yank或yank-pop之后工作。

   数字参数
       数字参数（M-0，M-1，...，M--）
              将此数字添加到已累积的参数中，或者启动新参数。 M--
              开始一个负面的论点。
       通用参数的
              这是指定参数的另一种方法。如果此命令后跟一个或
              更多数字，可选地带有前导减号，这些数字定义参数。
              如果命令后跟数字，则再次执行universal-argument结束
              数字参数，但否则被忽略。作为一种特殊情况，如果是这个命令
              紧接着是一个既不是数字也不是减号的字符，
              下一个命令的计数乘以4。参数计数是ini
              一个，所以第一次执行此函数使参数计数为四，
              第二次使参数计数为16，依此类推。

   完成
       完成（TAB）
              尝试在点之前对文本执行完成。 Bash尝试完成
              将文本视为变量（如果文本以$开头），用户名（如果是文本
              以〜）开头，主机名（如果文本以@开头）或命令（包​​括别名）
              和功能）反过来。如果这些都不产生匹配，则文件名完成
              尝试。
       可能完成（M-？）
              在点之前列出文本的可能完成情况。
       插入完成（M- *）
              在由生成的点之前插入文本的所有完成
              可能完井。
       菜单完成
              与完成类似，但用一个匹配替换要完成的单词
              可能的完成列表。重复执行菜单完成步骤
              可能的完成列表，依次插入每个匹配。在结束时
              完成列表，铃声是响铃（根据钟式设置）和
              原始文本已恢复。 n的参数在列表中向前移动n个位置
              比赛;可以使用否定参数在列表中向后移动。这个
              命令旨在绑定到TAB，但默认情况下不绑定。
       菜单完成后向
              与菜单完成相同，但在可能的补充列表中向后移动
              tions，好像菜单完整已被给予否定的论点。这个命令是
              默认情况下不绑定。
       删除 - 炭或列表
              如果不在行的开头或结尾，则删除光标下的字符
              （比如delete-char）。如果在行尾，行为与可能的行为相同
              pletions。默认情况下，此命令未绑定。
       完整文件名（M- /）
              在点之前的文本上尝试完成文件名。
       可能的文件名完成次数（C-x /）
              在点之前列出文本的可能完成，将其视为文件名。
       完整用户名（M-〜）
              在点之前尝试完成文本，将其视为用户名。
       可能的用户名完成次数（C-x~）
              在点之前列出文本的可能完成，将其视为用户名。
       完全变量（M- $）
              在点之前尝试完成文本，将其视为shell变量。
       可能变量完成（C-x $）
              在点之前列出文本的可能完成，将其视为shell变量
              能够。
       完整主机名（M- @）
              在点之前尝试完成文本，将其视为主机名。
       可能的主机名完成次数（C-x @）
              在点之前列出文本的可能完成，将其视为主机名。
       完成命令（M-！）
              在点之前尝试完成文本，将其视为命令名称。命令
              完成尝试将文本与别名，保留字，shell函数匹配
              tions，shell builtins，最后是可执行文件名，按顺序排列。
       可能的命令完成（C-x！）
              在点之前列出文本的可能完成，将其视为命令
              名称。
       动态完整历史（M-TAB）
              在点之前尝试完成文本，将文本与来自的行进行比较
              可能完成匹配的历史列表。
       dabbrev-扩大
              在点之前的文本上尝试菜单完成，将文本与行进行比较
              从历史列表中可能完成匹配。
       完成括号（M- {）
              执行文件名完成并插入所包含的可能完成列表
              在大括号内，所以列表可供shell使用（参见上面的Brace Expansion）。

   键盘宏
       start-kbd-macro（C-x（）
              开始保存键入当前键盘宏的字符。
       end-kbd-macro（C-x））
              停止保存键入当前键盘宏的字符并存储默认值
              nition。
       call-last-kbd-macro（C-x e）
              通过在宏中创建字符，重新执行定义的最后一个键盘宏
              看起来好像键入了键盘。

   杂
       re-read-init-file（C-x C-r）
              读入inputrc文件的内容，并合并任何绑定或变量
              在那里找到了作业。
       中止（C-g）
              中止当前的编辑命令并响铃终端的铃声（取决于设置 - 
              钟式的）。
       do-uppercase-version（M-a，M-b，M-x，...）
              如果元化字符x是小写，则运行绑定到cor-的命令
              响应大写字符。
       前缀元（ESC）
              Metafy下一个字符输入。 ESC f相当于Meta-f。
       撤消（C-_，C-x C-u）
              增量撤消，分别记住每一行。
       恢复线（M-r）
              撤消对此行所做的所有更改。这就像执行撤销命令一样
              将该行恢复到初始状态的时间。
       波浪扩展（M-＆）
              对当前单词执行波浪扩展。
       设定标记（C- @，M- <空格>）
              将标记设置为该点。如果提供了数字参数，则标记设置为
              那个位置。
       交换点和标记（C-x C-x）
              用标记交换点。当前光标位置设置为保存的位置
              和旧光标位置保存为标记。
       字符搜索（C-]）
              读取一个字符，并将点移动到该字符的下一个匹配项。一个
              消极的国家
t搜索先前的事件。
       字符搜索后退（M-C-]）
              读取一个字符，并将点移动到该字符的上一个匹配项。
              否定计数搜索后续事件。
       跳过-CSI-序列
              读取足够多的字符以使用多键序列，例如为其定义的序列
              像Home和End这样的键。此类序列以控制序列指示符开始
              （CSI），通常是ESC- [。如果此序列绑定到“\ [”，则生成此序列
              除非显式绑定到readline命令，否则序列将无效
              将杂散字符插入编辑缓冲区。默认情况下，这是未绑定的，
              但通常与ESC- [。
       插入注释（M-＃）
              如果没有数字参数，则readline comment-begin变量的值为
              插入当前行的开头。如果提供了数字参数，
              此命令用作切换：如果行开头的字符执行
              不匹配comment-begin的值，插入值，否则为charac-
              comment-begin中的ters将从行的开头删除。在任一情况下，
              接受该行，就像输入换行符一样。 com的默认值
              ment-begin导致此命令使当前行成为shell注释。如果一个
              数字参数导致注释字符被删除，该行将是exe-
              由贝壳提供。
       全球完整词（M-g）
              点之前的单词被视为路径名扩展的模式，带有aster-
              isk隐式附加。此模式用于生成匹配文件列表
              可能的完成名称。
       glob-expand-word（C-x *）
              点之前的单词被视为路径名扩展的模式和列表
              插入匹配的文件名，替换该单词。如果是数字参数
              如果提供，则在路径名扩展之前附加星号。
       glob-list-expansions（C-x g）
              由glob-expand-word生成的扩展列表是dis-
              玩了，重新划线。如果提供了数字参数，则为星号
              在路径名扩展之前附加。
       翻斗功能
              将所有函数及其键绑定打印到readline输出流。如果
              提供了一个数字参数，输出的格式可以是这样
              成为inputrc文件的一部分。
       翻斗变量
              将所有可设置的readline变量及其值打印到readline输出
              流。如果提供了数字参数，则以这种方式格式化输出
              它可以成为inputrc文件的一部分。
       翻斗宏
              打印绑定到宏的所有readline键序列及其输出的字符串。
              如果提供了数字参数，则输出的格式可以是这样
              成为inputrc文件的一部分。
       display-shell-version（C-x C-v）
              显示有关当前bash实例的版本信息。

   可编程完成
       当尝试对完成规范的命令的参数进行单词完成时
       使用完整的内置函数定义了compification（compspec）（参见SHELL BUILTIN COM-
       下面的MANDS），调用可编程完成工具。

       首先，识别命令名称。如果命令字是空字符串（完成
       尝试在空行的开头），使用-E选项定义的任何compspec
       完成使用。如果已为该命令定义了compspec，则使用compspec
       生成该单词的可能完成列表。如果命令字是完整的
       pathname，首先搜索完整路径名的compspec。如果没有找到compspec
       对于完整路径名，尝试查找后面的部分的compspec
       最后的斜线。如果这些搜索没有导致compspec，则任何compspec定义为
       -D选项完成用作默认值。

       找到compspec后，它将用于生成匹配单词列表。如果一个
       找不到compspec，默认的bash完成如上面的Completing中所述
       执行。

       首先，使用compspec指定的操作。只有前缀为的匹配项
       正在填写的单词将被退回。当-f或-d选项用于文件名或
       目录名称完成，shell变量FIGNORE用于过滤匹配。

       将生成由路径名扩展模式指定到-G选项的任何完成
       下一个。模式生成的单词不需要与正在完成的单词匹配。该
       GLOBIGNORE shell变量不用于过滤匹配，但是FIGNORE变量是
       用过的。

       接下来，将考虑指定为-W选项的参数的字符串。字符串是
       首先使用IFS特殊变量中的字符作为分隔符进行拆分。壳报价
       很荣幸。然后使用大括号扩展，波浪扩展，参数扩展每个单词
       和变量扩展，命令替换和算术扩展，如上所述
       在扩展下。使用上面在Word Split-下面描述的规则拆分结果
       婷。扩展的结果与正在完成的单词匹配前缀，
       并且匹配的单词成为可能的完成。

       生成这些匹配后，使用指定的任何shell函数或命令
       -F和-C选项被调用。当调用命令或函数时，COMP_LINE，
       COMP_POINT，COMP_KEY和COMP_TYPE变量分配值如上所述
       壳变量。如果正在调用shell函数，则COMP_WORDS和COMP_CWORD变量
       还设置了ables。调用函数或命令时，第一个参数是
       正在完成参数的命令的名称，第二个参数是单词
       正在完成，第三个参数是在完成的单词之前的单词
       当前的命令行。没有过滤生成的完成对词
       已完成;函数或命令完全自由地生成
       火柴。

       首先调用使用-F指定的任何函数。该函数可以使用任何shell
       设施，包括下面描述的compgen，用于生成匹配。它
       必须将可能的完成放在COMPREPLY数组变量中。

       接下来，在相当于的环境中调用使用-C选项指定的任何命令
       命令替换。它应该打印一个完成列表，每行一个，到标准
       输出。如有必要，可以使用反斜杠来转义换行符。

       生成所有可能的完成后，使用-X指定的任何过滤器
       选项应用于列表。过滤器是用于路径名扩展的模式;一个 ＆
       在模式中替换为正在完成的单词的文本。文字和可能
       用反斜杠逃脱;在尝试匹配之前删除反斜杠。任何补充 - 
       匹配模式的将从列表中删除。领先！否定了
       燕鸥;在这种情况下，任何与模式不匹配的完成都将被删除。

       最后，使用-P和-S选项指定的任何前缀和后缀都会添加到每个内存中。
       完成列表的ber，结果返回到readline完成代码为
       可能的完成列表。

       如果先前应用的操作不生成任何匹配项，则使用-o dirnames选项
       在定义compspec时，提供完成，目录名称完成
       尝试。

       如果在定义compspec时提供了-o plusdirs选项以完成，则为directory
       尝试完成名称，并将任何匹配添加到其他操作的结果中。

       默认情况下，如果找到compspec，它生成的任何内容都将返回到完成
       代码作为完整的可能完成集。默认的bash完成不是
       尝试，并禁用文件名完成的readline默认值。如果-o bashde-
       在定义compspec时提供了fault选项来完成，bash默认为
       如果compspec不生成匹配，则尝试尝试。如果-o default选项是
       在定义compspec时提供完成，readline的默认完成将是
       如果compspec（以及，如果尝试，默认的bash完成）生成no，则执行
       火柴。

       当compspec表明需要完成目录名称时，可编程的com-
       pletion函数强制readline将斜杠附加到符号的已完成名称
       指向目录的链接，取决于mark-directories readline变量的值，
       无论mark-symlinked-directories readline变量的设置如何。

       有一些动态修改完成的支持。这在使用时最有用
       与完整-D指定的默认完成相结合。它有可能
       shell函数作为完成处理程序执行，以指示应该完成
       通过返回124的退出状态重试。如果shell函数返回124，则更改
       compspec与正在尝试完成的命令相关联（提供
       作为执行函数时的第一个参数），可编程完成从重新开始
       一开始，尝试为该命令找到新的compspec。这允许一组
       尝试完成时动态构建的完成次数，而不是被加载
       一次全部。

       例如，假设有一个compspecs库，每个都保存在一个文件中
       在命令名称的作用下，将加载以下默认完成函数
       动态完成：

       _completion_loader（）
       {
            。 “/etc/bash_completion.d/$1.sh”> / dev / null 2>＆1 &&返回124
       }
       完成-D -F _completion_loader


历史
       启用set builtin的-o history选项后，shell将提供对该内置的访问权限
       命令历史记录，以前键入的命令列表。 HISTSIZE变量的值
       用作要保存在历史列表中的命令数。最后一个HISTSIZE的文本
       命令（默认为500）已保存。 shell先前将每个命令存储在历史列表中
       参数和变量扩展（参见上面的EXPANSION）但历史扩展后
       根据shell变量HISTIGNORE和HISTCONTROL的值执行。

       在启动时，历史记录是从变量HISTFILE命名的文件初始化的
       （默认〜/ .bash_history）。如果必要，则截断由HISTFILE值命名的文件
       sary，包含不超过HISTFILESIZE值指定的行数。
       读取历史文件时，将跟随以历史注释字符开头的行
       紧接着一个数字被解释为前一个历史记录行的时间戳。这些
       可选地显示时间戳，具体取决于HISTTIMEFORMAT变量的值。
       当交互式shell退出时，将从历史列表中复制最后的$ HISTSIZE行
       到$ HISTFILE。如果启用了histappend shell选项（请参阅shopt的说明
       在下面的SHELL BUILTIN命令下），行将附加到历史文件中，否则
       历史文件被覆盖。如果未设置HISTFILE，或者历史文件是
       不可写，历史没有保存。如果设置了HISTTIMEFORMAT变量，则为时间戳
       被写入历史文件，用历史注释字符标记，因此它们可能是
       在shell会话中保留。这使用历史注释字符来区分
       来自其他历史记录行的时间戳。保存历史记录后，历史文件是trun-
       包含不超过HISTFILESIZE行。如果没有设置HISTFILESIZE，则没有trunca-
       执行。

       内置命令fc（参见下面的SHELL BUILTIN命令）可用于列出或编辑和
       重新执行历史列表的一部分。内置的历史记录可用于显示或
       修改历史列表并操纵历史文件。使用命令行编辑时，
       搜索命令在每种编辑模式下都可用，它们提供对历史列表的访问。

       shell允许控制在历史列表中保存哪些命令。 HISTCON-
       TROL和HISTIGNORE变量可以设置为使shell只保存一部分
       输入的命令。 cmdhist shell选项（如果启用）会导致shell尝试
       在同一个历史记录条目中保存多行命令的每一行，在其中添加分号
       保持句法正确性所必需的。 lithist shell选项导致shell
       使用嵌入的换行符而不是分号保存命令。请参阅说明
       在SHELL BUILTIN COMMANDS下面的shopt内置有关设置和取消设置的信息
       shell选项。

历史扩张
       shell支持历史扩展功能，类似于历史记录扩展
       CSH。本节介绍可用的语法功能。此功能已启用
       默认情况下，对于交互式shell，可以使用该组的+ H选项禁用
       内置命令（参见下面的SHELL BUILTIN命令）。非交互式shell不执行
       历史扩展默认情况下。

       历史扩展将历史列表中的单词引入输入流中
       容易重复的命令，将前一个命令的参数插入当前输入
       line，或快速修复以前命令中的错误。

       在读取完整行之后，在shell之前立即执行历史记录扩展
       把它分解成文字。它分两部分进行。首先是确定哪一行
       从历史列表中替换时使用。第二是选择部分内容
       包含在当前行中的行。从历史中选择的线是事件，
       并且该行的部分是单词。各种改性剂可用 - 
       能够操纵选定的单词。这条线以同样的方式被分成了几个字
       当读取输入时，使几个元字符分隔的单词被引号括起来
       被认为是一个词。历史扩展是由他的外观引入的 - 
       保守党扩张人物，这是！默认情况下。只有反斜杠（\）和单引号才可以
       引用历史扩展字符。

       如果在历史之后立即发现，几个字符会抑制历史扩张
       扩展字符，即使它没有引用：空格，制表符，换行符，回车符和=。
       如果启用了extglob shell选项，（也将禁止扩展。

       内置shopt可设置的几个shell选项可用于定制行为
       历史扩张。如果启用了histverify shell选项（请参阅
       shopt builtin under），并且正在使用readline，历史替换不是立即的
       传递给shell解析器。而是将扩展的行重新加载到readline编辑中 - 
       缓冲区进一步修改。如果正在使用readline，则使用histreedit shell
       选项已启用，失败的历史记录替换将重新加载到readline编辑中
       缓冲纠正。可以使用history builtin命令的-p选项查看
       在使用之前，历史扩展会做些什么。内置历史记录的-s选项可以
       用于将命令添加到历史列表的末尾而不实际执行它们，所以
       他们可以随后召回。

       shell允许控制历史扩展机制使用的各种字符
       （参见Shell变量下面的histchars说明）。 shell使用历史记录
       注释字符以在写入历史文件时标记历史时间戳。

   活动指示人
       事件指示符是对历史列表中的命令行条目的引用。除非
       reference是绝对的，事件是相对于历史列表中的当前位置。

       ！开始历史记录替换，除非后跟空白，换行符，运输
              return，=或（（当使用内置的shopt启用extglob shell选项时）。
       ！n请参阅命令行n。
       ！-n请参阅当前命令减去n。
       ！请参阅上一个命令。这是`！-1'的同义词。
       ！串
              请参阅历史列表中当前位置之前的最新命令
              以字符串开头。
       ！？串[？]
              请参阅历史列表中当前邮件之前的最新命令
              包含字符串。落后？如果立即跟随字符串，则可以省略
              通过换行符。
       ^ ^ STRING1 ^字符串2
              快速替换。重复上一个命令，将string1替换为string2。
              相当于``!!：s / string1 / string2 /''（参见下面的修饰符）。
       ！＃到目前为止输入的整个命令行。

   Word指示符
       Word指示符用于从事件中选择所需的单词。答：分开事件
       来自单词指示符的规范。如果单词指示符开始，则可以省略
       使用^，$，*， - 或％。单词从行的开头编号，第一行
       单词由0（零）表示。单词被插入到由sin-分隔的当前行中
       gle空间。

       0（零）
              第0个字。对于shell，这是命令字。
       n第n个字。
       ^第一个参数。也就是说，单词1。
       $最后一个论点。
       ％这个词与最近的`？string？'相匹配？搜索。
       x-y一系列单词; `-y'缩写为'0-y'。
       *所有的话，但第零。这是“1- $”的同义词。这不是错误
              如果事件中只有一个单词，则使用*;返回空字符串
              那种情况。
       x *缩写x- $。
       x-缩写x- $喜欢x *，但省略了最后一个单词。

       如果提供的字指示符没有事件规范，则前一个命令是
       用作活动。

   修饰符
       在可选的单词指示符之后，可能会出现一个或多个序列的序列
       降低修饰符，每个修饰符前面都有一个`：'。

       h删除尾随文件名组件，只留下头部。
       t删除所有前导文件名组件，留下尾部。
       r删除表单.xxx的尾部后缀，保留基本名称。
       e删除除尾随后缀之外的所有内容。
       p打印新命令但不执行它。
       引用替换的单词，逃避进一步的替换。
       x引用替换的单词与q一样，但在空白和换行符处分成单词。
       S /老/新/
              在事件行中替换new为第一次出现的old。任何分隔符都可以
              用来代替/。如果最后一个分隔符是最后一个字符，则它是可选的
              事件线。分隔符可以引用旧的和新的单个背面 - 
              削减。如果＆出现在新的，它将被旧的替换。一个反斜杠就会引用
              ＆。如果old为null，则将其设置为最后一个旧的替换，或者，如果之前没有
              历史替换发生了，最后一个字符串在！？string [？]中搜索。
       并重复上一次替换。
       g导致在整个事件行上应用更改。这是结合使用的
              用`：s'（例如，`：gs / old / new /'）或`：＆'。如果与`：s'一起使用，任何分隔符都可以
              用于代替/，如果它是最后一个字符，则最终分隔符是可选的
              事件线。 a可以用作g的同义词。
       G对事件行中的每个单词应用以下`s'修饰符一次。

SHELL BUILTIN COMMANDS
       除非另有说明，否则本节中的每个内置命令都记录为接受
       选项前面带有 - 接受 - 表示选项的结束。 ：，真实，虚假，
       并测试builtins不接受选项，不要 - 特别是。退出，退出，
       break，continue，let和shift内置接受和处理以 - 开头的参数
       不要求 - 。其他接受参数但未指定为的内置函数
       接受选项解释以 - 作为无效选项和要求 - 来开头的参数
       防止这种解释。
       ：[参数]
              没有效果;除了扩展参数和执行任何操作之外，该命令不会执
              指定的重定向。返回零退出代码。

        .文件名[参数]
       source [参数]
              在当前shell环境中从filename读取并执行命令并返回
              从filename执行的最后一个命令的退出状态。如果文件名没有
              包含斜杠，PATH中的文件名用于查找包含文件的目录 - 
              名称。在PATH中搜索的文件不需要是可执行的。当bash不在时
              posix模式，如果在PATH中找不到文件，则搜索当前目录。如果
              shopt builtin命令的sourcepath选项被关闭，PATH则没有
              搜索。如果提供了任何参数，它们将成为位置参数
              文件名已执行。否则，位置参数不变。该
              返回状态是脚本中退出的最后一个命令的状态（如果不是，则为0）
              命令被执行），如果找不到或无法读取文件名，则为false。

       alias [-p] [name [= value] ...]
              没有参数的别名或带-p选项的别名会打印表单中的别名列表
              别名name =标准输出的值。提供参数时，别名为
              为每个给出其值的名称定义。值的尾随空格导致
              扩展别名时要检查别名替换的下一个字。对于每一个
              参数列表中没有提供值的名称，名称和值
              别名被打印出来。除非给出没有别名的名称，否则别名返回true
              已定义。

       bg [jobspec ...]
              在后台恢复每个暂停的作业jobspec，就像它已经开始一样
              ＆。如果jobspec不存在，则使用shell的当前作业概念。 BG
              除非在禁用作业控制时运行，或者在使用作业控制运行时运行，否则jobspec将返回0
              启用了控制，未找到任何指定的jobspec或在没有作业的情况下启动
              特伦。

       绑定[-m keymap] [-lpsvPSV]
       bind [-m keymap] [-q function] [-u function] [-r keyseq]
       bind [-m keymap] -f filename
       bind [-m keymap] -x keyseq：shell-command
       bind [-m keymap] keyseq：function-name
       绑定readline-command
              显示当前的readline键和功能绑定，将键序列绑定到read-
              行函数或宏，或设置readline变量。每个非选项参数都是a
              命令，因为它将出现在.inputrc中，但必须传递每个绑定或命令
              作为一个单独的论点;例如，''\ C-x \ C-r“：re-read-init-file'。选项，如果支持
              合作，具有以下含义：
              -m keymap
                     使用keymap作为受后续绑定影响的键映射。接受-
                     能够的键映射名称是emacs，emacs-standard，emacs-meta，emacs-ctlx，vi，
                     vi-move，vi-command和vi-insert。 vi相当于vi-command; emacs是
                     相当于emacs-standard。
              -l列出所有readline函数的名称。
              -p以可能的方式显示readline函数名称和绑定
                     重读。
              -P列出当前的readline函数名称和绑定。
              -s显示绑定到宏的readline键序列及其输出的字符串
                     这样一种方式可以重新阅读。
              -S显示绑定到宏的readline键序列及其输出的字符串。
              -v以这样的方式显示readline变量名称和值
                     读。
              -V列出当前的readline变量名称和值。
              -f文件名
                     从文件名中读取键绑定。
              -q功能
                     查询哪些键调用命名函数。
              -u功能
                     取消绑定绑定到指定函数的所有键。
              -r keyseq
                     删除keyseq的任何当前绑定。
              -x keyseq：shell-command
                     导致在输入keyseq时执行shell命令。什么时候
                     执行shell-command后，shell将READLINE_LINE变量设置为
                     readline行缓冲区的内容和READLINE_POINT变量
                     插入点的当前位置。如果执行的命令改变了
                     READLINE_LINE或READLINE_POINT的值将反映这些新值
                     在编辑状态。

              除非给出无法识别的选项或发生错误，否则返回值为0。

       break [n]
              从for，while，until或select循环中退出。如果指定了n，则中断n
              水平。 n必须≥1。如果n大于封闭循环的数量，则全部
              退出封闭循环。当n≤0时，返回值不为零;除此以外，
              break返回0值。

       builtin shell-builtin [参数]
              执行指定的shell内置，传递参数，并返回其退出sta
              土族。这在定义名称与shell相同的函数时很有用
              内置，保留功能内置功能。 cd
              内置通常以这种方式重新定义。如果是shell-builtin，则返回状态为false
              不是shell内置命令。

       caller [expr]
              返回任何活动子例程调用的上下文（shell函数或脚本exe-
              与...同伴。或源内置）。如果没有expr，调用者将显示行号
              和当前子程序调用的源文件名。如果是非负整数
              作为expr提供，调用者显示行号，子例程名称和源文件
              对应于当前执行调用堆栈中的该位置。这个额外的
              例如，可以使用信息来打印堆栈跟踪。目前的框架是
              除非shell没有执行子程序调用，否则返回值为0
              或expr不对应于调用堆栈中的有效位置。

       cd [-L | [-P [-e]]] [dir]
              将当前目录更改为dir。变量HOME是默认目录。该
              变量CDPATH定义包含dir的目录的搜索路径。 Alterna-
              CDPATH中的目录名称由冒号（:)分隔。空目录名称
              在CDPATH中与当前目录相同，即“。”。如果dir以a开头
              斜杠（/），然后不使用CDPATH。 -P选项表示使用物理目录
              结构而不是遵循符号链接（另请参阅集合的-P选项
              内置命令）; -L选项强制遵循符号链接。如果是-e
              选项随-P提供，当前工作目录无法成功
              在成功更改目录后确定，cd将返回一个不成功的目标
              土族。 - 的参数相当于$ OLDPWD。如果是非空目录名称
              使用CDPATH，或者如果 - 是第一个参数，并且目录更改成功 - 
              ful，新工作目录的绝对路径名写入标准
              输出。如果目录已成功更改，则返回值为true;假
              除此以外。

       command [-pVv] command [arg ...]
              使用args运行命令可以抑制正常的shell函数查找。只有内置
              执行PATH中的命令或命令。如果给出-p选项，则
              使用默认值fo执行搜索命令
r保证的路径
              找到所有标准实用程序。如果提供-V或-v选项，则a
              打印命令的描述。 -v选项会导致单个单词指示
              用于调用要显示的命令的命令或文件名; -V选项pro-
              更详细的描述。如果提供-V或-v选项，则退出sta
              如果找到命令，则tus为0，否则为1。如果没有提供任何选项和
              发生错误或命令无法找到，退出状态为127.否则，
              命令buildin的退出状态是命令的退出状态。

       compgen [选项] [字]
              根据选项生成可能的单词完成匹配，可能是
              完整内置函数接受的任何选项，但-p和-r除外
              将匹配写入标准输出。使用-F或-C选项时，var-
              由可编程完成工具设置的ious shell变量，虽然可用，
              没有有用的价值。

              匹配将以与可编程完成代码相同的方式生成
              直接从具有相同标志的完成规范生成它们。如果
              指定了单词，只显示匹配单词的那些完成。

              除非提供了无效选项，否则返回值为true，或者没有匹配项
              产生。

       complete [-abcdefgjksuv] [-o comp-option] [-DE] [-A action] [-G globpat] [-W wordlist] [-F
       功能] [-C命令]
              [-X filterpat] [-P prefix] [-S suffix] name [name ...]
       complete -pr [-DE] [name ...]
              指定应如何完成每个名称的参数。如果-p选项是支持
              如果没有提供选项，则打印现有的完成规范
              以允许它们作为输入重用的方式。 -r选项删除完成
              每个名称的规范，或者，如果没有提供名称，则所有完成规范 - 
              蒸发散。 -D选项表示应该应用其余选项和操作
              到``default''命令完成;也就是说，在命令上尝试完成
              以前没有完成任何完成。 -E选项表示
              剩下的选项和动作应该适用于``empty''命令完成;那
              是，在空白行上尝试完成。

              单词完成时应用这些完成规范的过程
              以上在可编程完成下描述了尝试。

              其他选项（如果指定）具有以下含义。 -G的论据，
              -W和-X选项（以及必要时，-P和-S选项）应引用
              在调用完整的内置函数之前保护它们不被扩展。
              -o comp-option
                      comp-option控制compspec行为的几个方面
                      简单生成完成。 comp-option可能是以下之一：
                      bashdefault
                              如果compspec执行其余的默认bash完成
                              不生成匹配项。
                      default如果生成compspec，则使用readline的默认文件名完成
                              无匹配。
                      dirnames中
                              如果compspec生成no，则执行目录名称完成
                              火柴。
                      文件名
                              告诉readline compspec生成文件名，因此它可以
                              形成任何特定于文件名的处理（比如向direc-添加斜杠）
                              保守党名称，引用特殊字符或抑制尾随水疗 - 
                              CES）。旨在与shell函数一起使用。
                      nospace告诉readline不要在已完成的单词后附加一个空格（默认值）
                              在行尾。
                      plusdirs
                              在生成由compspec定义的任何匹配之后，目录
                              尝试完成名称，并将任何匹配添加到
                              其他行动的结果。
               - 行动
                      该操作可以是以下之一，以生成可能的com-列表
                      pletions：
                      别名别名。也可以指定为-a。
                      arrayvar
                              数组变量名。
                      绑定Readline键绑定名称。
                      builtin shell内置命令的名称。也可以指定为-b。
                      命令命令。也可以指定为-c。
                      目录
                              目录名称。也可以指定为-d。
                      残
                              已禁用的shell内置命令的名称。
                      enabled已启用的shell内置命令的名称。
                      export导出的shell变量的名称。也可以指定为-e。
                      file文件名。也可以指定为-f。
                      功能
                              shell函数的名称。
                      组名称组。也可以指定为-g。
                      HELPTOPIC
                              帮助内置的帮助主题。
                      主机名
                              主机名，取自HOSTFILE shell指定的文件
                              变量。
                      作业名称，如果作业控制处于活动状态。也可以指定为-j。
                      关键字Shell保留字。也可以指定为-k。
                      如果作业控制处于活动状态，则运行正在运行的作业的名称
                      服务服务名称。也可以指定为-s。
                      setopt set builtin的-o选项的有效参数。
                      shopt内置的shopt接受的商店Shell选项名称。
                      信号信号名称。
                      如果作业控制处于活动状态，则停止已停止作业的名称。
                      用户用户名。也可以指定为-u。
                      变量
                              所有shell变量的名称。也可以指定为-v。
              -C命令
                      命令在子shell环境中执行，其输出用作
                      可能的完成。
              -F功能
                      shell函数函数在当前shell环境中执行。
                      完成后，可以从值中检索可能的完成
                      COMPREPLY数组变量。
              -G globpat
                      路径名扩展模式globpat被扩展为生成可能的
                      落成。
              -P前缀
                      在每个可能的完成之后，在所有其他之后添加前缀
                      选项已被应用。
              -S后缀
                      所有其他选项都有后缀附加到每个可能的完成
                      已被应用。
              -W wordlist
                      使用IFS特殊变量中的字符拆分wordlist
                      分隔符，每个结果单词都被扩展。可能的完成
                      结果列表的成员与正在填写的单词匹配。
              -X filterpat
                      filterpat是用于路径名扩展的模式。它适用于
                      由前述选项产生的可能完成的清单和论证 - 
                      将从列表中删除每个完成匹配filterpat。一个
                      领导 ！在filterpat中否定了模式;在这种情况下，任何完成不
                      匹配filterpat被删除。

              除非提供了无效选项，否则返回值为true，除了。之外的选项
              -p或-r是在没有name参数的情况下提供的，尝试删除一个完整的
              不存在规范或发生错误的名称的规范
              添加完成规范。

       compopt [-o选项] [-DE] [+ o选项] [名称]
              根据选项修改每个名称的完成选项，或者修改
              如果没有提供名称，则执行完成。如果没有给出任何选择，
              播放每个名称或当前完成的完成选项。可能
              option的值是对上述完整内置函数有效的值。 -D
              option表示其余选项应该应用于``default''命令
              完成;也就是说，尝试完成没有完成的命令
              以前已定义。 -E选项表示其余选项应该
              适用于``empty''命令完成;也就是说，在空白处尝试完成
              线。

              除非提供了无效选项，否则返回值为true
              修改没有完成规范的名称的选项，或者
              发生输出错误。

       continue [n]
              恢复封闭for，while，until或select循环的下一次迭代。如果是
              指定，在第n个封闭循环处继续。 n必须≥1。如果n更大
              比封闭循环的数量，最后一个封闭循环（“顶级”循环）
              恢复了。当在循环内执行continue时，返回值不为零
              当n≤0时;否则，继续返回0值。当继续执行时 - 
              循环一侧，返回值为0。

       declare [-aAfFgilrtux] [-p] [name [= value] ...]
       typeset [-aAfFgilrtux] [-p] [name [= value] ...]
              声明变量和/或赋予它们属性。如果没有给出名字，则显示
              变量的值。 -p选项将显示的属性和值
              每个名字。当-p与名称参数一起使用时，将忽略其他选项。
              当提供-p而没有名称参数时，它将显示属性和val-
              具有由附加选项指定的属性的所有变量的ues。如果
              没有其他选项与-p一起提供，声明将显示属性和val-
              所有shell变量的ues。 -f选项将显示限制为shell函数
              蒸发散。 -F选项禁止显示函数定义;只有功能 - 
              打印名称和属性。如果使用，则启用extdebug shell选项
              shopt，定义函数的源文件名和行号是dis-
              也起了作用。 -F选项意味着-f。 -g选项强制变量
              在全局范围内创建或修改，即使在shell中执行声明也是如此
              功能。在所有其他情况下都会被忽略。可以使用以下选项
              将输出限制为具有指定属性的变量或提供变量
              属性：
              -a每个名称都是一个索引数组变量（参见上面的数组）。
              -A每个名称都是一个关联数组变量（参见上面的数组）。
              -f仅使用函数名称。
              -i将变量视为整数;算术评估（参见ARITHMETIC
                     当变量被赋值时，执行上面的评估。
              -l为变量赋值时，所有大写字符都为con
                     转为小写。大写属性已禁用。
              -r只读名称。然后，这些名称不能通过subse-分配值
                     奇怪的赋值语句或未设置。
              -t为每个名称指定trace属性。跟踪函数继承DEBUG和
                     从调用shell返回陷阱。 trace属性没有特殊之处
                     对变量的意义。
              -u为变量赋值时，所有小写字符都为con
                     转为大写。小写属性已禁用。
              -x标记要通过环境导出到后续命令的名称。

              使用“+”而不是“ - ”会关闭属性，但有例外
              + a不能用于销毁数组变量，+ r不会删除readonly
              属性。在函数中使用时，将每个名称设置为本地名称，与本地com-
              mand，除非提供-g选项，如果变量名后跟= value，
              变量的值设置为value。除非无效，否则返回值为0
              遇到选项，尝试使用``-f foo = bar''定义一个函数，
              尝试将值分配给只读变量，尝试进行尝试
              在不使用复合赋值语法的情况下为数组变量赋值
              （参见上面的数组），其中一个名称不是有效的shell变量名，一个尝试
              用于关闭只读变量的只读状态，尝试进行
              关闭数组变量的数组状态，或尝试显示非数组
              与-f存在的功能。

       dirs [+ n] [-n] [-clpv]
              如果没有选项，则显示当前记住的目录列表。默认
              display在一行上，目录名用空格分隔。目录
              使用pushd命令添加到列表中; popd命令从中删除条目
              列表。
              + n显示dirs显示的列表左侧的第n个条目
                     没有选项调用，从零开始。
              -n显示dirs显示的列表右侧的第n个条目
                     没有选项调用，从零开始。
              -c通过删除所有条目来清除目录堆栈。
              -l生成更长的列表;默认列表格式使用代字号表示
                     主目录。
              -p打印目录堆栈，每行一个条目。
              -v打印目录堆栈，每行一个条目，为每个条目添加前缀
                     它在堆栈中的索引。

              返回值为0，除非提供了无效选项或n个索引超出
              目录堆栈的结尾。

       disown [-ar] [-h] [jobspec ...]
              如果没有选项，则会从活动作业表中删除每个jobspec。如果jobspec
              不存在-a和-r都没有提供，shell的当前概念
              工作被使用。如果给出-h选项，则不会从表中删除每个jobspec，
              但标记为如果shell收到SIGHUP，则不会将SIGHUP发送到作业。
              如果不存在jobspec，并且既没有提供-a选项也没有-r选项，那么
              租用工作被使用。如果未提供jobspec，则-a选项表示删除或标记
              所有工作;没有jobspec参数的-r选项将操作限制为运行
              工作。除非jobspec未指定有效作业，否则返回值为0。

       echo [-neE] [arg ...]
              输出args，用空格分隔，后跟换行符。返回状态是
              始终为0.如果指定了-n，则抑制尾随换行符。如果是-e选项
              给出了以下反斜杠转义字符的解释。
              -E选项禁用这些转义字符的解释，即使在sys-
              tems默认解释它们。可以使用xpg_echo shell选项
              动态确定echo是否扩展这些转义字符
              默认。 echo不解释 - 意味着选项的结束。回声解释
              以下转义序列：
              警报（铃）
              \ b退格
              \ c抑制进一步的输出
              。\ E
              \ E逃脱角色
              \ f表格饲料
              \ n新行
              \ r \ n回车
              \ t水平标签
              \ v垂直标签
              \\反斜杠
              \ nnnnn八位字符，其值为八进制值nnn（零到三
                     八进制数字）
              \ xHH八位字符，其值为十六进制值HH（一个或两个
                     十六进制数字
              \ uHHHH Unicode（ISO / IEC 10646）字符，其值为十六进制值
                     HHHH（一到四个十六进制数字）
              \ UHHHHHHHH
                     Unicode（ISO / IEC 10646）字符，其值为十六进制值
                     HHHHHHHH（一到八位十六进制数字）

       enable[-a] [-dnps] [-f filename] [name ...]
              启用和禁用内置shell命令。禁用内置允许磁盘com-
              在没有指定的情况下，与内置的shell同名的mand
              完整路径名，即使shell通常在磁盘com-之前搜索内置
              mands。如果使用-n，则禁用每个名称;否则，名称已启用。对于
              例如，使用通过PATH找到的测试二进制代替shell内置版本
              sion，运行``enable -n test''。 -f选项表示加载新的builtin命令
              在支持动态加载的系统上，来自共享对象文件名的名称。 -d
              选项将删除先前使用-f加载的内置函数。如果没有名称参数
              给定，或者如果提供了-p选项，则打印一个shell内置列表。同
              没有其他选项参数，该列表包含所有已启用的shell内置函数。如果-n
              提供，只打印禁用的内置。如果提供-a，则列表
              打印包括所有内置，并指示是否已启用每个内置。
              如果提供了-s，则输出仅限于POSIX特殊内置。该
              除非名称不是内置shell或加载错误，否则返回值为0
              来自共享对象的新内置。

       评估[arg ...]
              args被读取并连接成一个命令。这个命令是
              然后由shell读取并执行，并将其退出状态作为值返回
              EVAL。如果没有args或只有null参数，则eval返回0。

       exec [-cl] [-a name] [command [arguments]]
              如果指定了command，则替换shell。没有创建新进程。该
              参数成为命令的参数。如果提供了-l选项，则为shell
              在传递给命令的第0个参数的开头放置一个破折号。这是
              登录（1）的作用。 -c选项导致命令以空的环境执行
              ronment。如果提供了-a，则shell将name作为第0个参数传递给
              执行命令。如果由于某种原因无法执行命令，则为非交互式
              shell退出，除非启用了shell选项execfail，在这种情况下它将返回
              失败。如果无法执行文件，则交互式shell将返回失败。如果
              命令未指定，任何重定向在当前shell中生效，并且
              返回状态为0.如果存在重定向错误，则返回状态为1。

       退出[n]
              导致shell退出状态为n。如果省略n，则退出状态为
              最后一个命令的执行。 EXIT上的陷阱在shell之前执行
              minates。

       export [-fn] [name [= word]] ...
       export -p
              提供的名称标记为自动导出到子环境 - 
              执行命令。如果给出-f选项，则名称引用函数。
              如果没有给出名称，或者提供了-p选项，则列出所有名称
              导出在这个shell中打印出来。 -n选项导致export属性
              从每个名字中删除。如果变量名后跟= word，则为
              变量设置为word。 export返回退出状态为0，除非无效
              遇到选项，其中一个名称不是有效的shell变量名，或者-f是
              提供的名称不是函数。

       fc [-e ename] [-lnr] [first] [last]
       fc -s [pat = rep] [cmd]
              修复命令。在第一种形式中，选择从第一个到最后一个的一系列命令
              从历史列表中。可以将first和last指定为字符串（以查找
              以该字符串开头的最后一个命令）或作为数字（历史记录的索引）
              list，其中负数用作当前命令编号的偏移量）。
              如果未指定last，则将其设置为当前用于列出的命令（以便``fc
              -l -10''打印最后10个命令），否则先打印。如果首先不是规格
              ified将其设置为上一个编辑命令，将-16设置为列表。

              -n选项在列出时禁止命令编号。 -r选项反转
              命令的顺序。如果给出-l选项，则列出命令
              标准输出。否则，ename给出的编辑器在一个包含的文件中被调用 - 
              这些命令。如果未给出ename，则FCEDIT变量的值为
              如果未设置FCEDIT，则使用EDITOR的值。如果两个变量都没有设置，vi
              用来。编辑完成后，将回显并执行编辑的命令。

              在第二种形式中，在每个pat实例被替换后重新执行命令
              代表。与此一起使用的一个有用的别名是``r =“fc -s”''，因此键入``r cc''运行
              以“cc”开头并输入“r”的最后一个命令重新执行最后一个命令
              普通话。

              如果使用第一个表单，则返回值为0，除非遇到无效选项
              tered或first或last指定历史记录行超出范围。如果-e选项是支持
              plied，返回值是最后执行的命令的值，如果是，则失败
              临时文件命令发生错误。如果使用第二种形式，则
              返回状态是重新执行的命令的状态，除非cmd未指定
              有效的历史记录行，在这种情况下fc返回失败。

       fg [jobspec]
              在前台恢复jobspec，并使其成为当前作业。如果jobspec不是
              目前，使用shell的当前作业的概念。返回值是
              将命令置于前台，或者如果在作业控制为dis-时运行则失败
              在启用作业控制的情况下运行，或者，如果jobspec未指定有效作业
              或jobspec指定在没有作业控制的情况下启动的作业。

       getopts optstring name [args]
              shell过程使用getopts来解析位置参数。 optstring con
              确认要识别的选项字符;如果一个字符后跟一个冒号，
              该选项应该有一个参数，该参数应该与之分开
              白色空间。冒号和问号字符不能用作选项字符 - 
              acters。每次调用它时，getopts都会将下一个选项放在shell变量中
              能够名称，如果它不存在则初始化名称，以及下一个论证的索引 - 
              将被处理成变量OPTIND。 OPTIND每次初始化为1
              调用shell或shell脚本。当一个选项需要参数时，
              getopts将该参数放入变量OPTARG中。 shell不会重置
              OPTIND自动;它必须在多次调用getopts之间手动重置
              如果要使用一组新参数，则在同一shell调用内。

              遇到选项结束时，getopts将以更大的返回值退出
              比零。 OPTIND设置为第一个非选项参数的索引，名称为
              调成 ？。

              getopts通常会解析位置参数，但是如果给出的参数更多
              在args中，getopts会解析这些。

              getopts可以通过两种方式报告错误。如果optstring的第一个字符是a
              冒号，使用静默错误报告。在正常操作中，诊断消息是
              遇到无效选项或缺少选项参数时打印。如果
              变量OPTERR设置为0，即使是第一个，也不会显示错误消息
              optstring的字符不是冒号。

              如果看到无效选项，请使用getopts吗？进入名称，如果不是沉默，则打印
              错误消息并取消设置OPTARG。如果getopts是静默的，那么选项字符
              找到放在OPTARG中，不打印任何诊断消息。

              如果找不到必需的参数，并且getopts不是静默的，则会出现问号（？）
              将其置于名称中，取消设置OPTARG，并打印诊断消息。如果getopts
              是沉默的，然后冒号（:)放在名称中，OPTARG设置为选项char-
              发现了。

              如果找到指定或未指定的选项，则getopts返回true。它回来了
              如果遇到选项结尾或发生错误，则返回false。

       hash [-lr] [-p filename] [-dt] [name]
              每次调用哈希时，命令名称的完整路径名由下式确定
              在$ PATH中搜索目录并记住。以前记得的任何路径 - 
              名称被丢弃。如果提供了-p选项，则不执行路径搜索，并且
              filename用作命令的完整文件名。 -r选项导致
              贝壳忘了所有记住的位置。 -d选项导致shell忘记
              记住每个名字的位置。如果提供-t选项，则完整路径 - 
              打印每个名称对应的名称。如果有多个名称参数支持
              与-t一起使用，在散列的完整路径名之前打印名称。 -l选项
              导致输出以可重复用作输入的格式显示。如果没有争论 - 
              给出了，或者如果只提供-l，则有关记忆命令的信息是
              打印。除非找不到名称或无效选项，否则返回状态为true
              供应。

       help [-dms] [模式]
              显示有关内置命令的有用信息。如果指定了pattern，请帮助
              给出匹配模式的所有命令的详细帮助;否则所有的帮助
              打印内置和外壳控制结构。
              -d显示每个模式的简短描述
              -m以类似联机帮助页的格式显示每个模式的描述
              -s仅显示每个模式的简短用法概要

              除非没有命令匹配模式，否则返回状态为0。

       历史[n]
       历史-c
       历史-d offset
       历史记录-anrw [文件名]
       历史-p arg [arg ...]
       历史-s arg [arg ...]
              如果没有选项，则显示带有行号的命令历史列表。列出的行
              带*已被修改。 n的参数仅列出最后n行。如果
              shell变量HISTTIMEFORMAT已设置且不为null，它用作格式字符串
              strftime（3）显示与每个显示的历史条目关联的时间戳。
              在格式化的时间戳和历史记录之间不打印中间空白
              线。如果提供了filename，则将其用作历史文件的名称;如果不，
              使用HISTFILE的值。选项（如果提供）具有以下含义：
              -c通过删除所有条目来清除历史列表。
              -d offset
                     删除位置偏移处的历史记录条目。
              -a附加“新”历史记录行（从开头输入的历史记录行）
                     当前的bash会话）到历史文件。
              -n将尚未从历史文件中读取的历史记录行读入cur-
                     租金历史清单。这些是自从以来附加到历史文件的行
                     当前bash会话的开头。
              -r读取历史文件的内容并将其用作当前历史记录。
              -w将当前历史记录写入历史文件，覆盖历史文件
                     内容。
              -p对以下args执行历史记录替换并显示结果
                     标准输出。不将结果存储在历史列表中。每
                     必须引用arg才能禁用正常的历史记录扩展。
              -s将args作为单个条目存储在历史列表中。最后一个命令
                     在添加args之前删除历史列表。

              如果设置了HISTTIMEFORMAT变量，则与时间戳信息关联
              每个历史记录条目都写入历史记录文件，标记有历史记录
              字符。读取历史记录文件时，以历史记录开头的行
              紧跟一个数字的字符被解释为前面的时间戳
              虔诚的历史路线。除非遇到无效选项，否则返回值为0
              读取或写入历史文件时发生错误，无效偏移是支持
              作为-d的参数，或作为-p的参数提供的历史扩展
              失败。

       工作[-lnprs] [jobspec ...]
       jobs -x命令[args ...]
              第一个表单列出了活动作业。选项具有以下含义：
              -l除正常信息外，还列出进程ID。
              -n仅显示自用户以来状态已更改的作业的信息
                     最后通知他们的状态。
              -p仅列出作业进程组组长的进程ID。
              -r将输出限制为正在运行的作业。
              -s将输出限制为已停止的作业。

              如果给出了jobspec，则输出仅限于有关该作业的信息。回报
              状态为0，除非遇到无效选项或无效的jobspec支持
              合股。

              如果提供了-x选项，则作业将替换command或args中找到的所有jobspec
              使用相应的进程组ID，并执行命令传递args，
              返回其退出状态。

       kill [-s sigspec | -n signum | -sigspec] [pid | jobspec] ......
       kill -l [sigspec | EXIT_STATUS]
              将由sigspec或signum命名的信号发送到由pid或jobspec命名的进程。
              sigspec是一个不区分大小写的信号名称，如SIGKILL（有或没有
              SIG前缀）或信号编号; signum是一个信号编号。如果sigspec不是
              现在，假设SIGTERM。 -l的参数列出了信号名称。如果有的话
              给出-l时提供的参数，对应的信号名称
              列出参数，返回状态为0. exit_status参数为
              -l是指定进程的信号编号或退出状态的编号
              由信号终止。如果至少有一个信号成功，则kill返回true
              发送错误，如果发生错误或遇到无效选项，则为false。

       let arg [arg ...]
              每个arg都是一个要评估的算术表达式（参见算术评估
              以上）。如果最后一个arg的计算结果为0，则返回1;否则返回0。

       local [option] [name [= value] ...]
              对于每个参数，将创建名为name的局部变量，并为其指定值。该
              option可以是declare接受的任何选项。当本地使用时
              函数，它使变量名称的可见范围限制为该范围
              功能及其子女。如果没有操作数，本地会写入局部变量列表
              到标准输出。不在函数内时使用local是错误的。
              除非在函数外部使用local，否则返回状态为0，无效名称为
              提供，或名称是只读变量。

       logout退出登录shell。

       mapfile [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]
       readarray [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]
              从标准输入到索引数组变量数组或从中读取行
              文件描述符fd如果提供了-u选项。变量MAPFILE是
              默认数组。选项（如果提供）具有以下含义：
              -n复制最多计数行。如果count为0，则复制所有行。
              -O开始在索引源处分配数组。默认索引为0。
              -s丢弃读取的第一个计数行。
              -t从每行读取中删除尾部换行符。
              -u从文件描述符fd而不是标准输入读取行。
              -C每次读取量子线时评估回调。 -c选项指定
                     量子。
              -c指定每次调用回调之间读取的行数。

              如果在没有-c的情况下指定-C，则默认量程为5000.当回调是评估时 - 
              ated，它提供了要分配的下一个数组元素的索引和行
              要作为附加参数分配给该元素。之后评估回调
              在读取数组元素之前读取该行。

              如果未提供显式原点，则mapfile将在分配之前清除数组
              它。

              mapfile成功返回，除非有无效的选项或选项参数支持
              plied，数组无效或不可分配，或者数组不是索引数组。

       popd [-n] [+ n] [-n]
              从目录堆栈中删除条目。没有参数，删除顶部的方向 - 
              来自堆栈的tory，并执行cd到新的顶级目录。争论，如果支持
              合作，具有以下含义：
              -n从中删除目录时禁止正常更改目录
                     堆栈，以便只处理堆栈。
              + n删除dirs所示列表左侧的第n个条目，
                     从零开始。例如：``popd +0''删除第一个目录，
                     ``popd +1''第二个。
              -n删除dirs所示列表右侧的第n个条目，
                     从零开始。例如：``popd -0''删除最后一个目录，
                     ``popd -1''倒数第二个。

              如果popd命令成功，也会执行dirs，并且返回sta
              tus为0.如果遇到无效选项，popd将返回false，即目录
              stack为空，指定了不存在的目录堆栈条目或目录
              改变失败。

       printf [-v var] format [arguments]
              在for-的控制下将格式化的参数写入标准输出
              垫。 -v选项导致将输出分配给变量var而不是
              被打印到标准输出。

              格式是一个包含三种类型对象的字符串：plain char-
              acters，简单地复制到标准输出，字符转义序列，
              转换并复制到标准输出和格式规范，
              每一个都会导致打印下一个连续的参数。除了
              标准printf（1）格式规范，printf解释以下exten-
              sions：
              ％b导致printf在相应的论证中扩展反斜杠转义序列
                     （除了\ c终止输出，\'，\“和\？中的反斜杠都不是
                     删除，以\ 0开头的八进制转义可能包含最多四位数字）。
              ％q使printf以可以的格式输出相应的参数
                     重用为shell输入。
              ％（datefmt）笔
                     导致printf输出使用datefmt作为结果的日期时间字符串
                     strftime（3）的格式字符串。相应的参数是整数
                     表示自纪元以来的秒数。两个特殊的论点
                     可以使用以下值：-1表示当前时间，-2表示当前时间
                     调用shell的时间。

              非字符串格式说明符的参数被视为C常量，但a除外
              允许使用前导加号或减号，如果前导字符是单个或
              双引号，该值是以下字符的ASCII值。

              必要时重用该格式以使用所有参数。如果是格式
              需要的参数多于提供的参数，额外的格式规范表现为
              如果提供了零值或空字符串（如果适用）。返回值
              成功时为零，失败时为非零。

       pushd [-n] [+ n] [-n]
       pushd [-n] [dir]
              将目录添加到目录堆栈的顶部，或者旋转堆栈，制作
              新的堆栈顶部当前工作目录。没有争论，交流
              除非目录堆栈为空，否则前两个目录并返回0。论元
              如果提供，则具有以下含义：
              -n在向目录添加目录时禁止正常更改目录
                     堆栈，以便只处理堆栈。
              + n旋转堆栈以便第n个目录（从左侧开始计数）
                     dirs显示的列表，从零开始）位于顶部。
              -n旋转堆栈以便第n个目录（从右侧开始计数）
                     dirs显示的列表，从零开始）位于顶部。
              dir将dir添加到顶部的目录堆栈，使其成为新的当前工作
                     目录。

              如果pushd命令成功，则也执行dirs。如果是第一个表格
              使用，pushd返回0，除非cd到dir失败。用第二种形式，推
              返回0，除非目录堆栈为空，一个不存在的目录堆栈ele-
              指定了ment，或者目录更改为指定的新当前目录
              失败。

       pwd [-LP]
              打印当前工作目录的绝对路径名。打印的路径名
              如果提供了-P选项或者-o physical选项，则不包含符号链接
              set builtin命令已启用。如果使用-L选项，则打印路径名
              可能包含符号链接。返回状态为0，除非发生错误
              读取当前目录的名称或提供无效选项。

       read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t time-
       out] [-u fd] [name ...]
              从标准输入读取一行，或从提供的文件描述符fd读取
              -u选项的参数，第一个单词分配给第一个名称，即
              第二个字到第二个名字，依此类推，剩下的字和他们的介入
              分配给姓氏的分隔符。如果从输入中读取的单词较少
              流比名称，其余名称分配空值。中的人物
              IFS用于将行拆分为单词。可以使用反斜杠字符（\）
              删除下一个字符读取和行继续的任何特殊含义。
              选项（如果提供）具有以下含义：
               - 一个人
                     这些单词被分配给数组变量aname的顺序索引，
                     从0开始。在分配任何新值之前，未设置aname。其他
                     名称参数被忽略。
              -d delim
                     delim的第一个字符用于终止输入行，而不是
                     新队。
              -e如果标准输入来自终端，则为readline（参见READLINE
                     以上）用于获得该线。 Readline使用当前（或默认，如果
                     行编辑以前没有激活）编辑设置。
              -i文字
                     如果使用readline读取行，则将文本放入编辑中
                     编辑开始前的缓冲区。
              -n nchars
                     读取nchars字符后读取返回而不是等待com-
                     完整的输入行，但如果少于nchars字符，则表示分隔符
                     在分隔符之前读取。
              -N nchars
                     读取完全nchars字符后读取返回而不是等待
                     完整的输入线，除非遇到EOF或读取超时。
                     输入中遇到的分隔符不会被特殊处理
                     在读取nchars字符之前不要导致读取。
              -p提示
                     在尝试之前显示标准错误的提示，没有尾随换行符
                     阅读任何输入。仅在输入来自时才显示提示
                     一个终端。
              -r反斜杠不作为转义字符。考虑反斜杠
                     成为该行的一部分。特别是，反斜杠 - 换行符可能不是
                     用作续行。
              -s静音模式。如果输入来自终端，则不回显字符。
              -t超时
                     如果没有完整的输入行，则会导致读取超时并返回失败
                     在超时秒内读取。超时可能是一个带小数的十进制数
                     小数点后面的部分。此选项仅在以下情况下有效
                     read是从终端，管道或其他特殊文件读取输入;它没有
                     从常规文件中读取时的效果。如果timeout为0，则read返回成功
                     cess如果输入在指定的文件描述符上可用，则失败 - 
                     明智的。如果超出超时，则退出状态大于128。
              -u fd从文件描述符fd读取输入。

              如果未提供名称，则将读取的行分配给变量REPLY。该
              返回代码为零，除非遇到文件结尾，读取超时（其中
              返回代码大于128的情况，或者提供了无效的文件描述符
              作为-u的参数。

       readonly [-aAf] [-p] [name [= word] ...]
              给定的名称标记为只读;这些名称的值不能改变
              后续任务。如果提供了-f选项，则对应的函数
              名字是如此标记。 -a选项将变量限制为索引数组;
              -A选项将变量限制为关联数组。如果两个选项都是
              提供，-A优先。如果没有给出名称参数，或者是-p选项
              如果提供，则打印所有只读名称的列表。可以使用其他选项
              将输出限制为只读名称集的子集。 -p选项
              导致输出以可重复用作输入的格式显示。如果变量
              能够名称后跟= word，变量的值设置为word。该
              除非遇到无效选项，否则返回状态为0，其中一个名称不是
              一个有效的shell变量名，或者-f提供的名称不是函数。

       return [n]
              使函数以n指定的返回值退出。如果省略n，
              返回状态是函数体中执行的最后一个命令的状态。如果
              在函数外部使用，但在执行脚本期间。 （来源）com-
              mand，它会导致shell停止执行该脚本并返回n或者
              在脚本中执行的最后一个命令的退出状态作为退出状态
              脚本。如果在函数外部使用而不是在执行脚本期间使用，则
              返回状态为false。执行与RETURN陷阱关联的任何命令
              在执行函数或脚本之后恢复之前。

       set [--abefhkmnptuvxBCEHPT] [-o选项名称] [arg ...]
    set [+ abefhkmnptuvxBCEHPT] [+ o选项名称] [arg ...]
              如果没有选项，每个shell变量的名称和值都以格式显示
              可以重复用作设置或重置当前设置变量的输入。
              只读变量无法重置。在posix模式下，只有shell变量
              上市。输出根据当前区域设置进行排序。当选项时
              指定时，它们设置或取消设置shell属性。选项后剩余的任何参数
              处理被视为位置参数的值并被分配
              订单，$ 1，$ 2，... $ n。选项（如果指定）具有以下含义：
              -a自动标记为其修改或创建的变量和函数
                      导出到后续命令的环境。
              -b立即报告已终止后台作业的状态，而不是
                      在下一个主要提示之前。这仅在作业控制时有效
                      启用。
              -e如果管道（可能由一个简单的组件组成）立即退出
                      mand），括在括号中的子shell命令，或其中一个命令
                      作为括号括起来的命令列表的一部分执行（参见SHELL GRAMMAR
                      以上）以非零状态退出。如果命令，shell不会退出
                      失败是命令列表的一部分，紧接着一段时间或
                      直到关键字，if或elif保留字后面的测试的一部分，
                      在&&或||中执行的任何命令的一部分除以下命令之外的列表
                      最后的&&或||，管道中的任何命令，但最后一个，或者如果是
                      mand的返回值正在被反转！ ERR上的陷阱（如果设置）是
                      在shell退出之前执行。此选项适用于shell环境
                      分别与每个子壳环境相关（参见COMMAND EXECUTION ENVI-
                      上面的RONMENT，并且可能导致子shell在执行所有之前退出
                      子shell中的命令。
              -f禁用路径名扩展。
              -h在查找执行命令时记住命令的位置。这个
                      默认情况下启用。
              -k赋值语句形式的所有参数都放在环境中
                      命令的ronment，而不仅仅是命令名称之前的命令。
              -m监控模式。作业控制已启用。默认情况下，此选项处于启用状态
                      支持它的系统上的交互式shell（参见上面的JOB CONTROL）。
                      后台进程在单独的进程组和包含的行中运行
                      他们的退出状态在完成后打印。
              -n读取命令但不执行它们。这可用于检查shell
                      语法错误的脚本。交互式shell会忽略它。
              -o选项名称
                      选项名称可以是以下之一：
                      allexport
                              与-a相同。
                      braceexpand
                              与-B相同。
                      emacs使用emacs样式的命令行编辑界面。这已启用
                              默认情况下，当shell是交互式时，除非shell是
                              以--noediting选项开始。这也会影响编辑
                              用于读取-e的接口。
                      errexit与-e相同。
                      errtrace
                              与-E相同。
                      functrace
                              与-T相同。
                      hashall与-h相同。
                      histexpand
                              与-H相同。
                      history启用命令历史记录，如上面HISTORY中所述。这个
                              默认情况下，交互式shell中的选项处于启用
                      了ignoreeof
                              效果就好像shell命令``IGNOREEOF = 10''已被执行
                              cuted（参见上面的Shell变量）。
                      keyword与-k相同。
                      monitor与-m相同。
                      noclobber选项
                              与-C相同。
                      noexec与-n相同。
                      noglob与-f相同。
                      nolog目前被忽略了。
                      通知与-b相同。
                      nounset与-u相同。
                      onecmd与-t相同。
                      物理
                              与-P相同。
                      pipefail
                              如果设置，管道的返回值是最后一个的值
                              （最右边）命令以非零状态退出，如果全部退出则为零
                              管道中的命令成功退出。此选项已禁用
                              默认情况下。
                      posix更改默认操作不同的bash的行为
                              POSIX标准与标准（posix模式）相匹配。
                      特权
                              与-p相同。
                      verbose与-v相同。
                      vi使用vi样式的命令行编辑界面。这也会影响
                              用于读取-e的编辑界面。
                      xtrace与-x相同。
                      如果-o没有选项名称，则当前选项的值为
                      打印。如果+ o没有option-name，则提供一系列set命令
                      重新创建当前选项设置显示在标准输出上。
              -p启用特权模式。在此模式下，$ ENV和$ BASH_ENV文件不是
                      处理后，shell函数不是从环境中继承而来的
                      SHELLOPTS，BASHOPTS，CDPATH和GLOBIGNORE变量，如果它们出现在
                      环境，被忽略了。如果shell是由有效用户启动的
                      （group）id不等于真实用户（组）id，而-p选项不等于
                      提供，执行这些操作，并将有效用户ID设置为
                      真实的用户ID。如果启动时提供-p选项，则为有效用户
                      id未重置。关闭此选项会导致有效的用户和
                      要将组ID设置为真实用户和组ID。
              -t读取并执行一个命令后退出。
              -u处理除特殊参数“@”以外的未设置变量和参数
                      和“*”作为执行参数扩展时的错误。如果扩张是
                      尝试对未设置的变量或参数，shell打印错误信息
                      sage，如果不是交互式，则以非零状态退出。
              -v在读取时打印shell输入行。
              -x扩展每个简单命令后，对于command，case命令，选择com-
                      mand，或arithmetic for command，显示PS4的扩展值，紧接着
                      通过命令及其扩展的参数或相关的单词列表。
              -B shell执行大括号扩展（参见上面的Brace Expansion）。这是开启
                      默认情况下。
              -C如果设置，bash不会使用>，>＆和<>重新覆盖现有文件
                      方向运营商。在创建输出文件时，可以覆盖此项
                      使用重定向运算符> |而不是>。
              -E如果设置，ERR上的任何陷阱都由shell函数继承，命令替换 - 
                      子shell和子shell环境中执行的命令。 ERR陷阱是
                      通常不会在这种情况下继承。
              -H启用！风格历史替代。默认情况下，此选项处于启用状态
                      shell是交互式的。
              -P如果设置，则在执行命令时shell不遵循符号链接
                      例如改变当前工作目录的cd。它使用物理
                      目录结构而不是。默认情况下，bash遵循逻辑链
                      执行更改当前目录的命令时的目录。
              -T如果设置，则DEBUG和RETURN上的任何陷阱都由shell函数继承，
                      mand替换，以及在子shell环境中执行的命令。该
                      在这种情况下，DEBUG和RETURN陷阱通常不会被继承。
               - 如果此选项后面没有参数，则位置参数为
                      未设置。否则，即使位置参数也设置为args
                      其中一些以 - 开头。
               - 发出选项结束信号，将所有剩余的args分配给
                      位置参数。 -x和-v选项已关闭。如果有
                      没有args，位置参数保持不变。

              除非另有说明，否则默认情况下关闭选项。使用+而不是 - 原因
              这些选项要关闭。选项也可以指定为参数
              一个shell的调用。当前的选项集可以在$  - 中找到。该
              除非遇到无效选项，否则返回状态始终为true。

       转移[n]
              来自n + 1 ...的位置参数被重命名为$ 1 ....参数代表
              数字$＃下调至$＃ -  n + 1未被设置。 n必须是非负数
              小于或等于$＃。如果n为0，则不更改任何参数。如果没有给出n，
              它假设为1.如果n大于$＃，则位置参数不是
              改变。如果n大于$＃或更小，则返回状态大于零
              比零;否则为0。

       shopt [-pqsu] [-o] [optname ...]
              切换控制可选shell行为的变量值。没有
              选项，或使用-p选项，显示所有可设置选项的列表，并带有
              指示是否已设置。 -p选项导致输出为dis-
              以可以重复用作输入的形式播放。其他选项有以下几种
              含义：
              -s启用（设置）每个optname。
              -u禁用（取消设置）每个optname。
              -q禁止正常输出（安静模式）;返回状态表示是否
                     optname已设置或未设置。如果给出了多个optname参数
                     -q，如果启用了所有optnames，则返回状态为零;非零其他 - 
                     明智的。
              -o将optname的值限制为为-o选项定义的值
                     设置内置。

              如果使用-s或-u且没有optname参数，则显示仅限于
              分别设置或取消设置的选项。除非另有说明，否则
              默认情况下，shopt选项被禁用（未设置）。

              如果启用了所有optnames，则列出选项时的返回状态为零，非零
              除此以外。设置或取消设置选项时，返回状态为零，除非
              optname不是有效的shell选项。

              shopt选项列表是：

              autocd如果设置，则作为目录名称的命令名称将作为i执行
它
                      是cd命令的参数。此选项仅供交互使用
                      贝壳。
              cdable_vars
                      如果设置，则cd builtin命令的参数不是目录
                      假定是变量的名称，其值是要更改的目录
                      至。
              cdspell如果设置，cd com中目录组件的拼写中的小错误
                      授权将得到纠正。检查的错误是转置字符，a
                      缺少一个角色，一个角色太多了。如果找到更正，
                      打印更正的文件名，然后命令继续。这个选项
                      仅供交互式shell使用。
              checkhash
                      如果设置，bash将检查哈希表中找到的命令是否存在
                      试图执行它。如果散列命令不再存在，则为正常路径
                      搜索已执行。
              checkjobs
                      如果设置，bash会在退出之前列出任何已停止和正在运行的作业的状态
                      交互式shell。如果正在运行任何作业，则会导致退出
                      推迟到第二次退出时没有干预命令
                      （见上面的JOB CONTROL）。如果有任何工作，shell总是推迟退出
                      停止。
              checkwinsize
                      如果设置，bash会在每个命令后检查窗口大小，如果需要，
                      更新LINES和COLUMNS的值。
              cmdhist如果设置，bash会尝试保存多行命令的所有行
                      相同的历史记录。这样可以轻松地重新编辑多行命令。
              compat31
                      如果设置，bash将其行为更改为版本3.1的行为
                      引用[[条件命令的=〜运算符]的参数。
              compat32
                      如果设置，bash将其行为更改为版本3.2的行为
                      使用[[条件命令的<]时特定于语言环境的字符串比较
                      和>运营商。 bash-4.1之前的Bash版本使用ASCII排序规则和
                      的strcmp（3）; bash-4.1及更高版本使用当前语言环境的归类序列
                      和strcoll（3）。
              compat40
                      如果设置，bash将其行为更改为版本4.0的行为
                      使用[[条件命令的<]时特定于语言环境的字符串比较
                      和>运算符（参见上一项）以及中断命令的效果
                      名单。
              compat41
                      如果设置，bash，在posix模式下，用双引号处理单引号
                      参数扩展为特殊字符。单引号必须匹配
                      （偶数）和单引号之间的字符被考虑
                      引。这是posix模式到4.1版的行为。该
                      默认的bash行为仍然与以前的版本一样。
              direxpand
                      如果设置，bash将使用单词扩展的结果替换目录名称
                      执行文件名完成时。这改变了阅读的内容 - 
                      行编辑缓冲区。如果未设置，bash会尝试保留用户的内容
                      类型。
              dirspell
                      如果设置，bash会在单词期间尝试对目录名进行拼写校正
                      如果最初提供的目录名称不存在，则完成。
              dotglob如果设置，bash包含以“。”开头的文件名。在路径的结果 - 
                      名称扩展。
              execfail
                      如果设置，如果无法执行文件，则不会退出非交互式shell
                      指定为exec builtin命令的参数。交互式shell
                      如果exec失败，则不会退出。
              expand_aliases
                      如果设置，则如上所述在ALIASES下扩展别名。这个选项
                      默认情况下为交互式shell启用。
              extdebug
                      如果设置，则启用供调试器使用的行为：
                      1. declare builtin的-F选项显示源文件名
                             和作为一个提供的每个函数名对应的行号
                             论点。
                      2.如果DEBUG陷阱运行的命令返回非零值，则
                             跳过下一个命令而不执行。
                      3.如果DEBUG陷阱运行的命令返回值2，则
                             shell正在子例程（shell函数或shell）中执行
                             脚本执行的。或来源内置），一个回复的呼吁是
                             模拟。
                      4. BASH_ARGC和BASH_ARGV按其描述中的描述进行更新。
                             以上。
                      5.启用了函数跟踪：命令替换，shell函数，
                             和（命令）调用的子shell继承DEBUG和RETURN
                             陷阱。
                      6.启用了错误跟踪：命令替换，shell函数和
                             用（命令）调用的子shell继承ERR陷阱。
              extglob如果设置，则上面描述的扩展模式匹配功能
                      名称扩展已启用。
              extquote
                      如果设置，$'string'和$“string”引用在$ {parameter}内执行
                      扩展名用双引号括起来。默认情况下启用此选项。
              failglob
                      如果设置，则在路径名扩展期间无法匹配文件名的模式
                      导致扩展错误。
              force_fignore
                      如果设置，则由FIGNORE shell变量指定的后缀会导致单词
                      在执行单词完成时被忽略，即使被忽略的单词是
                      只有可能的完成。有关说明，请参见上面的SHELL VARIABLES
                      FIGNORE。默认情况下启用此选项。
              globstar
                      如果设置，路径名扩展上下文中使用的模式**将匹配所有
                      文件和零个或多个目录和子目录。如果模式是
                      后跟一个/，只有目录和子目录匹配。
              gnu_errfmt
                      如果设置，则会在标准GNU错误消息中写入shell错误消息
                      格式。
              histappend
                      如果设置，则历史列表将附加到由值的名称命名的文件中
                      shell退出时的HISTFILE变量，而不是覆盖文件。
              histreedit
                      如果设置，并且正在使用readline，则用户有机会重新
                      编辑失败的历史记录替换。
              histverify
                      如果设置，并且正在使用readline，则历史替换的结果为
                      没有立即传递给shell解析器。相反，生成的行是
                      加载到readline编辑缓冲区，允许进一步修改。
              hostcomplete
                      如果设置，并且正在使用readline，bash将尝试执行主机名
                      完成包含@的单词时的完成（请参阅完成
                      在READLINE上面）。默认情况下启用此选项。
              huponexit
                      如果设置，bash将在交互式登录shell时向所有作业发送SIGHUP
                      退出。
              interactive_comments
                      如果设置，则允许以＃开头的单词导致该单词和所有剩余单词
                      该行上的字符在交互式shell中被忽略（参见COMMENTS
                      以上）。默认情况下启用此选项。
              lastpipe
                      如果设置，并且作业控制未激活，则shell运行a的最后一个命令
                      管道未在当前shell环境中的后台执行。
              lithist如果设置，并且启用了cmdhist选项，则会保存多行命令
                      嵌入换行符而不是使用分号分隔符的历史记录
                      在可能的情况。
              login_shell
                      如果shell作为登录shell启动，则shell会设置此选项（请参阅INVOCATION
                      以上）。该值可能不会更改。
              mailwarn
                      如果设置，则从那时起访问了bash正在检查邮件的文件
                      最后一次检查，邮件``邮件邮件已经邮件
                      显示“是”。
              no_empty_cmd_completion
                      如果设置，并且正在使用readline，则bash将不会尝试搜索PATH
                      在空行上尝试完成时可能的完成。
              nocaseglob
                      如果设置，bash在执行时以不区分大小写的方式匹配文件名
                      路径名扩展（请参阅上面的路径名扩展）。
              nocasematch
                      如果设置，bash在执行时以不区分大小写的方式匹配模式
                      执行大小写时匹配或[[条件命令。
              了nullglob
                      如果设置，bash允许不匹配任何文件的模式（请参阅路径名扩展
                      上面）扩展为空字符串，而不是自己。
              progcomp
                      如果设置，则可编程完成设施（参见可编程完成
                      以上）已启用。默认情况下启用此选项。
              promptvars
                      如果设置，则提示字符串经历参数扩展，命令替换，
                      扩展后的算术扩展和引用删除，如中所述
                      提到上面。默认情况下启用此选项。
              restricted_shell
                      如果以限制模式启动，shell会设置此选项（请参阅
                      受限制的壳下面）。该值可能不会更改。这不会重置
                      执行启动文件时，允许启动文件发现
                      shell是否受限制。
              shift_verbose
                      如果设置，shift builtin在移位计数时打印错误消息
                      超过位置参数的数量。
              源路径
                      如果设置，源（。）builtin使用PATH的值来查找目录
                      包含作为参数提供的文件。此选项已启用
                      默认。
              xpg_echo
                      如果设置，echo builtin默认会扩展反斜杠转义序列。

       暂停[-f]
              挂起此shell的执行，直到收到SIGCONT信号。当。。。的时候
              suspell shell是后台进程，可以通过fg命令重启。对于
              更多信息，请阅读JOB CONTROL部分。 suspend命令无法挂起
              登录shell。但是，如果指定了-f选项，则suspend命令可以挂起
              甚至登录shell。返回状态为0，除非shell是登录shell和-f
              未提供，或者未启用作业控制。

       测试expr
       [expr]
              根据条件表达式的计算，返回0或1的状态
              EXPR。每个运算符和操作数必须是单独的参数。表达式是
              在有条件的表达下提出的上述初选。测试没有
              接受任何选择，也不接受和忽略 - 作为表示的论点
              选项的结束。

              表达式可以使用以下运算符组合，以递减列出
              优先顺序。评估取决于论点的数量;见下文。
              当有五个或更多参数时，使用运算符优先级。
              ！ expr如果expr为false则为True。
              （expr）
                     返回expr的值。这可以用来覆盖正常的先例 - 
                     经营者。
              expr1 -a expr2
                     如果expr1和expr2都为真，则为真。
              expr1 -o expr2
                     如果expr1或expr2为真，则为真。

              测试和[使用基于数字的一组规则来评估条件表达式
              论点。

              0个参数
                     表达式是假的。
              1个论点
                     当且仅当参数不为null时，表达式才为真。
              2个论点
                     如果第一个参数是！，当且仅当第二个参数时，表达式为真
                     参数为null。如果第一个参数是一元条件之一
                     上面列出的条件表达式下的运算符，表达式为真
                     如果一元测试是真的。如果第一个参数不是有效的一元条件 - 
                     运营商，表达是假的。
              3个论点
                     以下列条件适用于所列顺序。如果是第二个
                     参数是上面列出的CONDI-中的二元条件运算符之一
                     TIONAL EXPRESSIONS，表达式的结果是二进制的结果
                     使用第一个和第三个参数作为操作数进行测试。 -a和-o opera-
                     当有三个参数时，tors被认为是二元运算符。如果
                     第一个参数是！，该值是使用的两个参数测试的否定
                     第二和第三个论点。如果第一个参数是完全正确的（和
                     第三个参数确切地说，结果是第二个参数测试
                     ond论点。否则，表达式为false。
              4个论点
                     如果第一个参数是！，则结果是三参数的否定
                     表达式由其余参数组成。否则，表达式是
                     使用上面列出的规则根据优先级进行解析和评估。
              5个或更多参数
                     使用。根据优先级解析和评估表达式
                     上面列出的规则。

              当与test或[，<和>运算符一起使用时，使用ASCII按字典顺序排序
              排序。

       times打印shell的累计用户和系统时间以及运行的进程
              贝壳。返回状态为0。

       trap [-lp] [[arg] sigspec ...]
              当shell收到信号时，将读取并执行命令arg
              SIGSPEC。如果没有arg（并且有一个sigspec）或 - ，则每个指定的sig-
              nal被重置为其原始处置（进入该处时的值）
              贝壳）。如果arg是空字符串，则忽略每个sigspec指定的信号
              由shell和它调用的命令。如果arg不存在且-p已经存在
              如果提供，则显示与每个sigspec关联的陷阱命令。如果不
              提供了参数，或者如果只给出-p，则trap打印命令列表
              与每个信号相关联。 -l选项使shell打印一个sig-列表
              最终名称及其相应的数字。每个sigspec都是一个信号名称
              在<signal.h>中定义，或信号编号。信号名称不区分大小写
              SIG前缀是可选的。

              如果sigspec是EXIT（0），则命令arg在从shell退出时执行。如果一个
              sigspec是DEBUG，命令arg在每个简单命令之前执行，
              mand，case命令，select命令，命令的每个算术，以及之前的命令
              第一个命令在shell函数中执行（参见上面的SHELL GRAMMAR）。参考
              内置商店的extdebug选项的描述，以了解其对其影响的详细信息
              DEBUG陷阱。如果sigspec是RETURN，则每次执行命令arg
              shell函数或用它执行的脚本。或源内置完成执行 - 
              ING。

              如果sigspec是ERR，则只要一个简单的命令有一个命令就执行命令arg
              非零退出状态，符合以下条件。 ERR陷阱不是exe-
              如果失败的命令是紧跟在a之后的命令列表的一部分
              while或until关键字，if语句中的部分测试，命令exe的一部分
              在&&或||中提取列表，或者命令的返回值是否被反转！
              这些是errexit选项遵循的相同条件。

              进入shell时忽略的信号不能被捕获，重置或列出。被困
              未被忽略的信号将重置为子shell中的原始值
              创建一个或子shell环境。如果有的话，返回状态为false
              sigspec无效;否则陷阱返回true。

       input [-aftpP]名称[名称...]
              如果没有选项，请指明在用作命令时如何解释每个名称
              名称。如果使用-t选项，则键入打印字符串，该字符串是别名之一，key-
              word，function，builtin或file如果name是别名，shell保留字，函数，
              内置或磁盘文件。如果找不到名称，那么什么都没有
              打印，并返回退出状态false。如果使用-p选项，请键入
              如果名称是speci，则返回将执行的磁盘文件的名称
              作为命令名称，或者如果``type -t name''不会返回文件。该
              -P选项强制PATH搜索每个名称，即使``type -t name''也不会
              返回文件。如果对命令进行哈希处理，则-p和-P将打印散列值，而不是neces-
              在PATH中首先出现的文件。如果使用-a选项，请键入prints
              包含名为name的可执行文件的所有位置。这包括别名和
              函数，当且仅当不使用-p选项时。哈希表
              使用-a时不咨询mands。 -f选项禁止shell函数
              查找，与内置命令一样。如果所有参数都是，则返回true
              发现，如果没有找到，则为false。

       ulimit [-HSTabcdefilmnpqrstuvx [limit]]
              提供对shell可用资源和已启动进程的控制
              通过它，在允许这种控制的系统上。 -H和-S选项指定了
              为给定资源设置硬限制或软限制。硬限制不能增加
              设置后由非root用户设置;软限制可以增加到值
              硬限制。如果既未指定-H也未指定-S，则均为软限制和硬限制
              已设定。 limit的值可以是为资源指定的单位中的数字
              或其中一个特殊值，硬，软或无限，代表当前
              硬限制，当前软限制，无限制。如果省略限制 - 
              ted，打印资源的软限制的当前值，除非-H
              给出了选项。指定多个资源时，限制名称和单位
              在价值之前印刷。其他选项解释如下：
              -a报告所有当前限制
              -b最大套接字缓冲区大小
              -c创建的核心文件的最大大小
              -d进程数据段的最大大小
              -e最大调度优先级（“nice”）
              -f shell及其子项写入的文件的最大大小
              -i待处理信号的最大数量
              -l可以锁定到内存的最大大小
              -m最大驻留集大小（许多系统不遵守此限制）
              -n打开文件描述符的最大数量（大多数系统不允许这样做
                     要设定的值）
              -p 512字节块中的管道大小（可能未设置）
              -q POSIX消息队列中的最大字节数
              -r最大实时调度优先级
              -s最大堆栈大小
              -t以秒为单位的最大CPU时间量
              -u单个用户可用的最大进程数
              -v shell可用的最大虚拟内存量，在某些系统上
                     tems，给它的孩子们
              -x文件锁的最大数量
              -T最大线程数

              如果给出了limit，则它是指定资源的新值（-a选项是
              仅显示）。如果没有给出选项，则假定为-f。值以1024字节为单位
              增量，除了-t，以秒为单位，-p，以512字节为单位
              块和-T，-b，-n和-u，它们是未缩放的值。返回状态为0
              除非提供了无效的选项或参数，否则在设置时会发生错误
              新的限制。在POSIX模式下，512字节块用于`-c'和`-f'选项。

       umask [-p] [-S] [模式]
              用户文件创建掩码设置为mode。如果模式以数字开头，则为
              解释为八进制数;否则它被解释为符号模式掩码
              类似于chmod（1）所接受的。如果省略mode，则为当前值
              面具被打印出来。 -S选项使掩码以符号形式打印;该
              默认输出是八进制数。如果提供了-p选项，则省略模式 - 
              特德，输出的形式可以作为输入重用。如果返回状态为0
              模式已成功更改或未提供模式参数，并且为false
              除此以外。

       unalias [-a] [name ...]
              从已定义的别名列表中删除每个名称。如果提供-a，则为所有别名
              定义被删除。除非提供的名称不是a，否则返回值为true
              别名。

       未设置[-fv] [名称...]
              对于每个名称，删除相应的变量或函数。如果没有选择
              提供，或给出-v选项，每个名称引用一个shell变量。读-
              只有变量可能不会被取消。如果指定了-f，则每个名称都指向一个shell
              函数，并删除函数定义。每个未设置的变量或函数
              从传递给后续命令的环境中删除。如果任何COMP_WORD-
              未设置BREAKS，RANDOM，SECONDS，LINENO，HISTCMD，FUNCNAME，GROUPS或DIRSTACK，
              他们失去了特殊的属性，即使他们随后被重置。出口
              除非名称是只读的，否则status为true。

       等[n ...]
              等待每个指定的进程并返回其终止状态。每个n可以是a
              进程ID或作业规范;如果给出了工作规范，那么所有流程都是如此
              工作的管道等待。如果没有给出n，那么所有当前活跃的孩子都会
              等待cesses，返回状态为零。如果n指定不存在
              进程或作业，返回状态为127.否则，返回状态为退出
              最后一个进程或作业的状态等待。

受限制的壳
       如果以名称rbash启动bash，或者在调用时提供-r选项，则
       外壳变得受限制。受限制的shell用于建立更加环保的环境
       比标准外壳还要笨拙。它的行为与bash相同，但有例外
       以下是不允许或不执行的：

       ·用cd更改目录

       ·设置或取消设置SHELL，PATH，ENV或BASH_ENV的值

       ·指定包含/的命令名

       ·指定包含/作为参数的文件名。内置命令

       ·指定包含斜杠的文件名作为哈希的-p选项的参数
              内置命令

       ·在启动时从shell环境导入函数定义

       ·在启动时从shell环境中解析SHELLOPTS的值

       ·使用>，> |，<>，>＆，＆>和>>重定向运算符重定向输出

       ·使用exec builtin命令将shell替换为另一个命令

       ·使用-f和-d选项向内置命令添加或删除内置命令
              命令

       ·使用enable builtin命令启用禁用的shell内置命令

       ·为命令builtin命令指定-p选项

       ·使用设定+ r或设定+ o限制关闭限制模式。

       在读取任何启动文件后强制执行这些限制。

       当执行找到shell脚本的命令时（请参阅命令执行
       上面），rbash关闭生成的shell中的任何限制来执行脚本。

也可以看看
       Bash参考手册，Brian Fox和Chet Ramey
       Gnu Readline图书馆，Brian Fox和Chet Ramey
       Gnu历史图书馆，Brian Fox和Chet Ramey
       便携式操作系统接口（POSIX）第2部分：Shell和实用程序，IEEE
       sh（1），ksh（1），csh（1）
       emacs（1），vi（1）
       readline的（3）

FILES
       /斌/庆典
              bash可执行文件
       / etc / profile文件
              系统范围的初始化文件，为登录shell执行
       /etc/bash.bash_logout
              系统范围的登录shell清理文件，在登录shell退出时执行
       在〜/ .bash_profile
              为登录shell执行的个人初始化文件
       在〜/ .bashrc
              单个per-interactive-shell启动文件
       〜/ .bash_logout中
              单个登录shell清理文件，在登录shell退出时执行
       〜/ .inputrc文件
              单独的readline初始化文件

作者
       Brian Fox，自由软件基金会
       bfox@gnu.org

       凯斯西储大学Chet Ramey
       chet.ramey@case.edu

BUG报告
       如果你在bash中发现了一个bug，你应该报告它。但首先，你应该确保它
       真的是一个bug，它出现在最新版本的bash中。最新版本是
       始终可以从ftp://ftp.gnu.org/pub/gnu/bash/获得。

       一旦确定实际存在错误，请使用bashbug命令（来自
       源包）提交错误报告。如果您有修复，建议您发送邮件
       还有！建议和“哲学”错误报告可以邮寄到bug-bash@gnu.org或
       发布到Usenet新闻组gnu.bash.bug。

       所有错误报告应包括：

       bash的版本号
       硬件和操作系统
       用于编译的编译器
       错误行为的描述
       一个简短的脚本或“食谱”，它可以解决这个问题

       有关本手册页的评论和错误报告应直接发送至
       chet.ramey@case.edu。

BUGS
       它太大太慢了。

       bash和传统版本的sh之间存在一些细微差别
       因为POSIX规范。

       别名在某些用途中令人困惑。

       Shell内置命令和函数不可停止/可重新启动。

       复合命令和命令序列形式`a; b; c'没有得到优雅的处理
       当试图暂停过程时。当进程停止时，shell立即生效
       执行序列中的下一个命令。放置命令序列就足够了
       在括号之间强制它进入子壳，它可以作为一个单元停止。

       可能尚未导出数组变量。

       一次可能只有一个活动的协处理器。



GNU Bash-4.2 2010年12月28日BASH（1）
